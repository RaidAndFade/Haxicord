<haxe>
	<class path="Array" params="T" file="/usr/lib/haxe/std/Array.hx" extern="1">
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The length of `this` Array.</haxe_doc>
		</length>
		<concat public="1" set="method">
			<f a="a">
				<c path="Array"><c path="Array.T"/></c>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Returns a new Array by appending the elements of `a` to the elements of
		`this` Array.

		This operation does not modify `this` Array.

		If `a` is the empty Array `[]`, a copy of `this` Array is returned.

		The length of the returned Array is equal to the sum of `this.length`
		and `a.length`.

		If `a` is `null`, the result is unspecified.</haxe_doc>
		</concat>
		<join public="1" set="method">
			<f a="sep">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a string representation of `this` Array, with `sep` separating
		each element.

		The result of this operation is equal to `Std.string(this[0]) + sep +
		Std.string(this[1]) + sep + ... + sep + Std.string(this[this.length-1])`

		If `this` is the empty Array `[]`, the result is the empty String `""`.
		If `this` has exactly one element, the result is equal to a call to
		`Std.string(this[0])`.

		If `sep` is null, the result is unspecified.</haxe_doc>
		</join>
		<pop public="1" set="method">
			<f a=""><t path="Null"><c path="Array.T"/></t></f>
			<haxe_doc>Removes the last element of `this` Array and returns it.

		This operation modifies `this` Array in place.

		If `this` has at least one element, `this.length` will decrease by 1.

		If `this` is the empty Array `[]`, null is returned and the length
		remains 0.</haxe_doc>
		</pop>
		<push public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Adds the element `x` at the end of `this` Array and returns the new
		length of `this` Array.

		This operation modifies `this` Array in place.

		`this.length` increases by 1.</haxe_doc>
		</push>
		<reverse public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[Reverse the order of elements of `this` Array.

		This operation modifies `this` Array in place.

		If `this.length < 2`, `this` remains unchanged.]]></haxe_doc>
		</reverse>
		<shift public="1" set="method">
			<f a=""><t path="Null"><c path="Array.T"/></t></f>
			<haxe_doc>Removes the first element of `this` Array and returns it.

		This operation modifies `this` Array in place.

		If `this` has at least one element, `this`.length and the index of each
		remaining element is decreased by 1.

		If `this` is the empty Array `[]`, `null` is returned and the length
		remains 0.</haxe_doc>
		</shift>
		<slice public="1" set="method">
			<f a="pos:?end">
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Creates a shallow copy of the range of `this` Array, starting at and
		including `pos`, up to but not including `end`.

		This operation does not modify `this` Array.

		The elements are not copied and retain their identity.

		If `end` is omitted or exceeds `this.length`, it defaults to the end of
		`this` Array.

		If `pos` or `end` are negative, their offsets are calculated from the
		end of `this` Array by `this.length + pos` and `this.length + end`
		respectively. If this yields a negative value, 0 is used instead.

		If `pos` exceeds `this.length` or if `end` is less than or equals
		`pos`, the result is `[]`.</haxe_doc>
		</slice>
		<sort public="1" set="method">
			<f a="f">
				<f a=":">
					<c path="Array.T"/>
					<c path="Array.T"/>
					<x path="Int"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[Sorts `this` Array according to the comparison function `f`, where
		`f(x,y)` returns 0 if x == y, a positive Int if x > y and a
		negative Int if x < y.

		This operation modifies `this` Array in place.

		The sort operation is not guaranteed to be stable, which means that the
		order of equal elements may not be retained. For a stable Array sorting
		algorithm, `haxe.ds.ArraySort.sort()` can be used instead.

		If `f` is null, the result is unspecified.]]></haxe_doc>
		</sort>
		<splice public="1" set="method">
			<f a="pos:len">
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc><![CDATA[Removes `len` elements from `this` Array, starting at and including
		`pos`, an returns them.

		This operation modifies `this` Array in place.

		If `len` is < 0 or `pos` exceeds `this`.length, an empty Array [] is 
		returned and `this` Array is unchanged.

		If `pos` is negative, its value is calculated from the end	of `this`
		Array by `this.length + pos`. If this yields a negative value, 0 is
		used instead.

		If the sum of the resulting values for `len` and `pos` exceed
		`this.length`, this operation will affect the elements from `pos` to the
		end of `this` Array.

		The length of the returned Array is equal to the new length of `this`
		Array subtracted from the original length of `this` Array. In other
		words, each element of the original `this` Array either remains in
		`this` Array or becomes an element of the returned Array.]]></haxe_doc>
		</splice>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string representation of `this` Array.

		The result will include the individual elements' String representations
		separated by comma. The enclosing [ ] may be missing on some platforms,
		use `Std.string()` to get a String representation that is consistent
		across platforms.</haxe_doc>
		</toString>
		<unshift public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adds the element `x` at the start of `this` Array.

		This operation modifies `this` Array in place.

		`this.length` and the index of each Array element increases by 1.</haxe_doc>
		</unshift>
		<insert public="1" set="method">
			<f a="pos:x">
				<x path="Int"/>
				<c path="Array.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Inserts the element `x` at the position `pos`.

		This operation modifies `this` Array in place.

		The offset is calculated like so:

		- If `pos` exceeds `this.length`, the offset is `this.length`.
		- If `pos` is negative, the offset is calculated from the end of `this`
		  Array, i.e. `this.length + pos`. If this yields a negative value, the
		  offset is 0.
		- Otherwise, the offset is `pos`.

		If the resulting offset does not exceed `this.length`, all elements from
		and including that offset to the end of `this` Array are moved one index
		ahead.</haxe_doc>
		</insert>
		<remove public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Removes the first occurrence of `x` in `this` Array.

		This operation modifies `this` Array in place.

		If `x` is found by checking standard equality, it is removed from `this`
		Array and all following elements are reindexed accordingly. The function
		then returns true.

		If `x` is not found, `this` Array is not changed and the function
		returns false.</haxe_doc>
		</remove>
		<indexOf public="1" set="method">
			<f a="x:?fromIndex">
				<c path="Array.T"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns position of the first occurrence of `x` in `this` Array, searching front to back.

		If `x` is found by checking standard equality, the function returns its index.

		If `x` is not found, the function returns -1.

		If `fromIndex` is specified, it will be used as the starting index to search from,
		otherwise search starts with zero index. If it is negative, it will be taken as the
		offset from the end of `this` Array to compute the starting index. If given or computed
		starting index is less than 0, the whole array will be searched, if it is greater than
		or equal to the length of `this` Array, the function returns -1.</haxe_doc>
		</indexOf>
		<lastIndexOf public="1" set="method">
			<f a="x:?fromIndex">
				<c path="Array.T"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns position of the last occurrence of `x` in `this` Array, searching back to front.

		If `x` is found by checking standard equality, the function returns its index.

		If `x` is not found, the function returns -1.

		If `fromIndex` is specified, it will be used as the starting index to search from,
		otherwise search starts with the last element index. If it is negative, it will be
		taken as the offset from the end of `this` Array to compute the starting index. If
		given or computed starting index is greater than or equal to the length of `this` Array,
		the whole array will be searched, if it is less than 0, the function returns -1.</haxe_doc>
		</lastIndexOf>
		<copy public="1" set="method">
			<f a=""><c path="Array"><c path="Array.T"/></c></f>
			<haxe_doc>Returns a shallow copy of `this` Array.

		The elements are not copied and retain their identity, so
		`a[i] == a.copy()[i]` is true for any valid `i`. However,
		`a == a.copy()` is always false.</haxe_doc>
		</copy>
		<iterator public="1" set="method">
			<f a=""><t path="Iterator"><c path="Array.T"/></t></f>
			<haxe_doc>Returns an iterator of the Array values.</haxe_doc>
		</iterator>
		<map public="1" params="S" set="method">
			<f a="f">
				<f a="">
					<c path="Array.T"/>
					<c path="map.S"/>
				</f>
				<c path="Array"><c path="map.S"/></c>
			</f>
			<haxe_doc>Creates a new Array by applying function `f` to all elements of `this`.

		The order of elements is preserved.

		If `f` is null, the result is unspecified.</haxe_doc>
		</map>
		<filter public="1" set="method">
			<f a="f">
				<f a="">
					<c path="Array.T"/>
					<x path="Bool"/>
				</f>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Returns an Array containing those elements of `this` for which `f`
		returned true.

		The individual elements are not duplicated and retain their identity.

		If `f` is null, the result is unspecified.</haxe_doc>
		</filter>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Array.</haxe_doc>
		</new>
		<haxe_doc>An Array is a storage for values. You can access it using indexes or
	with its API.

	@see https://haxe.org/manual/std-Array.html
	@see https://haxe.org/manual/lf-array-comprehension.html</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="Class" params="T" file="/usr/lib/haxe/std/Class.hx">
		<this><x path="Class"><c path="Class.T"/></x></this>
		<haxe_doc>An abstract type that represents a Class.

	See `Type` for the Haxe Reflection API.

	@see https://haxe.org/manual/types-class-instance.html</haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<class path="Date" params="" file="/usr/lib/haxe/std/Date.hx" extern="1">
		<now public="1" set="method" static="1">
			<f a=""><c path="Date"/></f>
			<haxe_doc>Returns a Date representing the current local time.</haxe_doc>
		</now>
		<fromTime public="1" set="method" static="1">
			<f a="t">
				<x path="Float"/>
				<c path="Date"/>
			</f>
			<haxe_doc>Returns a Date from timestamp `t`.</haxe_doc>
		</fromTime>
		<fromString public="1" set="method" static="1">
			<f a="s">
				<c path="String"/>
				<c path="Date"/>
			</f>
			<haxe_doc>Returns a Date from a formated string `s`, with the following accepted
		formats:

		- `"YYYY-MM-DD hh:mm:ss"`
		- `"YYYY-MM-DD"`
		- `"hh:mm:ss"`

		The first two formats are expressed in local time, the third in UTC
		Epoch.</haxe_doc>
		</fromString>
		<getTime public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns the timestamp (in milliseconds) of the date. It might
		only have a per-second precision depending on the platforms.</haxe_doc>
		</getTime>
		<getHours public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the hours of `this` Date (0-23 range).</haxe_doc>
		</getHours>
		<getMinutes public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the minutes of `this` Date (0-59 range).</haxe_doc>
		</getMinutes>
		<getSeconds public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the seconds of `this` Date (0-59 range).</haxe_doc>
		</getSeconds>
		<getFullYear public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the full year of `this` Date (4-digits).</haxe_doc>
		</getFullYear>
		<getMonth public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the month of `this` Date (0-11 range).</haxe_doc>
		</getMonth>
		<getDate public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the day of `this` Date (1-31 range).</haxe_doc>
		</getDate>
		<getDay public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the day of the week of `this` Date (0-6 range) where `0` is Sunday.</haxe_doc>
		</getDay>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string representation of `this` Date, by using the
		standard format [YYYY-MM-DD HH:MM:SS]. See `DateTools.format` for
		other formating rules.</haxe_doc>
		</toString>
		<new public="1" set="method">
			<f a="year:month:day:hour:min:sec">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new date object from the given arguments.

		The behaviour of a Date instance is only consistent across platforms if
		the the arguments describe a valid date.

		- month: 0 to 11
		- day: 1 to 31
		- hour: 0 to 23
		- min: 0 to 59
		- sec: 0 to 59</haxe_doc>
		</new>
		<haxe_doc>The Date class provides a basic structure for date and time related
	information. Date instances can be created by

	- `new Date()` for a specific date,
	- `Date.now()` to obtain information about the current time,
	- `Date.fromTime()` with a given timestamp or
	- `Date.fromString()` by parsing from a String.

	There are some extra functions available in the `DateTools` class.

	In the context of Haxe dates, a timestamp is defined as the number of
	milliseconds elapsed since 1st January 1970.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="DateTools" params="" file="/usr/lib/haxe/std/DateTools.hx">
		<DAY_SHORT_NAMES expr="[&quot;Sun&quot;, &quot;Mon&quot;, &quot;Tue&quot;, &quot;Wed&quot;, &quot;Thu&quot;, &quot;Fri&quot;, &quot;Sat&quot;]" line="36" static="1">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]</e></m></meta>
		</DAY_SHORT_NAMES>
		<DAY_NAMES expr="[&quot;Sunday&quot;, &quot;Monday&quot;, &quot;Tuesday&quot;, &quot;Wednesday&quot;, &quot;Thursday&quot;, &quot;Friday&quot;, &quot;Saturday&quot;]" line="37" static="1">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]</e></m></meta>
		</DAY_NAMES>
		<MONTH_SHORT_NAMES expr="[&quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;, &quot;May&quot;, &quot;Jun&quot;, &quot;Jul&quot;, &quot;Aug&quot;, &quot;Sep&quot;, &quot;Oct&quot;, &quot;Nov&quot;, &quot;Dec&quot;]" line="38" static="1">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]</e></m></meta>
		</MONTH_SHORT_NAMES>
		<MONTH_NAMES expr="[&quot;January&quot;, &quot;February&quot;, &quot;March&quot;, &quot;April&quot;, &quot;May&quot;, &quot;June&quot;, &quot;July&quot;, &quot;August&quot;, &quot;September&quot;, &quot;October&quot;, &quot;November&quot;, &quot;December&quot;]" line="39" static="1">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]</e></m></meta>
		</MONTH_NAMES>
		<__format_get set="method" line="41" static="1">
			<f a="d:e">
				<c path="Date"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</__format_get>
		<__format set="method" line="104" static="1"><f a="d:f">
	<c path="Date"/>
	<c path="String"/>
	<c path="String"/>
</f></__format>
		<format public="1" set="method" line="143" static="1">
			<f a="d:f">
				<c path="Date"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Format the date `d` according to the format `f`. The format is
		compatible with the `strftime` standard format, except that there is no
		support in Flash and JS for day and months names (due to lack of proper
		internationalization API). On Haxe/Neko/Windows, some formats are not
		supported.

		```haxe
		var t = DateTools.format(Date.now(), "%Y-%m-%d_%H:%M:%S");
		// 2016-07-08_14:44:05

		var t = DateTools.format(Date.now(), "%r");
		// 02:44:05 PM

		var t = DateTools.format(Date.now(), "%T");
		// 14:44:05

		var t = DateTools.format(Date.now(), "%F");
		// 2016-07-08
		```</haxe_doc>
		</format>
		<haxe_doc>The DateTools class contains some extra functionalities for handling `Date`
	instances and timestamps.

	In the context of Haxe dates, a timestamp is defined as the number of
	milliseconds elapsed since 1st January 1970.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="EReg" params="" file="/usr/lib/haxe/std/EReg.hx">
		<match public="1" set="method" line="59">
			<f a="s">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `this` regular expression matches String `s`.

		This method modifies the internal state.

		If `s` is `null`, the result is unspecified.</haxe_doc>
		</match>
		<matched public="1" set="method" line="74">
			<f a="n">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the matched sub-group `n` of `this` EReg.

		This method should only be called after `this.match` or
		`this.matchSub`, and then operates on the String of that operation.

		The index `n` corresponds to the n-th set of parentheses in the pattern
		of `this` EReg. If no such sub-group exists, an exception is thrown.

		If `n` equals 0, the whole matched substring is returned.</haxe_doc>
		</matched>
		<matchedPos public="1" set="method" line="119">
			<f a=""><a>
	<pos><x path="Int"/></pos>
	<len><x path="Int"/></len>
</a></f>
			<haxe_doc>Returns the position and length of the last matched substring, within
		the String which was last used as argument to `this.match` or
		`this.matchSub`.

		If the most recent call to `this.match` or `this.matchSub` did not
		match anything, the result is unspecified.

		If the global g modifier was in place for the matching, the position and
		length of the leftmost substring is returned.</haxe_doc>
		</matchedPos>
		<new public="1" set="method" line="48">
			<f a="r:opt">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new regular expression with pattern `r` and modifiers `opt`.

		This is equivalent to the shorthand syntax `~/r/opt`

		If `r` or `opt` are null, the result is unspecified.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[The EReg class represents regular expressions.

	While basic usage and patterns consistently work across platforms, some more
	complex operations may yield different results. This is a necessary trade-
	off to retain a certain level of performance.

	EReg instances can be created by calling the constructor, or with the
	special syntax `~/pattern/modifier`

	EReg instances maintain an internal state, which is affected by several of
	its methods.

	A detailed explanation of the supported operations is available at
	<https://haxe.org/manual/std-regex.html>]]></haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<abstract path="Enum" params="T" file="/usr/lib/haxe/std/Enum.hx">
		<this><x path="Enum"><c path="Enum.T"/></x></this>
		<haxe_doc>An abstract type that represents an Enum type.

	The corresponding enum instance type is `EnumValue`.

	See `Type` for the Haxe Reflection API.

	@see https://haxe.org/manual/types-enum-instance.html</haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="EnumValue" params="" file="/usr/lib/haxe/std/EnumValue.hx">
		<this><x path="EnumValue"/></this>
		<haxe_doc>An abstract type that represents any enum value.
	See `Type` for the Haxe Reflection API.

	@see https://haxe.org/manual/types-enum-instance.html</haxe_doc>
		<meta><m n=":coreType"/></meta>
	</abstract>
	<class path="Lambda" params="" file="/usr/lib/haxe/std/Lambda.hx">
		<exists public="1" params="A" set="method" line="141" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="exists.A"/></t>
				<f a="">
					<c path="exists.A"/>
					<x path="Bool"/>
				</f>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `it` contains an element for which `f` is true.

		This function returns true as soon as an element is found for which a
		call to `f` returns true.

		If no such element is found, the result is false.

		If `f` is null, the result is unspecified.</haxe_doc>
		</exists>
		<filter public="1" params="A" set="method" line="185" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="filter.A"/></t>
				<f a="">
					<c path="filter.A"/>
					<x path="Bool"/>
				</f>
				<c path="List"><c path="filter.A"/></c>
			</f>
			<haxe_doc>Returns a List containing those elements of `it` for which `f` returned
		true.

		If `it` is empty, the result is the empty List even if `f` is null.

		Otherwise if `f` is null, the result is unspecified.</haxe_doc>
		</filter>
		<haxe_doc>The `Lambda` class is a collection of methods to support functional
	programming. It is ideally used with `using Lambda` and then acts as an
	extension to Iterable types.

	On static platforms, working with the Iterable structure might be slower
	than performing the operations directly on known types, such as Array and
	List.

	If the first argument to any of the methods is null, the result is
	unspecified.

	@see https://haxe.org/manual/std-Lambda.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="List" params="T" file="/usr/lib/haxe/std/List.hx">
		<h><c path="_List.ListNode"><c path="List.T"/></c></h>
		<q><c path="_List.ListNode"><c path="List.T"/></c></q>
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The length of `this` List.</haxe_doc>
		</length>
		<add public="1" set="method" line="52">
			<f a="item">
				<c path="List.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adds element `item` at the end of `this` List.

		`this.length` increases by 1.</haxe_doc>
		</add>
		<push public="1" set="method" line="67">
			<f a="item">
				<c path="List.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adds element `item` at the beginning of `this` List.

		`this.length` increases by 1.</haxe_doc>
		</push>
		<iterator public="1" get="inline" set="null" line="160">
			<f a=""><c path="_List.ListIterator"><c path="List.T"/></c></f>
			<haxe_doc>Returns an iterator on the elements of the list.</haxe_doc>
		</iterator>
		<new public="1" set="method" line="43">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new empty list.</haxe_doc>
		</new>
		<haxe_doc>A linked-list of elements. The list is composed of element container objects
	that are chained together. It is optimized so that adding or removing an
	element does not imply copying the whole list content every time.

	@see https://haxe.org/manual/std-List.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="_List.ListNode" params="T" file="/usr/lib/haxe/std/List.hx" private="1" module="List">
		<item public="1"><c path="_List.ListNode.T"/></item>
		<next public="1"><c path="_List.ListNode"><c path="_List.ListNode.T"/></c></next>
		<new public="1" set="method" line="255"><f a="item:next">
	<c path="_List.ListNode.T"/>
	<c path="_List.ListNode"><c path="_List.ListNode.T"/></c>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="_List.ListIterator" params="T" file="/usr/lib/haxe/std/List.hx" private="1" module="List">
		<head><c path="_List.ListNode"><c path="_List.ListIterator.T"/></c></head>
		<hasNext public="1" get="inline" set="null" line="272"><f a=""><x path="Bool"/></f></hasNext>
		<next public="1" get="inline" set="null" line="276"><f a=""><c path="_List.ListIterator.T"/></f></next>
		<new public="1" get="inline" set="null" line="268"><f a="head">
	<c path="_List.ListNode"><c path="_List.ListIterator.T"/></c>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<abstract path="Map" params="K:V" file="/usr/lib/haxe/std/Map.hx">
		<from>
			<icast field="fromStringMap"><c path="haxe.ds.StringMap"><c path="fromStringMap.V"/></c></icast>
			<icast field="fromIntMap"><c path="haxe.ds.IntMap"><c path="fromIntMap.V"/></c></icast>
			<icast field="fromObjectMap"><c path="haxe.ds.ObjectMap">
	<c path="fromObjectMap.K"/>
	<c path="fromObjectMap.V"/>
</c></icast>
		</from>
		<this><t path="IMap">
	<c path="Map.K"/>
	<c path="Map.V"/>
</t></this>
		<to>
			<icast field="toStringMap"><c path="haxe.ds.StringMap"><c path="toStringMap.V"/></c></icast>
			<icast field="toIntMap"><c path="haxe.ds.IntMap"><c path="toIntMap.V"/></c></icast>
			<icast field="toEnumValueMapMap"><c path="haxe.ds.EnumValueMap">
	<c path="toEnumValueMapMap.K"/>
	<c path="toEnumValueMapMap.V"/>
</c></icast>
			<icast field="toObjectMap"><c path="haxe.ds.ObjectMap">
	<c path="toObjectMap.K"/>
	<c path="toObjectMap.V"/>
</c></icast>
		</to>
		<haxe_doc><![CDATA[Map allows key to value mapping for arbitrary value types, and many key
	types.

	This is a multi-type abstract, it is instantiated as one of its
	specialization types depending on its type parameters.

	A Map can be instantiated without explicit type parameters. Type inference
	will then determine the type parameters from the usage.

	Maps can also be created with `key1 => value1, key2 => value2` syntax.

	Map is an abstract type, it is not available at runtime.

	@see https://haxe.org/manual/std-Map.html]]></haxe_doc>
		<meta><m n=":multiType"><e>@:followWithAbstracts K</e></m></meta>
		<impl><class path="_Map.Map_Impl_" params="" file="/usr/lib/haxe/std/Map.hx" private="1" module="Map"><meta>
	<m n=":keep"/>
	<m n=":final"/>
</meta></class></impl>
	</abstract>
	<typedef path="IMap" params="K:V" file="/usr/lib/haxe/std/Map.hx" module="Map">
		<c path="haxe.IMap">
			<c path="IMap.K"/>
			<c path="IMap.V"/>
		</c>
		<meta>
			<m n=":dox"><e>hide</e></m>
			<m n=":deprecated"/>
		</meta>
	</typedef>
	<class path="Math" params="" file="/usr/lib/haxe/std/Math.hx" extern="1">
		<PI public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>Represents the ratio of the circumference of a circle to its diameter,
		specified by the constant, Ï€. `PI` is approximately 3.141592653589793.</haxe_doc>
		</PI>
		<NEGATIVE_INFINITY public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>A special `Float` constant which denotes negative infinity.

		For example, this is the result of -1.0 / 0.0.

		Operations with `NEGATIVE_INFINITY` as an operand may result in
		`NEGATIVE_INFINITY`, `POSITIVE_INFINITY` or `NaN`.

		If this constant is converted to an `Int`, e.g. through `Std.int()`, the
		result is unspecified.</haxe_doc>
		</NEGATIVE_INFINITY>
		<POSITIVE_INFINITY public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>A special `Float` constant which denotes positive infinity.

		For example, this is the result of 1.0 / 0.0.

		Operations with `POSITIVE_INFINITY` as an operand may result in
		`NEGATIVE_INFINITY`, `POSITIVE_INFINITY` or `NaN`.

		If this constant is converted to an `Int`, e.g. through `Std.int()`, the
		result is unspecified.</haxe_doc>
		</POSITIVE_INFINITY>
		<NaN public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[A special `Float` constant which denotes an invalid number.

		NaN stands for "Not a Number". It occurs when a mathematically incorrect
		operation is executed, such as taking the square root of a negative
		number: Math.sqrt(-1).

		All further operations with `NaN` as an operand will result in `NaN`.

		If this constant is converted to an `Int`, e.g. through `Std.int()`, the
		result is unspecified.

		In order to test if a value is `NaN`, you should use `Math.isNaN()` function.

		@php In PHP versions prior to 5.3.1 VC 9 there may be unexpected
		results when performing arithmetic operations with `NaN` on Windows,
		see <https://bugs.php.net/bug.php?id=42143>]]></haxe_doc>
		</NaN>
		<abs public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the absolute value of `v`.

		If `v` is positive or 0, the result is unchanged. Otherwise the result
		is -`v`.

		If `v` is `NEGATIVE_INFINITY` or `POSITIVE_INFINITY`, the result is
		`POSITIVE_INFINITY`.

		If `v` is `NaN`, the result is `NaN`.</haxe_doc>
		</abs>
		<min public="1" set="method" static="1">
			<f a="a:b">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the smaller of values `a` and `b`.

		If `a` or `b` are `NaN`, the result is `NaN`.
		If `a` or `b` are `NEGATIVE_INFINITY`, the result is `NEGATIVE_INFINITY`.
		If `a` and `b` are `POSITIVE_INFINITY`, the result is `POSITIVE_INFINITY`.</haxe_doc>
		</min>
		<max public="1" set="method" static="1">
			<f a="a:b">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the greater of values `a` and `b`.

		If `a` or `b` are `NaN`, the result is `NaN`.
		If `a` or `b` are `POSITIVE_INFINITY`, the result is `POSITIVE_INFINITY`.
		If `a` and `b` are `NEGATIVE_INFINITY`, the result is `NEGATIVE_INFINITY`.</haxe_doc>
		</max>
		<sin public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric sine of the specified angle `v`, in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</sin>
		<cos public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric cosine of the specified angle `v`, in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</cos>
		<tan public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric tangent of the specified angle `v`, in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</tan>
		<asin public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric arc of the specified angle `v`, in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</asin>
		<acos public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric arc cosine of the specified angle `v`,
		in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</acos>
		<atan public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric arc tangent of the specified angle `v`,
		in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</atan>
		<atan2 public="1" set="method" static="1">
			<f a="y:x">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric arc tangent whose tangent is the quotient of
		two specified numbers, in radians.

		If parameter `x` or `y`  is `NaN`, `NEGATIVE_INFINITY` or `POSITIVE_INFINITY`,
		the result is `NaN`.</haxe_doc>
		</atan2>
		<exp public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns Euler's number, raised to the power of `v`.

		exp(1.0) is approximately 2.718281828459.

		If `v` is `POSITIVE_INFINITY`, the result is `POSITIVE_INFINITY`.
		If `v` is `NEGATIVE_INFINITY`, the result is `0.0`.
		If `v` is `NaN`, the result is `NaN`.</haxe_doc>
		</exp>
		<log public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the natural logarithm of `v`.

		This is the mathematical inverse operation of exp,
		i.e. `log(exp(v)) == v` always holds.

		If `v` is negative (including `NEGATIVE_INFINITY`) or `NaN`, the result
		is `NaN`.
		If `v` is `POSITIVE_INFINITY`, the result is `POSITIVE_INFINITY`.
		If `v` is `0.0`, the result is `NEGATIVE_INFINITY`.</haxe_doc>
		</log>
		<pow public="1" set="method" static="1">
			<f a="v:exp">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns a specified base `v` raised to the specified power `exp`.</haxe_doc>
		</pow>
		<sqrt public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the square root of `v`.

		If `v` is negative (including `NEGATIVE_INFINITY`) or `NaN`, the result
		is `NaN`.
		If `v` is `POSITIVE_INFINITY`, the result is `POSITIVE_INFINITY`.
		If `v` is `0.0`, the result is `0.0`.</haxe_doc>
		</sqrt>
		<round public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Rounds `v` to the nearest integer value.

		Ties are rounded up, so that `0.5` becomes `1` and `-0.5` becomes `0`.

		If `v` is outside of the signed `Int32` range, or is `NaN`, `NEGATIVE_INFINITY`
		or `POSITIVE_INFINITY`, the result is unspecified.</haxe_doc>
		</round>
		<floor public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the largest integer value that is not greater than `v`.

		If `v` is outside of the signed `Int32` range, or is `NaN`, `NEGATIVE_INFINITY`
		or `POSITIVE_INFINITY`, the result is unspecified.</haxe_doc>
		</floor>
		<ceil public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the smallest integer value that is not less than `v`.

		If `v` is outside of the signed `Int32` range, or is `NaN`, `NEGATIVE_INFINITY`
		or `POSITIVE_INFINITY`, the result is unspecified.</haxe_doc>
		</ceil>
		<random public="1" set="method" static="1">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns a pseudo-random number which is greater than or equal to 0.0,
		and less than 1.0.</haxe_doc>
		</random>
		<ffloor public="1" get="inline" set="null" line="267" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></ffloor>
		<fceil public="1" get="inline" set="null" line="271" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></fceil>
		<fround public="1" get="inline" set="null" line="275" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></fround>
		<isFinite public="1" set="method" static="1">
			<f a="f">
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `f` is a finite number.

		If `f` is `POSITIVE_INFINITY`, `NEGATIVE_INFINITY` or `NaN`, the result
		is `false`, otherwise the result is `true`.</haxe_doc>
		</isFinite>
		<isNaN public="1" set="method" static="1">
			<f a="f">
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `f` is not a valid number.

		If `f` is `NaN`, the result is `true`, otherwise the result is `false`.
		In particular, both `POSITIVE_INFINITY` and `NEGATIVE_INFINITY` are
		not considered `NaN`.</haxe_doc>
		</isNaN>
		<haxe_doc>This class defines mathematical functions and constants.

	@see https://haxe.org/manual/std-math.html</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="Reflect" params="" file="/usr/lib/haxe/std/Reflect.hx" extern="1">
		<hasField public="1" set="method" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if structure `o` has a field named `field`.

		This is only guaranteed to work for anonymous structures. Refer to
		`Type.getInstanceFields` for a function supporting class instances.

		If `o` or `field` are null, the result is unspecified.</haxe_doc>
		</hasField>
		<field public="1" set="method" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>Returns the value of the field named `field` on object `o`.

		If `o` is not an object or has no field named `field`, the result is
		null.

		If the field is defined as a property, its accessors are ignored. Refer
		to `Reflect.getProperty` for a function supporting property accessors.

		If `field` is null, the result is unspecified.

		(As3) If used on a property field, the getter will be invoked. It is
		not possible to obtain the value directly.</haxe_doc>
		</field>
		<setField public="1" set="method" static="1">
			<f a="o:field:value">
				<d/>
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the field named `field` of object `o` to value `value`.

		If `o` has no field named `field`, this function is only guaranteed to
		work for anonymous structures.

		If `o` or `field` are null, the result is unspecified.

		(As3) If used on a property field, the setter will be invoked. It is
		not possible to set the value directly.</haxe_doc>
		</setField>
		<getProperty public="1" set="method" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>Returns the value of the field named `field` on object `o`, taking
		property getter functions into account.

		If the field is not a property, this function behaves like
		`Reflect.field`, but might be slower.

		If `o` or `field` are null, the result is unspecified.</haxe_doc>
		</getProperty>
		<setProperty public="1" set="method" static="1">
			<f a="o:field:value">
				<d/>
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the field named `field` of object `o` to value `value`, taking
		property setter functions into account.

		If the field is not a property, this function behaves like
		`Reflect.setField`, but might be slower.

		If `field` is null, the result is unspecified.</haxe_doc>
		</setProperty>
		<callMethod public="1" set="method" static="1">
			<f a="o:func:args">
				<d/>
				<x path="haxe.Function"/>
				<c path="Array"><d/></c>
				<d/>
			</f>
			<haxe_doc>Call a method with the given object and arguments.</haxe_doc>
		</callMethod>
		<fields public="1" set="method" static="1">
			<f a="o">
				<d/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns the fields of structure `o`.

		This method is only guaranteed to work on anonymous structures. Refer to
		`Type.getInstanceFields` for a function supporting class instances.

		If `o` is null, the result is unspecified.</haxe_doc>
		</fields>
		<isFunction public="1" set="method" static="1">
			<f a="f">
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns true if `f` is a function, false otherwise.

		If `f` is null, the result is false.</haxe_doc>
		</isFunction>
		<compare public="1" params="T" set="method" static="1">
			<f a="a:b">
				<c path="compare.T"/>
				<c path="compare.T"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Compares `a` and `b`.

		If `a` is less than `b`, the result is negative. If `b` is less than
		`a`, the result is positive. If `a` and `b` are equal, the result is 0.

		This function is only defined if `a` and `b` are of the same type.

		If that type is a function, the result is unspecified and
		`Reflect.compareMethods` should be used instead.

		For all other types, the result is 0 if `a` and `b` are equal. If they
		are not equal, the result depends on the type and is negative if:

		- Numeric types: a is less than b
		- String: a is lexicographically less than b
		- Other: unspecified

		If `a` and `b` are null, the result is 0. If only one of them is null,
		the result is unspecified.</haxe_doc>
		</compare>
		<compareMethods public="1" set="method" static="1">
			<f a="f1:f2">
				<d/>
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Compares the functions `f1` and `f2`.

		If `f1` or `f2` are not functions, the result is unspecified.

		Otherwise the result is true if `f1` and the `f2` are physically equal,
		false otherwise.</haxe_doc>
		</compareMethods>
		<isObject public="1" set="method" static="1">
			<f a="v">
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[Tells if `v` is an object.

		The result is true if `v` is one of the following:

		- class instance
		- structure
		- `Class<T>`
		- `Enum<T>`

		Otherwise, including if `v` is null, the result is false.]]></haxe_doc>
		</isObject>
		<isEnumValue public="1" set="method" static="1">
			<f a="v">
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `v` is an enum value.

		The result is true if `v` is of type EnumValue, i.e. an enum
		constructor.

		Otherwise, including if `v` is null, the result is false.</haxe_doc>
		</isEnumValue>
		<deleteField public="1" set="method" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Removes the field named `field` from structure `o`.

		This method is only guaranteed to work on anonymous structures.

		If `o` or `field` are null, the result is unspecified.</haxe_doc>
		</deleteField>
		<copy public="1" params="T" set="method" static="1">
			<f a="o">
				<c path="copy.T"/>
				<c path="copy.T"/>
			</f>
			<haxe_doc>Copies the fields of structure `o`.

		This is only guaranteed to work on anonymous structures.

		If `o` is null, the result is unspecified.</haxe_doc>
		</copy>
		<makeVarArgs public="1" set="method" static="1">
			<f a="f">
				<f a="">
					<c path="Array"><d/></c>
					<d/>
				</f>
				<d/>
			</f>
			<haxe_doc>Transform a function taking an array of arguments into a function that can
		be called with any number of arguments.</haxe_doc>
			<overloads><makeVarArgs public="1" set="method">
	<f a="f">
		<f a="">
			<c path="Array"><d/></c>
			<x path="Void"/>
		</f>
		<d/>
	</f>
	<haxe_doc>Transform a function taking an array of arguments into a function that can
		be called with any number of arguments.</haxe_doc>
</makeVarArgs></overloads>
		</makeVarArgs>
		<haxe_doc>The Reflect API is a way to manipulate values dynamically through an
	abstract interface in an untyped manner. Use with care.

	@see https://haxe.org/manual/std-reflection.html</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="Std" params="" file="/usr/lib/haxe/std/Std.hx" extern="1">
		<is public="1" set="method" static="1">
			<f a="v:t">
				<d/>
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if a value `v` is of the type `t`. Returns `false` if `v` or `t` are null.</haxe_doc>
		</is>
		<instance public="1" params="T:S" set="method" static="1">
			<f a="value:c">
				<c path="instance.T"/>
				<x path="Class"><c path="instance.S"/></x>
				<c path="instance.S"/>
			</f>
			<haxe_doc>Checks if object `value` is an instance of class `c`.

		Compiles only if the class specified by `c` can be assigned to the type
		of `value`.

		This method checks if a downcast is possible. That is, if the runtime
		type of `value` is assignable to the class specified by `c`, `value` is
		returned. Otherwise null is returned.

		This method is not guaranteed to work with interfaces or core types such
		as `String`, `Array` and `Date`.

		If `value` is null, the result is null. If `c` is null, the result is
		unspecified.</haxe_doc>
		</instance>
		<string public="1" set="method" static="1">
			<f a="s">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>Converts any value to a String.

		If `s` is of `String`, `Int`, `Float` or `Bool`, its value is returned.

		If `s` is an instance of a class and that class or one of its parent classes has
		a `toString` method, that method is called. If no such method is present, the result
		is unspecified.

		If `s` is an enum constructor without argument, the constructor's name is returned. If
		arguments exists, the constructor's name followed by the String representations of
		the arguments is returned.

		If `s` is a structure, the field names along with their values are returned. The field order
		and the operator separating field names and values are unspecified.

		If s is null, "null" is returned.</haxe_doc>
		</string>
		<int public="1" set="method" static="1">
			<f a="x">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Converts a `Float` to an `Int`, rounded towards 0.

		If `x` is outside of the signed Int32 range, or is `NaN`, `NEGATIVE_INFINITY` or `POSITIVE_INFINITY`, the result is unspecified.</haxe_doc>
		</int>
		<parseInt public="1" set="method" static="1">
			<f a="x">
				<c path="String"/>
				<t path="Null"><x path="Int"/></t>
			</f>
			<haxe_doc>Converts a `String` to an `Int`.

		Leading whitespaces are ignored.

		If `x` starts with 0x or 0X, hexadecimal notation is recognized where the following digits may
		contain 0-9 and A-F.

		Otherwise `x` is read as decimal number with 0-9 being allowed characters. `x` may also start with
		a - to denote a negative value.

		In decimal mode, parsing continues until an invalid character is detected, in which case the
		result up to that point is returned. For hexadecimal notation, the effect of invalid characters
		is unspecified.

		Leading 0s that are not part of the 0x/0X hexadecimal notation are ignored, which means octal
		notation is not supported.

		If the input cannot be recognized, the result is `null`.</haxe_doc>
		</parseInt>
		<parseFloat public="1" set="method" static="1">
			<f a="x">
				<c path="String"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Converts a `String` to a `Float`.

		The parsing rules for `parseInt` apply here as well, with the exception of invalid input
		resulting in a `NaN` value instead of null.

		Additionally, decimal notation may contain a single `.` to denote the start of the fractions.</haxe_doc>
		</parseFloat>
		<random public="1" set="method" static="1">
			<f a="x">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc><![CDATA[Return a random integer between 0 included and `x` excluded.

		If `x <= 1`, the result is always 0.]]></haxe_doc>
		</random>
		<haxe_doc>The Std class provides standard methods for manipulating basic types.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="Void" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<this><x path="Void"/></this>
		<haxe_doc>The standard `Void` type. Only `null` values can be of the type `Void`.

	@see https://haxe.org/manual/types-void.html</haxe_doc>
		<meta><m n=":coreType"/></meta>
	</abstract>
	<abstract path="Float" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<this><x path="Float"/></this>
		<haxe_doc><![CDATA[The standard `Float` type, this is a double-precision IEEE 64bit float.

	On static targets, `null` cannot be assigned to Float. If this is necessary,
	`Null<Float>` can be used instead.

	`Std.int` converts a `Float` to an `Int`, rounded towards 0.
	`Std.parseFloat` converts a `String` to a `Float`.

	@see https://haxe.org/manual/types-basic-types.html
	@see https://haxe.org/manual/types-nullability.html]]></haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Int" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<this><x path="Int"/></this>
		<to><icast><x path="Float"/></icast></to>
		<haxe_doc><![CDATA[The standard `Int` type. Its precision depends on the platform.

	On static targets, `null` cannot be assigned to `Int`. If this is necessary,
	`Null<Int>` can be used instead.

	`Std.int` converts a `Float` to an `Int`, rounded towards 0.
	`Std.parseInt` converts a `String` to an `Int`.

	@see https://haxe.org/manual/types-basic-types.html
	@see https://haxe.org/manual/std-math-integer-math.html
	@see https://haxe.org/manual/types-nullability.html]]></haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<typedef path="Null" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<c path="Null.T"/>
		<haxe_doc>`Null` can be useful in two cases. In order to document some methods
	that accept or can return a `null` value, or for the Flash compiler and AS3
	generator to distinguish between base values that can be `null` and others that
	can't.

	@see https://haxe.org/manual/types-nullability.html</haxe_doc>
	</typedef>
	<abstract path="Bool" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<this><x path="Bool"/></this>
		<haxe_doc><![CDATA[The standard Boolean type, which can either be `true` or `false`.

	On static targets, `null` cannot be assigned to `Bool`. If this is necessary,
	`Null<Bool>` can be used instead.

	@see https://haxe.org/manual/types-bool.html
	@see https://haxe.org/manual/types-nullability.html]]></haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Dynamic" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<this><x path="Dynamic"><c path="Dynamic.T"/></x></this>
		<haxe_doc>`Dynamic` is a special type which is compatible with all other types.

	Use of `Dynamic` should be minimized as it prevents several compiler
	checks and optimizations. See `Any` type for a safer alternative for
	representing values of any type.

	@see https://haxe.org/manual/types-dynamic.html</haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<typedef path="Iterator" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<a>
			<next set="method">
				<f a=""><c path="Iterator.T"/></f>
				<haxe_doc>Returns the current item of the `Iterator` and advances to the next one.

		This method is not required to check `hasNext()` first. A call to this
		method while `hasNext()` is `false` yields unspecified behavior.

		On the other hand, iterators should not require a call to `hasNext()`
		before the first call to `next()` if an element is available.</haxe_doc>
			</next>
			<hasNext set="method">
				<f a=""><x path="Bool"/></f>
				<haxe_doc>Returns `false` if the iteration is complete, `true` otherwise.

		Usually iteration is considered to be complete if all elements of the
		underlying data structure were handled through calls to `next()`. However,
		in custom iterators any logic may be used to determine the completion
		state.</haxe_doc>
			</hasNext>
		</a>
		<haxe_doc>An `Iterator` is a structure that permits iteration over elements of type `T`.

	Any class with matching `hasNext()` and `next()` fields is considered an `Iterator`
	and can then be used e.g. in `for`-loops. This makes it easy to implement
	custom iterators.

	@see https://haxe.org/manual/lf-iterators.html</haxe_doc>
	</typedef>
	<typedef path="Iterable" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<a><iterator set="method"><f a=""><t path="Iterator"><c path="Iterable.T"/></t></f></iterator></a>
		<haxe_doc>An `Iterable` is a data structure which has an `iterator()` method.
	See `Lambda` for generic functions on iterable structures.

	@see https://haxe.org/manual/lf-iterators.html</haxe_doc>
	</typedef>
	<class path="ArrayAccess" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes" extern="1" interface="1"><haxe_doc>`ArrayAccess` is used to indicate a class that can be accessed using brackets.
	The type parameter represents the type of the elements stored.

	This interface should be used for externs only. Haxe does not support custom
	array access on classes. However, array access can be implemented for
	abstract types.

	@see https://haxe.org/manual/types-abstract-array-access.html</haxe_doc></class>
	<class path="String" params="" file="/usr/lib/haxe/std/String.hx" extern="1">
		<fromCharCode public="1" set="method" static="1">
			<f a="code">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the String corresponding to the character code `code`.

		If `code` is negative or has another invalid value, the result is
		unspecified.</haxe_doc>
		</fromCharCode>
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The number of characters in `this` String.</haxe_doc>
		</length>
		<toUpperCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a String where all characters of `this` String are upper case.

		Affects the characters `a-z`. Other characters remain unchanged.</haxe_doc>
		</toUpperCase>
		<toLowerCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a String where all characters of `this` String are lower case.

		Affects the characters `A-Z`. Other characters remain unchanged.</haxe_doc>
		</toLowerCase>
		<charAt public="1" set="method">
			<f a="index">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the character at position `index` of `this` String.

		If `index` is negative or exceeds `this.length`, the empty String `""`
		is returned.</haxe_doc>
		</charAt>
		<charCodeAt public="1" set="method">
			<f a="index">
				<x path="Int"/>
				<t path="Null"><x path="Int"/></t>
			</f>
			<haxe_doc>Returns the character code at position `index` of `this` String.

		If `index` is negative or exceeds `this.length`, `null` is returned.

		To obtain the character code of a single character, `"x".code` can be
		used instead to inline the character code at compile time. Note that
		this only works on String literals of length 1.</haxe_doc>
		</charCodeAt>
		<indexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the position of the leftmost occurrence of `str` within `this`
		String.

		If `startIndex` is given, the search is performed within the substring
		of `this` String starting from `startIndex`. Otherwise the search is
		performed within `this` String. In either case, the returned position
		is relative to the beginning of `this` String.

		If `str` cannot be found, -1 is returned.</haxe_doc>
		</indexOf>
		<lastIndexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the position of the rightmost occurrence of `str` within `this`
		String.

		If `startIndex` is given, the search is performed within the substring
		of `this` String from 0 to `startIndex`. Otherwise the search is
		performed within `this` String. In either case, the returned position
		is relative to the beginning of `this` String.

		If `str` cannot be found, -1 is returned.</haxe_doc>
		</lastIndexOf>
		<split public="1" set="method">
			<f a="delimiter">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Splits `this` String at each occurrence of `delimiter`.

		If `this` String is the empty String `""`, the result is not consistent
		across targets and may either be `[]` (on Js, Cpp) or `[""]`.

		If `delimiter` is the empty String `""`, `this` String is split into an
		Array of `this.length` elements, where the elements correspond to the
		characters of `this` String.

		If `delimiter` is not found within `this` String, the result is an Array
		with one element, which equals `this` String.

		If `delimiter` is null, the result is unspecified.

		Otherwise, `this` String is split into parts at each occurrence of
		`delimiter`. If `this` String starts (or ends) with `delimiter`, the
		result `Array` contains a leading (or trailing) empty String `""` element.
		Two subsequent delimiters also result in an empty String `""` element.</haxe_doc>
		</split>
		<substr public="1" set="method">
			<f a="pos:?len">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns `len` characters of `this` String, starting at position `pos`.

		If `len` is omitted, all characters from position `pos` to the end of
		`this` String are included.

		If `pos` is negative, its value is calculated from the end of `this`
		String by `this.length + pos`. If this yields a negative value, 0 is
		used instead.

		If the calculated position + `len` exceeds `this.length`, the characters
		from that position to the end of `this` String are returned.

		If `len` is negative, the result is unspecified.</haxe_doc>
		</substr>
		<substring public="1" set="method">
			<f a="startIndex:?endIndex">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the part of `this` String from `startIndex` to but not including `endIndex`.

		If `startIndex` or `endIndex` are negative, 0 is used instead.

		If `startIndex` exceeds `endIndex`, they are swapped.

		If the (possibly swapped) `endIndex` is omitted or exceeds
		`this.length`, `this.length` is used instead.

		If the (possibly swapped) `startIndex` exceeds `this.length`, the empty
		String `""` is returned.</haxe_doc>
		</substring>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the String itself.</haxe_doc>
		</toString>
		<new public="1" set="method">
			<f a="string">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a copy from a given String.</haxe_doc>
		</new>
		<haxe_doc>The basic String class.

	A Haxe String is immutable, it is not possible to modify individual
	characters. No method of this class changes the state of `this` String.

	Strings can be constructed using the String literal syntax `"string value"`.

	String can be concatenated by using the `+` operator. If an operand is not a
	String, it is passed through `Std.string()` first.
	
	@see https://haxe.org/manual/std-String.html</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="StringBuf" params="" file="/usr/lib/haxe/std/StringBuf.hx">
		<b><c path="String"/></b>
		<length public="1" get="null" set="null">
			<x path="Int"/>
			<haxe_doc>The length of `this` StringBuf in characters.</haxe_doc>
		</length>
		<new public="1" get="inline" set="null" line="47">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new StringBuf instance.

		This may involve initialization of the internal buffer.</haxe_doc>
		</new>
		<haxe_doc>A String buffer is an efficient way to build a big string by appending small
	elements together.

	Its cross-platform implementation uses String concatenation internally, but
	StringBuf may be optimized for different targets.

	Unlike String, an instance of StringBuf is not immutable in the sense that
	it can be passed as argument to functions which modify it by appending more
	values. However, the internal buffer cannot be modified.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="StringTools" params="" file="/usr/lib/haxe/std/StringTools.hx">
		<isSpace public="1" set="method" line="245" static="1">
			<f a="s:pos">
				<c path="String"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if the character in the string `s` at position `pos` is a space.

		A character is considered to be a space character if its character code
		is 9,10,11,12,13 or 32.

		If `s` is the empty String `""`, or if pos is not a valid position within
		`s`, the result is false.</haxe_doc>
		</isSpace>
		<ltrim public="1" set="method" line="262" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Removes leading space characters of `s`.

		This function internally calls `isSpace()` to decide which characters to
		remove.

		If `s` is the empty String `""` or consists only of space characters, the
		result is the empty String `""`.</haxe_doc>
		</ltrim>
		<rtrim public="1" set="method" line="287" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Removes trailing space characters of `s`.

		This function internally calls `isSpace()` to decide which characters to
		remove.

		If `s` is the empty String `""` or consists only of space characters, the
		result is the empty String `""`.</haxe_doc>
		</rtrim>
		<lpad public="1" set="method" line="331" static="1">
			<f a="s:c:l">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Concatenates `c` to `s` until `s.length` is at least `l`.

		If `c` is the empty String `""` or if `l` does not exceed `s.length`,
		`s` is returned unchanged.

		If `c.length` is 1, the resulting String length is exactly `l`.

		Otherwise the length may exceed `l`.

		If `c` is null, the result is unspecified.</haxe_doc>
		</lpad>
		<replace public="1" set="method" line="374" static="1">
			<f a="s:sub:by">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Replace all occurrences of the String `sub` in the String `s` by the
		String `by`.

		If `sub` is the empty String `""`, `by` is inserted after each character
		of `s`. If `by` is also the empty String `""`, `s` remains unchanged.

		This is a convenience function for `s.split(sub).join(by)`.

		If `sub` or `by` are null, the result is unspecified.</haxe_doc>
		</replace>
		<haxe_doc>This class provides advanced methods on Strings. It is ideally used with
	`using StringTools` and then acts as an [extension](https://haxe.org/manual/lf-static-extension.html)
	to the `String` class.

	If the first argument to any of the methods is null, the result is
	unspecified.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="Sys" params="" file="/usr/lib/haxe/std/Sys.hx" extern="1">
		<print public="1" set="method" static="1">
			<f a="v">
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>Print any value on the standard output.</haxe_doc>
		</print>
		<println public="1" set="method" static="1">
			<f a="v">
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>Print any value on the standard output, followed by a newline.</haxe_doc>
		</println>
		<args public="1" set="method" static="1">
			<f a=""><c path="Array"><c path="String"/></c></f>
			<haxe_doc>Returns all the arguments that were passed by the command line.</haxe_doc>
		</args>
		<getEnv public="1" set="method" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the value of the given environment variable.</haxe_doc>
		</getEnv>
		<putEnv public="1" set="method" static="1">
			<f a="s:v">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Set the value of the given environment variable.</haxe_doc>
		</putEnv>
		<environment public="1" set="method" static="1">
			<f a=""><x path="Map">
	<c path="String"/>
	<c path="String"/>
</x></f>
			<haxe_doc>Returns all environment variables.</haxe_doc>
		</environment>
		<sleep public="1" set="method" static="1">
			<f a="seconds">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Suspend the current execution for the given time (in seconds).</haxe_doc>
		</sleep>
		<setTimeLocale public="1" set="method" static="1">
			<f a="loc">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Change the current time locale, which will affect `DateTools.format` date formating.
		Returns true if the locale was successfully changed</haxe_doc>
		</setTimeLocale>
		<getCwd public="1" set="method" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>Get the current working directory (usually the one in which the program was started)</haxe_doc>
		</getCwd>
		<setCwd public="1" set="method" static="1">
			<f a="s">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Change the current working directory.</haxe_doc>
		</setCwd>
		<systemName public="1" set="method" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the name of the system you are running on. For instance :
			"Windows", "Linux", "BSD" and "Mac" depending on your desktop OS.</haxe_doc>
		</systemName>
		<command public="1" set="method" static="1">
			<f a="cmd:?args">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
				<x path="Int"/>
			</f>
			<haxe_doc>Run the given command. The command output will be printed on the same output as the current process.
		The current process will block until the command terminates and it will return the command result (0 if there was no error).

		Command arguments can be passed in two ways: 1. using `args`, 2. appending to `cmd` and leaving `args` as `null`.

		 1. When using `args` to pass command arguments, each argument will be automatically quoted, and shell meta-characters will be escaped if needed.
		`cmd` should be an executable name that can be located in the `PATH` environment variable, or a path to an executable.

		 2. When `args` is not given or is `null`, command arguments can be appended to `cmd`. No automatic quoting/escaping will be performed. `cmd` should be formatted exactly as it would be when typed at the command line.
		It can run executables, as well as shell commands that are not executables (e.g. on Windows: `dir`, `cd`, `echo` etc).

		Read the `sys.io.Process` api for a more complete way to start background processes.</haxe_doc>
		</command>
		<exit public="1" set="method" static="1">
			<f a="code">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Exit the current process with the given error code.</haxe_doc>
		</exit>
		<time public="1" set="method" static="1">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Gives the most precise timestamp value (in seconds).</haxe_doc>
		</time>
		<cpuTime public="1" set="method" static="1">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Gives the most precise timestamp value (in seconds) but only account for the actual time spent running on the CPU for the current thread/process.</haxe_doc>
		</cpuTime>
		<executablePath public="1" set="method" static="1">
			<f a=""><c path="String"/></f>
			<meta><m n=":deprecated"><e>"Use programPath instead"</e></m></meta>
			<haxe_doc>Returns the path to the current executable that we are running.</haxe_doc>
		</executablePath>
		<programPath public="1" set="method" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the absolute path to the current program file that we are running.
		Concretely, for an executable binary, it returns the path to the binary.
		For a script (e.g. a PHP file), it returns the path to the script.</haxe_doc>
		</programPath>
		<getChar public="1" set="method" static="1">
			<f a="echo">
				<x path="Bool"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Read a single input character from the standard input (without blocking) and returns it. Setting `echo` to true will also display it on the output.</haxe_doc>
		</getChar>
		<stdin public="1" set="method" static="1">
			<f a=""><c path="haxe.io.Input"/></f>
			<haxe_doc>Returns the process standard input, from which you can read what user enters. Usually it will block until the user send a full input line. See `getChar` for an alternative.</haxe_doc>
		</stdin>
		<stdout public="1" set="method" static="1">
			<f a=""><c path="haxe.io.Output"/></f>
			<haxe_doc>Returns the process standard output on which you can write.</haxe_doc>
		</stdout>
		<stderr public="1" set="method" static="1">
			<f a=""><c path="haxe.io.Output"/></f>
			<haxe_doc>Returns the process standard error on which you can write.</haxe_doc>
		</stderr>
		<haxe_doc>This class gives you access to many base functionalities of system platforms. Looks in `sys` sub packages for more system APIs.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":require"><e>sys</e></m>
		</meta>
	</class>
	<class path="Type" params="" file="/usr/lib/haxe/std/Type.hx" extern="1">
		<getClass public="1" params="T" set="method" static="1">
			<f a="o">
				<c path="getClass.T"/>
				<x path="Class"><c path="getClass.T"/></x>
			</f>
			<haxe_doc>Returns the class of `o`, if `o` is a class instance.

		If `o` is null or of a different type, null is returned.

		In general, type parameter information cannot be obtained at runtime.</haxe_doc>
		</getClass>
		<getEnum public="1" set="method" static="1">
			<f a="o">
				<x path="EnumValue"/>
				<x path="Enum"><d/></x>
			</f>
			<haxe_doc><![CDATA[Returns the enum of enum instance `o`.

		An enum instance is the result of using an enum constructor. Given an
		`enum Color { Red; }`, `getEnum(Red)` returns `Enum<Color>`.

		If `o` is null, null is returned.

		In general, type parameter information cannot be obtained at runtime.]]></haxe_doc>
		</getEnum>
		<getSuperClass public="1" set="method" static="1">
			<f a="c">
				<x path="Class"><d/></x>
				<x path="Class"><d/></x>
			</f>
			<haxe_doc>Returns the super-class of class `c`.

		If `c` has no super class, null is returned.

		If `c` is null, the result is unspecified.

		In general, type parameter information cannot be obtained at runtime.</haxe_doc>
		</getSuperClass>
		<getClassName public="1" set="method" static="1">
			<f a="c">
				<x path="Class"><d/></x>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the name of class `c`, including its path.

		If `c` is inside a package, the package structure is returned dot-
		separated, with another dot separating the class name:
		`pack1.pack2.(...).packN.ClassName`
		If `c` is a sub-type of a Haxe module, that module is not part of the
		package structure.

		If `c` has no package, the class name is returned.

		If `c` is null, the result is unspecified.

		The class name does not include any type parameters.</haxe_doc>
		</getClassName>
		<getEnumName public="1" set="method" static="1">
			<f a="e">
				<x path="Enum"><d/></x>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the name of enum `e`, including its path.

		If `e` is inside a package, the package structure is returned dot-
		separated, with another dot separating the enum name:
		`pack1.pack2.(...).packN.EnumName`
		If `e` is a sub-type of a Haxe module, that module is not part of the
		package structure.

		If `e` has no package, the enum name is returned.

		If `e` is null, the result is unspecified.

		The enum name does not include any type parameters.</haxe_doc>
		</getEnumName>
		<resolveClass public="1" set="method" static="1">
			<f a="name">
				<c path="String"/>
				<x path="Class"><d/></x>
			</f>
			<haxe_doc>Resolves a class by name.

		If `name` is the path of an existing class, that class is returned.

		Otherwise null is returned.

		If `name` is null or the path to a different type, the result is
		unspecified.

		The class name must not include any type parameters.</haxe_doc>
		</resolveClass>
		<resolveEnum public="1" set="method" static="1">
			<f a="name">
				<c path="String"/>
				<x path="Enum"><d/></x>
			</f>
			<haxe_doc>Resolves an enum by name.

		If `name` is the path of an existing enum, that enum is returned.

		Otherwise null is returned.

		If `name` is null the result is unspecified.

		If `name` is the path to a different type, null is returned.

		The enum name must not include any type parameters.</haxe_doc>
		</resolveEnum>
		<createInstance public="1" params="T" set="method" static="1">
			<f a="cl:args">
				<x path="Class"><c path="createInstance.T"/></x>
				<c path="Array"><d/></c>
				<c path="createInstance.T"/>
			</f>
			<haxe_doc>Creates an instance of class `cl`, using `args` as arguments to the
		class constructor.

		This function guarantees that the class constructor is called.

		Default values of constructors arguments are not guaranteed to be
		taken into account.

		If `cl` or `args` are null, or if the number of elements in `args` does
		not match the expected number of constructor arguments, or if any
		argument has an invalid type,  or if `cl` has no own constructor, the
		result is unspecified.

		In particular, default values of constructor arguments are not
		guaranteed to be taken into account.</haxe_doc>
		</createInstance>
		<createEmptyInstance public="1" params="T" set="method" static="1">
			<f a="cl">
				<x path="Class"><c path="createEmptyInstance.T"/></x>
				<c path="createEmptyInstance.T"/>
			</f>
			<haxe_doc>Creates an instance of class `cl`.

		This function guarantees that the class constructor is not called.

		If `cl` is null, the result is unspecified.</haxe_doc>
		</createEmptyInstance>
		<createEnum public="1" params="T" set="method" static="1">
			<f a="e:constr:?params">
				<x path="Enum"><c path="createEnum.T"/></x>
				<c path="String"/>
				<c path="Array"><d/></c>
				<c path="createEnum.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor `constr` with
		arguments `params`.

		If `e` or `constr` is null, or if enum `e` has no constructor named
		`constr`, or if the number of elements in `params` does not match the
		expected number of constructor arguments, or if any argument has an
		invalid type, the result is unspecified.</haxe_doc>
		</createEnum>
		<createEnumIndex public="1" params="T" set="method" static="1">
			<f a="e:index:?params">
				<x path="Enum"><c path="createEnumIndex.T"/></x>
				<x path="Int"/>
				<c path="Array"><d/></c>
				<c path="createEnumIndex.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor number
		`index` with arguments `params`.

		The constructor indices are preserved from Haxe syntax, so the first
		declared is index 0, the next index 1 etc.

		If `e` or `constr` is null, or if enum `e` has no constructor named
		`constr`, or if the number of elements in `params` does not match the
		expected number of constructor arguments, or if any argument has an
		invalid type, the result is unspecified.</haxe_doc>
		</createEnumIndex>
		<getInstanceFields public="1" set="method" static="1">
			<f a="c">
				<x path="Class"><d/></x>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns a list of the instance fields of class `c`.

		This only includes fields which are known at compile-time. In
		particular, using getInstanceFields(getClass(obj)) will not include
		any fields which were added to obj at runtime.

		The order of the fields in the returned Array is unspecified.

		If `c` is null, the result is unspecified.

		(As3) This method only returns instance fields that are public.</haxe_doc>
		</getInstanceFields>
		<getClassFields public="1" set="method" static="1">
			<f a="c">
				<x path="Class"><d/></x>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns a list of static fields of class `c`.

		This does not include static fields of parent classes.

		The order of the fields in the returned Array is unspecified.

		If `c` is null, the result is unspecified.

		(As3) This method only returns class fields that are public.</haxe_doc>
		</getClassFields>
		<getEnumConstructs public="1" set="method" static="1">
			<f a="e">
				<x path="Enum"><d/></x>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns a list of the names of all constructors of enum `e`.

		The order of the constructor names in the returned Array is preserved
		from the original syntax.

		If `c` is null, the result is unspecified.</haxe_doc>
		</getEnumConstructs>
		<typeof public="1" set="method" static="1">
			<f a="v">
				<d/>
				<e path="ValueType"/>
			</f>
			<haxe_doc>Returns the runtime type of value `v`.

		The result corresponds to the type `v` has at runtime, which may vary
		per platform. Assumptions regarding this should be minimized to avoid
		surprises.</haxe_doc>
		</typeof>
		<enumEq public="1" params="T" set="method" static="1">
			<f a="a:b">
				<c path="enumEq.T"/>
				<c path="enumEq.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Recursively compares two enum instances `a` and `b` by value.

		Unlike `a == b`, this function performs a deep equality check on the
		arguments of the constructors, if exists.

		If `a` or `b` are null, the result is unspecified.</haxe_doc>
		</enumEq>
		<enumConstructor public="1" set="method" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the constructor name of enum instance `e`.

		The result String does not contain any constructor arguments.

		If `e` is null, the result is unspecified.</haxe_doc>
		</enumConstructor>
		<enumParameters public="1" set="method" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="Array"><d/></c>
			</f>
			<haxe_doc>Returns a list of the constructor arguments of enum instance `e`.

		If `e` has no arguments, the result is [].

		Otherwise the result are the values that were used as arguments to `e`,
		in the order of their declaration.

		If `e` is null, the result is unspecified.</haxe_doc>
		</enumParameters>
		<enumIndex public="1" set="method" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the index of enum instance `e`.

		This corresponds to the original syntactic position of `e`. The index of
		the first declared constructor is 0, the next one is 1 etc.

		If `e` is null, the result is unspecified.</haxe_doc>
		</enumIndex>
		<allEnums public="1" params="T" set="method" static="1">
			<f a="e">
				<x path="Enum"><c path="allEnums.T"/></x>
				<c path="Array"><c path="allEnums.T"/></c>
			</f>
			<haxe_doc>Returns a list of all constructors of enum `e` that require no
		arguments.

		This may return the empty Array `[]` if all constructors of `e` require
		arguments.

		Otherwise an instance of `e` constructed through each of its non-
		argument constructors is returned, in the order of the constructor
		declaration.

		If `e` is null, the result is unspecified.</haxe_doc>
		</allEnums>
		<haxe_doc>The Haxe Reflection API allows retrieval of type information at runtime.

	This class complements the more lightweight Reflect class, with a focus on
	class and enum instances.

	@see https://haxe.org/manual/types.html
	@see https://haxe.org/manual/std-reflection.html</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="ValueType" params="" file="/usr/lib/haxe/std/Type.hx" module="Type">
		<TNull/>
		<TInt/>
		<TFloat/>
		<TBool/>
		<TObject/>
		<TFunction/>
		<TClass a="c"><x path="Class"><d/></x></TClass>
		<TEnum a="e"><x path="Enum"><d/></x></TEnum>
		<TUnknown/>
		<haxe_doc>The different possible runtime types of a value.</haxe_doc>
	</enum>
	<abstract path="UInt" params="" file="/usr/lib/haxe/std/UInt.hx">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to>
			<icast><x path="Int"/></icast>
			<icast field="toFloat"><x path="Float"/></icast>
		</to>
		<haxe_doc>The unsigned `Int` type is only defined for Flash and C#.
	Simulate it for other platforms.

	@see https://haxe.org/manual/types-basic-types.html</haxe_doc>
		<impl><class path="_UInt.UInt_Impl_" params="" file="/usr/lib/haxe/std/UInt.hx" private="1" module="UInt"><meta>
	<m n=":keep"/>
	<m n=":final"/>
</meta></class></impl>
	</abstract>
	<class path="com.raidandfade.haxicord.DiscordClient" params="" file="src/com/raidandfade/haxicord/DiscordClient.hx">
		<libName public="1" expr="&quot;Haxicord&quot;" line="33" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"Haxicord"</e></m></meta>
			<haxe_doc>The name of the library</haxe_doc>
		</libName>
		<userAgent public="1" expr="&quot;DiscordBot (https://github.com/RaidAndFade/Haxicord, 0.1.0)&quot;" line="37" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"DiscordBot (https://github.com/RaidAndFade/Haxicord, 0.1.0)"</e></m></meta>
			<haxe_doc>The library's useragent</haxe_doc>
		</userAgent>
		<gatewayVersion public="1" expr="7" line="41" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>7</e></m></meta>
			<haxe_doc>The gateway version being used.</haxe_doc>
		</gatewayVersion>
		<messageCache public="1" expr="new Map&lt;String,Message&gt;()">
			<x path="Map">
				<c path="String"/>
				<c path="com.raidandfade.haxicord.types.Message"/>
			</x>
			<meta>
				<m n=":value"><e><![CDATA[new Map<String,Message>()]]></e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</messageCache>
		<userCache public="1" expr="new Map&lt;String,User&gt;()">
			<x path="Map">
				<c path="String"/>
				<c path="com.raidandfade.haxicord.types.User"/>
			</x>
			<meta>
				<m n=":value"><e><![CDATA[new Map<String,User>()]]></e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</userCache>
		<channelCache public="1" expr="new Map&lt;String,Channel&gt;()">
			<x path="Map">
				<c path="String"/>
				<c path="com.raidandfade.haxicord.types.Channel"/>
			</x>
			<meta>
				<m n=":value"><e><![CDATA[new Map<String,Channel>()]]></e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</channelCache>
		<dmChannelCache public="1" expr="new Map&lt;String,DMChannel&gt;()">
			<x path="Map">
				<c path="String"/>
				<c path="com.raidandfade.haxicord.types.DMChannel"/>
			</x>
			<meta>
				<m n=":value"><e><![CDATA[new Map<String,DMChannel>()]]></e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</dmChannelCache>
		<guildCache public="1" expr="new Map&lt;String,Guild&gt;()">
			<x path="Map">
				<c path="String"/>
				<c path="com.raidandfade.haxicord.types.Guild"/>
			</x>
			<meta>
				<m n=":value"><e><![CDATA[new Map<String,Guild>()]]></e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</guildCache>
		<userDMChannels public="1" expr="new Map&lt;String,String&gt;()">
			<x path="Map">
				<c path="String"/>
				<c path="String"/>
			</x>
			<meta>
				<m n=":value"><e><![CDATA[new Map<String,String>()]]></e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</userDMChannels>
		<ready public="1" expr="false">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>false</e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</ready>
		<user public="1">
			<c path="com.raidandfade.haxicord.types.User"/>
			<haxe_doc>The bot user, this is you.</haxe_doc>
		</user>
		<token public="1">
			<c path="String"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</token>
		<isBot public="1">
			<x path="Bool"/>
			<haxe_doc><![CDATA[Is the bot a bot account? <Always true>]]></haxe_doc>
		</isBot>
		<endpoints public="1">
			<c path="com.raidandfade.haxicord.endpoints.Endpoints"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</endpoints>
		<reconnectTimeout public="1" expr="1">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>1</e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</reconnectTimeout>
		<hbThread>
			<c path="com.raidandfade.haxicord._DiscordClient.HeartbeatThread"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</hbThread>
		<ws>
			<c path="com.raidandfade.haxicord.websocket.WebSocketConnection"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</ws>
		<start public="1" set="method" line="103">
			<f a="?blocking" v="true">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ blocking : true }</e></m></meta>
			<haxe_doc>This is basically just a while true loop to keep the main thread alive while the other threads work.
        @param blocking=true - If you dont want to have the while loop activate, set this to false and make your own loop.</haxe_doc>
		</start>
		<connect set="method" line="112">
			<f a="gateway:error">
				<a>
					<url set="null"><c path="String"/></url>
					<shards>
						<t path="Null"><x path="Int"/></t>
						<meta><m n=":optional"/></meta>
						<haxe_doc>The number of shards suggested (will only be there for bots)</haxe_doc>
					</shards>
				</a>
				<t path="com.raidandfade.haxicord.endpoints.ErrorReport"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</connect>
		<reconnect set="method" line="130">
			<f a="gateway:error">
				<a><url set="null"><c path="String"/></url></a>
				<unknown/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</reconnect>
		<webSocketMessage set="method" line="145">
			<f a="msg">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</webSocketMessage>
		<receiveEvent set="method" line="161">
			<f a="msg">
				<t path="com.raidandfade.haxicord._DiscordClient.WSMessage"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</receiveEvent>
		<getInviteLink public="1" set="method" line="299">
			<f a="?perms" v="0">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ perms : 0 }</e></m></meta>
			<haxe_doc>Get the invite link of the bot.
        @param perms=0 - The permissions to put on the link.</haxe_doc>
		</getInviteLink>
		<listVoiceRegions public="1" set="method" line="311">
			<f a="cb">
				<t path="Null"><f a=":">
	<c path="Array"><t path="com.raidandfade.haxicord.types.structs.VoiceRegion"/></c>
	<t path="com.raidandfade.haxicord.endpoints.ErrorReport"/>
	<x path="Void"/>
</f></t>
				<x path="Void"/>
			</f>
			<haxe_doc>Get a list of voice regions.
        @param cb - Returns a list of voice regions, or an error.</haxe_doc>
		</listVoiceRegions>
		<createGuild public="1" set="method" line="320">
			<f a="guild_data:cb">
				<t path="com.raidandfade.haxicord.endpoints.GuildCreate"/>
				<t path="Null"><f a=":">
	<c path="com.raidandfade.haxicord.types.Guild"/>
	<t path="com.raidandfade.haxicord.endpoints.ErrorReport"/>
	<x path="Void"/>
</f></t>
				<x path="Void"/>
			</f>
			<haxe_doc>Create a new guild based on the data given
        @param guild_data - The data to be changed, All fields are optional.
        @param cb - Returns the new guild object, or an error.</haxe_doc>
		</createGuild>
		<sendMessage public="1" set="method" line="330">
			<f a="channel_id:message:?cb" v="::null">
				<c path="String"/>
				<t path="com.raidandfade.haxicord.endpoints.MessageCreate"/>
				<f a=":">
					<c path="com.raidandfade.haxicord.types.Message"/>
					<t path="com.raidandfade.haxicord.endpoints.ErrorReport"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Send a message to a channel
        @param channel_id - The channel to send to
        @param message - Message data
        @param cb - Return the message sent, or an error</haxe_doc>
		</sendMessage>
		<getInvite public="1" set="method" line="346">
			<f a="invite_code:?cb" v=":null">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Get information about an invite code.
        @param invite_code - The invite code.
        @param cb - Returns an Invite object, or an error.</haxe_doc>
		</getInvite>
		<joinInvite public="1" set="method" line="355">
			<f a="invite_code:?cb" v=":null">
				<c path="String"/>
				<f a=":">
					<t path="com.raidandfade.haxicord.types.structs.Invite"/>
					<t path="com.raidandfade.haxicord.endpoints.ErrorReport"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>(NOT AVAILABLE FOR BOTS) Accept an invite code and join the server.
        @param invite_code - The invite code to join.
        @param cb - Returns the invite that was joined, or an error.</haxe_doc>
		</joinInvite>
		<deleteInvite public="1" set="method" line="364">
			<f a="invite_code:?cb" v=":null">
				<c path="String"/>
				<f a=":">
					<t path="com.raidandfade.haxicord.types.structs.Invite"/>
					<t path="com.raidandfade.haxicord.endpoints.ErrorReport"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Delete an invite based on it's invite code. Requires the MANAGE_CHANNELS permission in the guild the invite is from.
        @param invite_code - The invite code of the invite to delete.
        @param cb - Returns the Invite that was removed, or an error.</haxe_doc>
		</deleteInvite>
		<createDMGroup public="1" set="method" line="373">
			<f a="data:?cb" v=":null">
				<t path="com.raidandfade.haxicord.endpoints.CreateGroupDM"/>
				<f a=":">
					<c path="com.raidandfade.haxicord.types.DMChannel"/>
					<t path="com.raidandfade.haxicord.endpoints.ErrorReport"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Create a DM group. 
        @param data - A struct that contains the necessary arguments required to invite members.
        @param cb - Returns the group dm channel, or an error.</haxe_doc>
		</createDMGroup>
		<editUser public="1" set="method" line="384">
			<f a="user_data:?cb" v=":null">
				<a>
					<username><c path="String"/></username>
					<avatar><c path="String"/></avatar>
				</a>
				<f a=":">
					<c path="com.raidandfade.haxicord.types.User"/>
					<t path="com.raidandfade.haxicord.endpoints.ErrorReport"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Edit the current user's settings.
        @param user_data - The parameters to change, all fields are optional.
        @param cb - Return the changed user, or an error.</haxe_doc>
		</editUser>
		<getGuilds public="1" set="method" line="393">
			<f a="filter:?cb" v=":null">
				<t path="com.raidandfade.haxicord.endpoints.GetGuildFilter"/>
				<f a=":">
					<c path="Array"><c path="com.raidandfade.haxicord.types.Guild"/></c>
					<t path="com.raidandfade.haxicord.endpoints.ErrorReport"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Get a list of all guilds that the current user is in. Normal users do not need to use the filter and can leave it blank `{}`
        @param filter - Filter the list depending on these parameters, Only one of BEFORE or AFTER can be specified.
        @param cb - Returns the list of Guilds according to the filter specified, or an error.</haxe_doc>
		</getGuilds>
		<getConnections public="1" set="method" line="401">
			<f a="?cb" v="null">
				<f a=":">
					<c path="Array"><t path="com.raidandfade.haxicord.types.structs.Connection"/></c>
					<t path="com.raidandfade.haxicord.endpoints.ErrorReport"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Get a list of connections hooked up to the current account.
        @param cb - Returns a list of connections, or an error.</haxe_doc>
		</getConnections>
		<removeChannel public="1" set="method" line="407">
			<f a="id">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</removeChannel>
		<removeMessage public="1" set="method" line="423">
			<f a="id">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</removeMessage>
		<removeGuild public="1" set="method" line="428">
			<f a="id">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</removeGuild>
		<removeUser public="1" set="method" line="433">
			<f a="id">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</removeUser>
		<getGuild public="1" set="method" line="443">
			<f a="id:cb">
				<c path="String"/>
				<f a="">
					<c path="com.raidandfade.haxicord.types.Guild"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>Get a guild from cache if it's there otherwise load from API.
        @param id - The id of the desired guild.
        @param cb - The Callback to return the guild to.</haxe_doc>
		</getGuild>
		<getGuildUnsafe public="1" set="method" line="459">
			<f a="id">
				<c path="String"/>
				<t path="Null"><c path="com.raidandfade.haxicord.types.Guild"/></t>
			</f>
			<haxe_doc>Unsafely get a guild from cache based on it's id.
        Throws an error if the guild is not cached.
        @param id - The id of the desired guild</haxe_doc>
		</getGuildUnsafe>
		<getDMChannels public="1" set="method" line="471">
			<f a="cb">
				<f a="">
					<c path="Array"><c path="com.raidandfade.haxicord.types.DMChannel"/></c>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>Get a list of all dm channels the bot is in.
        @param cb - Callback to return the channels to.</haxe_doc>
		</getDMChannels>
		<getDMChannelsUnsafe public="1" set="method" line="481">
			<f a=""><c path="Array"><c path="com.raidandfade.haxicord.types.DMChannel"/></c></f>
			<haxe_doc>Get a list of all DMChannels currently in cache</haxe_doc>
		</getDMChannelsUnsafe>
		<getChannel public="1" set="method" line="490">
			<f a="id:cb">
				<c path="String"/>
				<f a="">
					<c path="com.raidandfade.haxicord.types.Channel"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>Get a channel from cache if it's there otherwise get from the API.
        @param id - The id of the desired channel.
        @param cb - The callback to return the channel to.</haxe_doc>
		</getChannel>
		<getChannelUnsafe public="1" set="method" line="506">
			<f a="id">
				<c path="String"/>
				<t path="Null"><c path="com.raidandfade.haxicord.types.Channel"/></t>
			</f>
			<haxe_doc>Unsafely get a channel from cache based on it's id.
        Throws an error if the channel could not be loaded.
        @param id - The id of the desired channel.</haxe_doc>
		</getChannelUnsafe>
		<getUser public="1" set="method" line="519">
			<f a="id:cb">
				<c path="String"/>
				<f a="">
					<c path="com.raidandfade.haxicord.types.User"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>Get a user from cache if it's there otherwise get from API.
        @param id - The id of the desired user.
        @param cb - The callback to return the user to.</haxe_doc>
		</getUser>
		<getUserUnsafe public="1" set="method" line="535">
			<f a="id">
				<c path="String"/>
				<t path="Null"><c path="com.raidandfade.haxicord.types.User"/></t>
			</f>
			<haxe_doc>Unsafely get a user based on it's id from cache.
        Throws an error if the user could not be loaded.
        @param id - The id of the desired user.</haxe_doc>
		</getUserUnsafe>
		<getMessage public="1" set="method" line="549">
			<f a="id:channel_id:cb">
				<c path="String"/>
				<c path="String"/>
				<f a="">
					<c path="com.raidandfade.haxicord.types.Message"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>Get a message from cache if it is there otherwise load from api.
        @param id - The id of the message.
        @param channel_id - The id of the channel the message is from.
        @param cb - The callback to return the message to.</haxe_doc>
		</getMessage>
		<getMessageUnsafe public="1" set="method" line="565">
			<f a="id">
				<c path="String"/>
				<t path="Null"><c path="com.raidandfade.haxicord.types.Message"/></t>
			</f>
			<haxe_doc>Unsafely get a message based on it's id from cache.
        Throws an error if the message could not be loaded.
        @param id - The id of the desired message.</haxe_doc>
		</getMessageUnsafe>
		<_newMessage public="1" set="method" line="576">
			<f a="message_struct">
				<t path="com.raidandfade.haxicord.types.structs.MessageStruct"/>
				<t path="Null"><c path="com.raidandfade.haxicord.types.Message"/></t>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_newMessage>
		<_newUser public="1" set="method" line="590">
			<f a="user_struct">
				<t path="com.raidandfade.haxicord.types.structs.User"/>
				<t path="Null"><c path="com.raidandfade.haxicord.types.User"/></t>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_newUser>
		<_newChannel public="1" set="method" line="604">
			<f a="channel_struct">
				<t path="com.raidandfade.haxicord.types.structs.GuildChannelTypes"/>
				<c path="com.raidandfade.haxicord.types.Channel"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_newChannel>
		<__newChannel public="1" set="method" line="609">
			<f a="channel_struct">
				<d/>
				<f a="">
					<d/>
					<c path="com.raidandfade.haxicord.types.Channel"/>
				</f>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</__newChannel>
		<_newDMChannel public="1" set="method" line="637">
			<f a="channel_struct">
				<t path="com.raidandfade.haxicord.types.structs.DMChannel"/>
				<t path="Null"><c path="com.raidandfade.haxicord.types.DMChannel"/></t>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_newDMChannel>
		<_newGuild public="1" set="method" line="652">
			<f a="guild_struct">
				<t path="com.raidandfade.haxicord.types.structs.Guild"/>
				<t path="Null"><c path="com.raidandfade.haxicord.types.Guild"/></t>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_newGuild>
		<onReady public="1" set="dynamic" line="669">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Event hook for when the bot has connected, loaded cache, and is ready to go.</haxe_doc>
		</onReady>
		<onChannelCreate public="1" set="dynamic" line="675">
			<f a="c">
				<c path="com.raidandfade.haxicord.types.Channel"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event hook for when a new channel is created.
        @param c - The channel object.</haxe_doc>
		</onChannelCreate>
		<onChannelUpdate public="1" set="dynamic" line="680">
			<f a="c">
				<c path="com.raidandfade.haxicord.types.Channel"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event hook for when a channel is changed/updated.
        @param c - The new channel object.</haxe_doc>
		</onChannelUpdate>
		<onChannelDelete public="1" set="dynamic" line="685">
			<f a="channel_id">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event hook for when a channel is deleted.
        @param channel_id - The id of the deleted channel.</haxe_doc>
		</onChannelDelete>
		<onGuildCreate public="1" set="dynamic" line="691">
			<f a="g">
				<c path="com.raidandfade.haxicord.types.Guild"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event hook for when a guild is created or joined by you.
        @param g - The guild object.</haxe_doc>
		</onGuildCreate>
		<onGuildUpdate public="1" set="dynamic" line="696">
			<f a="g">
				<c path="com.raidandfade.haxicord.types.Guild"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event hook for when a guild is updated or changed.
        @param g - The new guild object.</haxe_doc>
		</onGuildUpdate>
		<onGuildDelete public="1" set="dynamic" line="701">
			<f a="guild_id">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event hook for when a guild is deleted
        @param guild_id - The id of the guild that was deleted.</haxe_doc>
		</onGuildDelete>
		<onGuildEmojisUpdate public="1" set="dynamic" line="707">
			<f a="g:emojis">
				<c path="com.raidandfade.haxicord.types.Guild"/>
				<c path="Array"><t path="com.raidandfade.haxicord.types.structs.Emoji"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>Event hook for when a guild updates it's emojis. 
        @param g - The guild the emojis were updated for.
        @param emojis - The new list of emojis</haxe_doc>
		</onGuildEmojisUpdate>
		<onMemberJoin public="1" set="dynamic" line="714">
			<f a="g:m">
				<c path="com.raidandfade.haxicord.types.Guild"/>
				<c path="com.raidandfade.haxicord.types.GuildMember"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event hook for when a new user joins a guild.
        @param g - The guild the user has joined.
        @param m - The instanced member object of the user.</haxe_doc>
		</onMemberJoin>
		<onMemberUpdate public="1" set="dynamic" line="720">
			<f a="g:m">
				<c path="com.raidandfade.haxicord.types.Guild"/>
				<c path="com.raidandfade.haxicord.types.GuildMember"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event hook for when a user is updated or changed. 
        @param g - The guild the user is in.
        @param m - The instanced member object of the user.</haxe_doc>
		</onMemberUpdate>
		<onMemberBan public="1" set="dynamic" line="726">
			<f a="g:u">
				<c path="com.raidandfade.haxicord.types.Guild"/>
				<t path="Null"><c path="com.raidandfade.haxicord.types.User"/></t>
				<x path="Void"/>
			</f>
			<haxe_doc>Event hook for when a user is banned from a guild.
        @param g - The guild the ban was from.
        @param u - The user that was banned (May be null).</haxe_doc>
		</onMemberBan>
		<onMemberUnban public="1" set="dynamic" line="732">
			<f a="g:u">
				<c path="com.raidandfade.haxicord.types.Guild"/>
				<t path="Null"><c path="com.raidandfade.haxicord.types.User"/></t>
				<x path="Void"/>
			</f>
			<haxe_doc>Event hook for when a user is unbanned from a guild.
        @param g - The guild the ban was from.
        @param u - The user that was unbanned (May be null).</haxe_doc>
		</onMemberUnban>
		<onMemberLeave public="1" set="dynamic" line="738">
			<f a="g:u">
				<c path="com.raidandfade.haxicord.types.Guild"/>
				<t path="Null"><c path="com.raidandfade.haxicord.types.User"/></t>
				<x path="Void"/>
			</f>
			<haxe_doc>Event hook for when a member leaves a guild.
        @param g - The guild the member belonged to.
        @param u - The user of the member (May be null).</haxe_doc>
		</onMemberLeave>
		<onRoleCreate public="1" set="dynamic" line="745">
			<f a="g:r">
				<c path="com.raidandfade.haxicord.types.Guild"/>
				<c path="com.raidandfade.haxicord.types.Role"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event hook for when a role is created.
        @param g - The guild it was created in.
        @param r - The role.</haxe_doc>
		</onRoleCreate>
		<onRoleUpdate public="1" set="dynamic" line="751">
			<f a="g:r">
				<c path="com.raidandfade.haxicord.types.Guild"/>
				<c path="com.raidandfade.haxicord.types.Role"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event hook for when a role is changed/updated
        @param g - The guild it was updated in.
        @param r - The new role.</haxe_doc>
		</onRoleUpdate>
		<onRoleDelete public="1" set="dynamic" line="757">
			<f a="g:role_id">
				<c path="com.raidandfade.haxicord.types.Guild"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event hook for when a role is deleted
        @param g - The guild it was deleted from.
        @param role_id - The id of the role that was deleted.</haxe_doc>
		</onRoleDelete>
		<onMessage public="1" set="dynamic" line="763">
			<f a="m">
				<c path="com.raidandfade.haxicord.types.Message"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event hook for when a message is sent.
        @param m - The message.</haxe_doc>
		</onMessage>
		<onMessageEdit public="1" set="dynamic" line="768">
			<f a="m">
				<c path="com.raidandfade.haxicord.types.Message"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event hook for when a message is edited.
        @param m - The new message.</haxe_doc>
		</onMessageEdit>
		<onMessageDelete public="1" set="dynamic" line="773">
			<f a="message_id">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event hook for when a message is deleted.
        @param message_id - The id of the deleted message.</haxe_doc>
		</onMessageDelete>
		<onReactionAdd public="1" set="dynamic" line="781">
			<f a="m:u:e">
				<c path="com.raidandfade.haxicord.types.Message"/>
				<c path="com.raidandfade.haxicord.types.User"/>
				<t path="com.raidandfade.haxicord.types.structs.Emoji"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event hook for when a reaction is added.
        @param m - The message the reaction is added to.
        @param u - The user that added the reaction.
        @param e - The emoji of the reaction.</haxe_doc>
		</onReactionAdd>
		<onReactionRemove public="1" set="dynamic" line="788">
			<f a="m:u:e">
				<c path="com.raidandfade.haxicord.types.Message"/>
				<t path="Null"><c path="com.raidandfade.haxicord.types.User"/></t>
				<t path="com.raidandfade.haxicord.types.structs.Emoji"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event hook for when reactions are removed.
        @param m - The message the reaction was removed from.
        @param u - The user that removed the reaction. (Do not rely on this for purges, may be null)
        @param e - The emoji of the reaction.</haxe_doc>
		</onReactionRemove>
		<onReactionPurge public="1" set="dynamic" line="793">
			<f a="m">
				<c path="com.raidandfade.haxicord.types.Message"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event hook for when reactions are purged from a message.
        @param m - The message that was purged.</haxe_doc>
		</onReactionPurge>
		<onRawEvent public="1" set="dynamic" line="800">
			<f a="e:d">
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>A raw event hook, for things that require a little more flexibility.
        @param e - The event name as defined by API Docs.
        @param d - The event data.</haxe_doc>
		</onRawEvent>
		<new public="1" set="method" line="86">
			<f a="_tkn">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Initialize the bot with your token. This should be the first thing you run in your program.
        @param _tkn - Your BOT token. User tokens do not work!</haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":keep"/>
			<m n=":expose"/>
		</meta>
	</class>
	<typedef path="com.raidandfade.haxicord._DiscordClient.WSMessage" params="" file="src/com/raidandfade/haxicord/DiscordClient.hx" private="1" module="com.raidandfade.haxicord.DiscordClient"><a>
	<t><c path="String"/></t>
	<s><x path="Int"/></s>
	<op><x path="Int"/></op>
	<d><d/></d>
</a></typedef>
	<class path="com.raidandfade.haxicord._DiscordClient.WSPrepareData" params="" file="src/com/raidandfade/haxicord/DiscordClient.hx" private="1" module="com.raidandfade.haxicord.DiscordClient">
		<Identify public="1" set="method" line="812" static="1">
			<f a="t:?p:?c:?l:?s" v=":null:false:59:null">
				<c path="String"/>
				<t path="com.raidandfade.haxicord._DiscordClient.WSIdentify_Properties"/>
				<x path="Bool"/>
				<x path="Int"/>
				<t path="com.raidandfade.haxicord._DiscordClient.WSShard"/>
				<a>
					<op><x path="Int"/></op>
					<d><a>
	<token><c path="String"/></token>
	<shard><t path="Null"><t path="com.raidandfade.haxicord._DiscordClient.WSShard"/></t></shard>
	<properties><t path="Null"><t path="com.raidandfade.haxicord._DiscordClient.WSIdentify_Properties"/></t></properties>
	<large_threshhold><x path="Int"/></large_threshhold>
	<compress><x path="Bool"/></compress>
</a></d>
				</a>
			</f>
			<meta><m n=":value"><e>{ s : null, l : 59, c : false, p : null }</e></m></meta>
		</Identify>
		<Heartbeat public="1" set="method" line="818" static="1">
			<f a="?seq" v="null">
				<x path="Int"/>
				<a>
					<op><x path="Int"/></op>
					<d><t path="Null"><x path="Int"/></t></d>
				</a>
			</f>
			<meta><m n=":value"><e>{ seq : null }</e></m></meta>
		</Heartbeat>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="com.raidandfade.haxicord._DiscordClient.WSShard" params="" file="src/com/raidandfade/haxicord/DiscordClient.hx" private="1" module="com.raidandfade.haxicord.DiscordClient"><c path="Array"><x path="Int"/></c></typedef>
	<typedef path="com.raidandfade.haxicord._DiscordClient.WSIdentify_Properties" params="" file="src/com/raidandfade/haxicord/DiscordClient.hx" private="1" module="com.raidandfade.haxicord.DiscordClient"><a>
	<referring_domain>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</referring_domain>
	<referrer>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</referrer>
	<os>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</os>
	<device>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</device>
	<browser>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</browser>
</a></typedef>
	<typedef path="com.raidandfade.haxicord._DiscordClient.WSReady" params="" file="src/com/raidandfade/haxicord/DiscordClient.hx" private="1" module="com.raidandfade.haxicord.DiscordClient"><a>
	<v>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</v>
	<user_settings>
		<t path="Null"><d/></t>
		<meta><m n=":optional"/></meta>
	</user_settings>
	<user>
		<t path="Null"><t path="com.raidandfade.haxicord.types.structs.User"/></t>
		<meta><m n=":optional"/></meta>
	</user>
	<shard>
		<t path="Null"><c path="Array"><x path="Int"/></c></t>
		<meta><m n=":optional"/></meta>
	</shard>
	<session_id>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</session_id>
	<relationships>
		<t path="Null"><d/></t>
		<meta><m n=":optional"/></meta>
	</relationships>
	<private_channels>
		<t path="Null"><c path="Array"><t path="com.raidandfade.haxicord.types.structs.DMChannel"/></c></t>
		<meta><m n=":optional"/></meta>
	</private_channels>
	<presences>
		<t path="Null"><c path="Array"><t path="com.raidandfade.haxicord.types.structs.Presence"/></c></t>
		<meta><m n=":optional"/></meta>
	</presences>
	<guilds>
		<t path="Null"><c path="Array"><t path="com.raidandfade.haxicord.types.structs.Guild"/></c></t>
		<meta><m n=":optional"/></meta>
	</guilds>
	<_trace>
		<t path="Null"><d/></t>
		<meta><m n=":optional"/></meta>
	</_trace>
</a></typedef>
	<class path="com.raidandfade.haxicord._DiscordClient.HeartbeatThread" params="" file="src/com/raidandfade/haxicord/DiscordClient.hx" private="1" module="com.raidandfade.haxicord.DiscordClient">
		<delay public="1"><x path="Int"/></delay>
		<seq><t path="Null"><x path="Int"/></t></seq>
		<ws><c path="com.raidandfade.haxicord.websocket.WebSocketConnection"/></ws>
		<timer><c path="haxe.Timer"/></timer>
		<cl><c path="com.raidandfade.haxicord.DiscordClient"/></cl>
		<paused><x path="Bool"/></paused>
		<setSeq public="1" set="method" line="856"><f a="_s">
	<t path="Null"><x path="Int"/></t>
	<x path="Void"/>
</f></setSeq>
		<beat public="1" set="method" line="869"><f a=""><x path="Void"/></f></beat>
		<pause public="1" set="method" line="874"><f a=""><x path="Void"/></f></pause>
		<resume public="1" set="method" line="879"><f a=""><x path="Void"/></f></resume>
		<new public="1" set="method" line="860"><f a="_d:_w:_s:_b">
	<x path="Int"/>
	<c path="com.raidandfade.haxicord.websocket.WebSocketConnection"/>
	<t path="Null"><x path="Int"/></t>
	<c path="com.raidandfade.haxicord.DiscordClient"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="com.raidandfade.haxicord.endpoints.Endpoints" params="" file="src/com/raidandfade/haxicord/endpoints/Endpoints.hx">
		<client>
			<c path="com.raidandfade.haxicord.DiscordClient"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</client>
		<lastGlobalCheck expr="-1">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>-1</e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</lastGlobalCheck>
		<globalReqsLeft expr="50">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>50</e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</globalReqsLeft>
		<rateLimitCache expr="new Map&lt;String,RateLimit&gt;()">
			<x path="Map">
				<c path="String"/>
				<c path="com.raidandfade.haxicord.endpoints.RateLimit"/>
			</x>
			<meta>
				<m n=":value"><e><![CDATA[new Map<String,RateLimit>()]]></e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</rateLimitCache>
		<limitedQueue expr="new Map&lt;String,Array&lt;EndpointCall&gt;&gt;()">
			<x path="Map">
				<c path="String"/>
				<c path="Array"><c path="com.raidandfade.haxicord.endpoints.EndpointCall"/></c>
			</x>
			<meta>
				<m n=":value"><e><![CDATA[new Map<String,Array<EndpointCall>>()]]></e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</limitedQueue>
		<getGateway public="1" set="method" line="62">
			<f a="?bot:?cb" v="false:null">
				<x path="Bool"/>
				<f a=":">
					<t path="com.raidandfade.haxicord.endpoints.Gateway"/>
					<t path="com.raidandfade.haxicord.endpoints.ErrorReport"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null, bot : false }</e></m></meta>
			<haxe_doc>Get the gateway that the client should connect to. 
        @param bot - Will get the bot gateway along with reccomended shard info if true.
        @param cb - The callback to call once gotten. Or null if result is not desired.</haxe_doc>
		</getGateway>
		<getChannel public="1" set="method" line="73">
			<f a="channel_id:?cb" v=":null">
				<c path="String"/>
				<f a=":">
					<c path="com.raidandfade.haxicord.types.Channel"/>
					<t path="com.raidandfade.haxicord.endpoints.ErrorReport"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Get a channel based on a given channel id.
        @param channel_id - The channel id to get the channel from
        @param cb - Callback to send the receivied channel object to. Or null if result is not desired.</haxe_doc>
		</getChannel>
		<createChannel public="1" set="method" line="88">
			<f a="guild_id:channel_data:?cb" v="::null">
				<c path="String"/>
				<t path="com.raidandfade.haxicord.endpoints.ChannelCreate"/>
				<t path="com.raidandfade.haxicord.endpoints.EmptyResponseCallback"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Create a channel in a guild
        @param guild_id - The guild to create the channel in
        @param channel_data - The channel's starting data 
        @param cb - Callback to send the new channel object to. Or null if result is not desired.</haxe_doc>
		</createChannel>
		<modifyChannel public="1" set="method" line="100">
			<f a="channel_id:channel_data:?cb" v="::null">
				<c path="String"/>
				<t path="com.raidandfade.haxicord.endpoints.ChannelUpdate"/>
				<f a=":">
					<c path="com.raidandfade.haxicord.types.Channel"/>
					<t path="com.raidandfade.haxicord.endpoints.ErrorReport"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Change a channel's parameters
        @param channel_id - The id of the channel to be modified
        @param channel_data - The changed channel data, all fields are optional
        @param cb - Callback to send the new channel object to. Or null if result is not desired.</haxe_doc>
		</modifyChannel>
		<deleteChannel public="1" set="method" line="115">
			<f a="channel_id:?cb" v=":null">
				<c path="String"/>
				<f a=":">
					<c path="com.raidandfade.haxicord.types.Channel"/>
					<t path="com.raidandfade.haxicord.endpoints.ErrorReport"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Delete the given channel.
        @param channel_id - Channel id of channel to delete
        @param cb - Callback to send old channel to. Or null if result is not desired.</haxe_doc>
		</deleteChannel>
		<editChannelPermissions public="1" set="method" line="132">
			<f a="channel_id:overwrite_id:new_permission:?cb" v=":::null">
				<c path="String"/>
				<c path="String"/>
				<t path="com.raidandfade.haxicord.types.structs.Overwrite"/>
				<t path="com.raidandfade.haxicord.endpoints.EmptyResponseCallback"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Edit or Create a channel's overwrite permissions;
        @param channel_id - The channel
        @param overwrite_id - The overwrite Id, Id of user or role.
        @param new_permission - The modified overwrite permission object
        @param cb - Call once finished.</haxe_doc>
		</editChannelPermissions>
		<deleteChannelPermission public="1" set="method" line="143">
			<f a="channel_id:overwrite_id:?cb" v="::null">
				<c path="String"/>
				<c path="String"/>
				<t path="com.raidandfade.haxicord.endpoints.EmptyResponseCallback"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Delete a channel override
        @param channel_id - The channel
        @param overwrite_id - The overwrite id to delete
        @param cb - Call once finished.</haxe_doc>
		</deleteChannelPermission>
		<getChannelInvites public="1" set="method" line="154">
			<f a="channel_id:?cb" v=":null">
				<c path="String"/>
				<f a=":">
					<c path="Array"><t path="com.raidandfade.haxicord.types.structs.Invite"/></c>
					<t path="com.raidandfade.haxicord.endpoints.ErrorReport"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Get the invites of a given channel
        @param channel_id - The channel
        @param cb - Array of Invites (or error).</haxe_doc>
		</getChannelInvites>
		<createChannelInvite public="1" set="method" line="166">
			<f a="channel_id:invite:?cb" v="::null">
				<c path="String"/>
				<t path="com.raidandfade.haxicord.endpoints.InviteCreate"/>
				<t path="com.raidandfade.haxicord.endpoints.EmptyResponseCallback"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Create a new invite for a given channel
        @param channel_id - The channel
        @param invite - The invite data.
        @param cb - Return the invite or an error.</haxe_doc>
		</createChannelInvite>
		<getChannelPins public="1" set="method" line="177">
			<f a="channel_id:?cb" v=":null">
				<c path="String"/>
				<f a=":">
					<c path="Array"><c path="com.raidandfade.haxicord.types.Message"/></c>
					<t path="com.raidandfade.haxicord.endpoints.ErrorReport"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Get the pins of a channel
        @param channel_id - The channel
        @param cb - Return an array of pins (or an error)</haxe_doc>
		</getChannelPins>
		<addChannelPin public="1" set="method" line="195">
			<f a="channel_id:message_id:?cb" v="::null">
				<c path="String"/>
				<c path="String"/>
				<t path="com.raidandfade.haxicord.endpoints.EmptyResponseCallback"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Add a channel pin
        @param channel_id - The channel
        @param message_id - The message
        @param cb - Called once completed. Leave blank to ignore.</haxe_doc>
		</addChannelPin>
		<deleteChannelPin public="1" set="method" line="207">
			<f a="channel_id:message_id:?cb" v="::null">
				<c path="String"/>
				<c path="String"/>
				<t path="com.raidandfade.haxicord.endpoints.EmptyResponseCallback"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Delete a channel's pin
        @param channel_id - The channel
        @param message_id - The pin id
        @param cb - Called once completed. Leave blank to ignore.</haxe_doc>
		</deleteChannelPin>
		<groupDMAddRecipient public="1" set="method" line="223">
			<f a="channel_id:user_id:access_token:nick:?cb" v="::::null">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<t path="com.raidandfade.haxicord.endpoints.EmptyResponseCallback"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Add a user to a group dm.
        @param channel_id - The group dm's channel.
        @param user_id - The user to be added.
        @param access_token - An OAUTH2 token received from authenticating the user.
        @param nick - The nickname of the user.
        @param cb - Called once completed.</haxe_doc>
		</groupDMAddRecipient>
		<groupDMRemoveRecipient public="1" set="method" line="234">
			<f a="channel_id:user_id:?cb" v="::null">
				<c path="String"/>
				<c path="String"/>
				<t path="com.raidandfade.haxicord.endpoints.EmptyResponseCallback"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Remove a user from a group dm.
        @param channel_id - The group dm's channel.
        @param user_id - The user to be removed
        @param cb - Called once completed, or errored</haxe_doc>
		</groupDMRemoveRecipient>
		<getMessages public="1" set="method" line="247">
			<f a="channel_id:format:?cb" v="::null">
				<c path="String"/>
				<t path="com.raidandfade.haxicord.endpoints.MessagesRequest"/>
				<f a=":">
					<c path="Array"><c path="com.raidandfade.haxicord.types.Message"/></c>
					<t path="com.raidandfade.haxicord.endpoints.ErrorReport"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Get messages from a given channel according to the given format.
        @param channel_id - The channel
        @param format - Before, After, or Around. 
        @param cb - The array of messages, or an error.</haxe_doc>
		</getMessages>
		<getMessage public="1" set="method" line="266">
			<f a="channel_id:message_id:?cb" v="::null">
				<c path="String"/>
				<c path="String"/>
				<f a=":">
					<c path="com.raidandfade.haxicord.types.Message"/>
					<t path="com.raidandfade.haxicord.endpoints.ErrorReport"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Get a message in a channel
        @param channel_id - The channel id
        @param message_id - The message id
        @param cb - Return the message, or an error.</haxe_doc>
		</getMessage>
		<sendMessage public="1" set="method" line="282">
			<f a="channel_id:message:?cb" v="::null">
				<c path="String"/>
				<t path="com.raidandfade.haxicord.endpoints.MessageCreate"/>
				<f a=":">
					<c path="com.raidandfade.haxicord.types.Message"/>
					<t path="com.raidandfade.haxicord.endpoints.ErrorReport"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Send a message to a channel
        @param channel_id - The channel to send to
        @param message - Message data
        @param cb - Return the message sent, or an error</haxe_doc>
		</sendMessage>
		<startTyping public="1" set="method" line="297">
			<f a="channel_id:?cb" v=":null">
				<c path="String"/>
				<t path="com.raidandfade.haxicord.endpoints.EmptyResponseCallback"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Send a typing event in the given channel. This lasts for 10 seconds or when a message is sent, whichever comes first.
        @param channel_id - The channel to type in.
        @param cb - Return when complete.</haxe_doc>
		</startTyping>
		<editMessage public="1" set="method" line="310">
			<f a="channel_id:message_id:message:?cb" v=":::null">
				<c path="String"/>
				<c path="String"/>
				<t path="com.raidandfade.haxicord.endpoints.MessageEdit"/>
				<f a=":">
					<c path="com.raidandfade.haxicord.types.Message"/>
					<t path="com.raidandfade.haxicord.endpoints.ErrorReport"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Edit a message previously sent by you.
        @param channel_id - The channel the message is in.
        @param message_id - The id of the message desired to be changed.
        @param message - The new content of the message, all fields are optional.
        @param cb - Return the new message, or an error.</haxe_doc>
		</editMessage>
		<deleteMessage public="1" set="method" line="325">
			<f a="channel_id:message_id:?cb" v="::null">
				<c path="String"/>
				<c path="String"/>
				<t path="com.raidandfade.haxicord.endpoints.EmptyResponseCallback"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Delete a given message. If the author is not the current user, the MANAGE_MESSAGES permission is required
        @param channel_id - The channel the message is in.
        @param message_id - The id of the message.
        @param cb - Return when complete.</haxe_doc>
		</deleteMessage>
		<deleteMessages public="1" set="method" line="336">
			<f a="channel_id:message_ids:?cb" v="::null">
				<c path="String"/>
				<t path="com.raidandfade.haxicord.endpoints.MessageBulkDelete"/>
				<t path="com.raidandfade.haxicord.endpoints.EmptyResponseCallback"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Delete a given messages. MANAGE_MESSAGES is required.
        @param channel_id - The channel the message is in.
        @param message_ids - an array of id of the messages.
        @param cb - Return when complete.</haxe_doc>
		</deleteMessages>
		<createReaction public="1" set="method" line="350">
			<f a="channel_id:message_id:emoji:?cb" v=":::null">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<t path="com.raidandfade.haxicord.endpoints.EmptyResponseCallback"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Add a reaction to a message. requires READ_MESSAGE_HISTORY and ADD_REACTIONS if the emoji is not already present.
        @param channel_id - The channel that contains the message.
        @param message_id - The message to react to.
        @param emoji - The emote to be added, Custom emotes require their TAG.
        @param cb - Called when completed, good for checking for errors.</haxe_doc>
		</createReaction>
		<deleteOwnReaction public="1" set="method" line="363">
			<f a="channel_id:message_id:emoji:?cb" v=":::null">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<t path="com.raidandfade.haxicord.endpoints.EmptyResponseCallback"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Delete a reaction of your own off of a message.
        @param channel_id - The channel that contains the message.
        @param message_id - The message to delete the reaction from.
        @param emoji - The emote to be removed. Custom emotes require their TAG
        @param cb - Called when completed, good for checking for errors.</haxe_doc>
		</deleteOwnReaction>
		<deleteUserReaction public="1" set="method" line="376">
			<f a="channel_id:message_id:user_id:emoji:?cb" v="::::null">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<t path="com.raidandfade.haxicord.endpoints.EmptyResponseCallback"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Delete another user's reaction off of a message.
        @param channel_id - The channel that contains the message.
        @param message_id - The message to delete the reaction from.
        @param user_id - The user to delete the reaction from.
        @param emoji - The emote to be removed. Custom emotes require their TAG
        @param cb - Called when completed, good for checking for errors.</haxe_doc>
		</deleteUserReaction>
		<getReactions public="1" set="method" line="389">
			<f a="channel_id:message_id:emoji:?cb" v=":::null">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<f a=":">
					<c path="Array"><t path="com.raidandfade.haxicord.types.structs.Reaction"/></c>
					<c path="String"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Get all reactions of emoji by user on a message.
        @param channel_id - The channel that contains the message.
        @param message_id - The message to get reactions from.
        @param emoji - The emoji to look for.
        @param cb - Returns an array of Reaction objects, or an error.</haxe_doc>
		</getReactions>
		<deleteAllReactions public="1" set="method" line="400">
			<f a="channel_id:message_id:?cb" v="::null">
				<c path="String"/>
				<c path="String"/>
				<t path="com.raidandfade.haxicord.endpoints.EmptyResponseCallback"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Delete all reactions from a message. Requires the MANAGE_MESSAGES permission.
        @param channel_id - The channel that contains the message.
        @param message_id - The message to remove reactions from.
        @param cb - Called when completed, good for looking for errors.</haxe_doc>
		</deleteAllReactions>
		<createGuild public="1" set="method" line="412">
			<f a="guild_data:?cb" v=":null">
				<t path="com.raidandfade.haxicord.endpoints.GuildCreate"/>
				<f a=":">
					<c path="com.raidandfade.haxicord.types.Guild"/>
					<t path="com.raidandfade.haxicord.endpoints.ErrorReport"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Create a new guild based on the data given
        @param guild_data - The data to be changed, All fields are optional.
        @param cb - Returns the new guild object, or an error.</haxe_doc>
		</createGuild>
		<getGuild public="1" set="method" line="427">
			<f a="guild_id:?cb" v=":null">
				<c path="String"/>
				<f a=":">
					<c path="com.raidandfade.haxicord.types.Guild"/>
					<c path="String"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Get a guild by the id.
        @param guild_id - The guild id
        @param cb - Return the guild object, or an error.</haxe_doc>
		</getGuild>
		<getAuditLogs public="1" set="method" line="442">
			<f a="guild_id:?filter:?cb" v=":null:null">
				<c path="String"/>
				<t path="com.raidandfade.haxicord.endpoints.AuditLogFilter"/>
				<f a=":">
					<t path="com.raidandfade.haxicord.types.structs.AuditLog"/>
					<t path="com.raidandfade.haxicord.endpoints.ErrorReport"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null, filter : null }</e></m></meta>
			<haxe_doc>Get a guild's audit logs
        @param guild_id - The guild id to get 
        @param filter - Filter audit logs by these parameters.
        @param cb - Returns the AuditLog object, or an error.</haxe_doc>
		</getAuditLogs>
		<modifyGuild public="1" set="method" line="460">
			<f a="guild_id:guild_data:?cb" v="::null">
				<c path="String"/>
				<t path="com.raidandfade.haxicord.endpoints.GuildUpdate"/>
				<f a=":">
					<c path="com.raidandfade.haxicord.types.Guild"/>
					<t path="com.raidandfade.haxicord.endpoints.ErrorReport"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Edit a guild's settings. Requires the MANAGE_GUILD permission
        @param guild_id - The guild id.
        @param guild_data - The data to be changed, All fields are optional.
        @param cb - Returns the new guild object, or an error.</haxe_doc>
		</modifyGuild>
		<deleteGuild public="1" set="method" line="475">
			<f a="guild_id:?cb" v=":null">
				<c path="String"/>
				<t path="com.raidandfade.haxicord.endpoints.EmptyResponseCallback"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Delete a guild. The account must be the owner of the guild.
        @param guild_id - The guild to delete.
        @param cb - Return the old guild object, or an error.</haxe_doc>
		</deleteGuild>
		<getChannels public="1" set="method" line="486">
			<f a="guild_id:?cb" v=":null">
				<c path="String"/>
				<f a=":">
					<c path="Array"><c path="com.raidandfade.haxicord.types.Channel"/></c>
					<t path="com.raidandfade.haxicord.endpoints.ErrorReport"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Get the channels in a guild
        @param guild_id - The guild id.
        @param cb - Return an array of channel objects, or an error.</haxe_doc>
		</getChannels>
		<moveChannel public="1" set="method" line="505">
			<f a="guild_id:changes:?cb" v="::null">
				<c path="String"/>
				<t path="com.raidandfade.haxicord.endpoints.PositionChange"/>
				<f a=":">
					<c path="Array"><c path="com.raidandfade.haxicord.types.Channel"/></c>
					<c path="String"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Move two or more channel's positions within a guild. Requires the MANAGE_CHANNELS permission.
        @param guild_id - The id of the guild
        @param changes - An array of changes to channel positions
        @param cb - Return an array of the channels within the guild, or an error.</haxe_doc>
		</moveChannel>
		<getGuildMember public="1" set="method" line="524">
			<f a="guild_id:user_id:?cb" v="::null">
				<c path="String"/>
				<c path="String"/>
				<f a=":">
					<c path="com.raidandfade.haxicord.types.GuildMember"/>
					<t path="com.raidandfade.haxicord.endpoints.ErrorReport"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Get a member of the guild.
        @param guild_id - The guild id.
        @param user_id - The member's id.
        @param cb - Return a member instance of the user. Or an error.</haxe_doc>
		</getGuildMember>
		<getGuildMembers public="1" set="method" line="538">
			<f a="guild_id:format:?cb" v="::null">
				<c path="String"/>
				<t path="com.raidandfade.haxicord.endpoints.ListGuildMember"/>
				<f a=":">
					<c path="Array"><c path="com.raidandfade.haxicord.types.GuildMember"/></c>
					<c path="String"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Get all members of a guild. 
        @param guild_id - The id of the guild.
        @param format - The limit, and after. both are optional. used for paginating.
        @param cb - The array of guild members. or an error.</haxe_doc>
		</getGuildMembers>
		<addGuildMember public="1" set="method" line="558">
			<f a="guild_id:user_id:member_data:?cb" v=":::null">
				<c path="String"/>
				<c path="String"/>
				<t path="com.raidandfade.haxicord.endpoints.AddGuildMember"/>
				<f a=":">
					<c path="com.raidandfade.haxicord.types.GuildMember"/>
					<c path="String"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Add a guild member using a token received through Oauth2. 
        Requires the CREATE_INSTANT_INVITE permission along with various other permissions depending on `member_data` parameters
        @param guild_id - The id of the guild.
        @param user_id - The id of the user
        @param member_data - The access token, along with other optional parameters.
        @param cb - The added guildmember. or an error.</haxe_doc>
		</addGuildMember>
		<editGuildMember public="1" set="method" line="575">
			<f a="guild_id:user_id:member_data:?cb" v=":::null">
				<c path="String"/>
				<c path="String"/>
				<t path="com.raidandfade.haxicord.endpoints.EditGuildMember"/>
				<t path="com.raidandfade.haxicord.endpoints.EmptyResponseCallback"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Edit a guild member's properties, requires various permissions depending on the data provided. 
        @param guild_id - The guild the member is in.
        @param user_id - The id of the member.
        @param member_data - The updated data, all parameters are optional. All parameters require a different permission.
        @param cb - Called on completion, useful for checking for errors.</haxe_doc>
		</editGuildMember>
		<changeNickname public="1" set="method" line="586">
			<f a="guild_id:nickname:?cb" v="::null">
				<c path="String"/>
				<c path="String"/>
				<f a=":">
					<c path="String"/>
					<t path="com.raidandfade.haxicord.endpoints.ErrorReport"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Change this user's nickname.
        @param guild_id - The guild to change nickname in.
        @param nickname - The nickname to change to.
        @param cb - Returns the nickname, or an error.</haxe_doc>
		</changeNickname>
		<giveMemberRole public="1" set="method" line="598">
			<f a="guild_id:user_id:role_id:?cb" v=":::null">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<t path="com.raidandfade.haxicord.endpoints.EmptyResponseCallback"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Give a role to a member. Requires the MANAGE_ROLES permission
        @param guild_id - The guild that the user is in. 
        @param user_id - The id of the user.
        @param role_id - The id of the role desired to be added.
        @param cb - Called on completion, useful for checking for errors.</haxe_doc>
		</giveMemberRole>
		<takeMemberRole public="1" set="method" line="611">
			<f a="guild_id:user_id:role_id:?cb" v=":::null">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<t path="com.raidandfade.haxicord.endpoints.EmptyResponseCallback"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Take a role away from a member. Requires the MANAGE_ROLES permission
        @param guild_id - The guild id.
        @param user_id - The id of the user.
        @param role_id - The id of the role to take away.
        @param cb - Called on completion, useful for checking for errors.</haxe_doc>
		</takeMemberRole>
		<kickMember public="1" set="method" line="623">
			<f a="guild_id:user_id:?cb" v="::null">
				<c path="String"/>
				<c path="String"/>
				<t path="com.raidandfade.haxicord.endpoints.EmptyResponseCallback"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Kick a member from the guild. Requires the KICK_MEMBERS permission
        @param guild_id - The guild id.
        @param user_id - The user id.
        @param cb - Called on completion, useful for checking for errors.</haxe_doc>
		</kickMember>
		<getGuildBans public="1" set="method" line="634">
			<f a="guild_id:?cb" v=":null">
				<c path="String"/>
				<f a=":">
					<c path="Array"><c path="com.raidandfade.haxicord.types.User"/></c>
					<t path="com.raidandfade.haxicord.endpoints.ErrorReport"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>List all the bans in a guild. Requires the BAN_MEMBERS permission.
        @param guild_id - The guild id.
        @param cb - Returns an array of users, or an error.</haxe_doc>
		</getGuildBans>
		<banMember public="1" set="method" line="654">
			<f a="guild_id:user_id:days:?cb" v=":::null">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<t path="com.raidandfade.haxicord.endpoints.EmptyResponseCallback"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Ban a member of the guild. Requires the BAN_MEMBERS permission.
        @param guild_id - The guild to ban from.
        @param user_id - The user to ban.
        @param days - Number of days (from 0-7) to remove the user's messages server wide.
        @param cb - Called on completion, useful for checking for errors.</haxe_doc>
		</banMember>
		<unbanMember public="1" set="method" line="666">
			<f a="guild_id:user_id:?cb" v="::null">
				<c path="String"/>
				<c path="String"/>
				<t path="com.raidandfade.haxicord.endpoints.EmptyResponseCallback"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Unban a member of the guild. Requires the BAN_MEMBERS permission.
        @param guild_id - The guild to unban from.
        @param user_id - The user to unban.
        @param cb - Called on completion, useful for checking for errors.</haxe_doc>
		</unbanMember>
		<getGuildRoles public="1" set="method" line="677">
			<f a="guild_id:?cb" v=":null">
				<c path="String"/>
				<f a=":">
					<c path="Array"><c path="com.raidandfade.haxicord.types.Role"/></c>
					<t path="com.raidandfade.haxicord.endpoints.ErrorReport"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Get the roles of a guild. Requires the MANAGE_ROLES permission.
        @param guild_id - The guild to fetch roles for.
        @param cb - Returns an array of guilds, or an error.</haxe_doc>
		</getGuildRoles>
		<createRole public="1" set="method" line="696">
			<f a="guild_id:role_data:?cb" v="::null">
				<c path="String"/>
				<t path="com.raidandfade.haxicord.endpoints.RoleInfo"/>
				<f a=":">
					<c path="com.raidandfade.haxicord.types.Role"/>
					<t path="com.raidandfade.haxicord.endpoints.ErrorReport"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Create a role. Requires the MANAGE_ROLES permission.
        @param guild_id - The guild to add a role to.
        @param role_data - The role's data.
        @param cb - Returns the new role, or an error.</haxe_doc>
		</createRole>
		<moveRole public="1" set="method" line="713">
			<f a="guild_id:changes:?cb" v="::null">
				<c path="String"/>
				<t path="com.raidandfade.haxicord.endpoints.PositionChange"/>
				<f a=":">
					<c path="Array"><c path="com.raidandfade.haxicord.types.Role"/></c>
					<t path="com.raidandfade.haxicord.endpoints.ErrorReport"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Move the position of two or more roles in the hierarchy, requiers the MANAGE_ROLES permission.
        @param guild_id - The guild to make the changes in.
        @param changes - An array of changes to position.
        @param cb - Returns an array of the roles of the server with their new positions, or an error.</haxe_doc>
		</moveRole>
		<editRole public="1" set="method" line="733">
			<f a="guild_id:role_id:role_data:?cb" v=":::null">
				<c path="String"/>
				<c path="String"/>
				<t path="com.raidandfade.haxicord.endpoints.RoleInfo"/>
				<f a=":">
					<c path="com.raidandfade.haxicord.types.Role"/>
					<t path="com.raidandfade.haxicord.endpoints.ErrorReport"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Edit a role's data. Requires the MANAGE_ROLES permission.
        @param guild_id - The guild id to make the changes in.
        @param role_id - The role to change.
        @param role_data - The new data, All fields are optional. 
        @param cb - Returns the new role, or an error.</haxe_doc>
		</editRole>
		<deleteRole public="1" set="method" line="749">
			<f a="guild_id:role_id:?cb" v="::null">
				<c path="String"/>
				<c path="String"/>
				<t path="com.raidandfade.haxicord.endpoints.EmptyResponseCallback"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Delete a role from a guild. Requires the MANAGE_ROLES permission.
        @param guild_id - The guild to remove from.
        @param role_id - The role to remove.
        @param cb - Called on completion, useful for checking for errors.</haxe_doc>
		</deleteRole>
		<getPruneCount public="1" set="method" line="761">
			<f a="guild_id:?days:?cb" v=":1:null">
				<c path="String"/>
				<x path="Int"/>
				<f a=":">
					<x path="Int"/>
					<t path="com.raidandfade.haxicord.endpoints.ErrorReport"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null, days : 1 }</e></m></meta>
			<haxe_doc>Get the number of users that will be pruned if a prune was run. Requires the KICK_MEMBERS permission.
        @param guild_id - The guild to prune in.
        @param days - The number of days to count prune for.
        @param cb - Returns the number of users that would be pruned on a real request, or an error.</haxe_doc>
		</getPruneCount>
		<beginPrune public="1" set="method" line="777">
			<f a="guild_id:?days:?cb" v=":1:null">
				<c path="String"/>
				<x path="Int"/>
				<f a=":">
					<x path="Int"/>
					<t path="com.raidandfade.haxicord.endpoints.ErrorReport"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null, days : 1 }</e></m></meta>
			<haxe_doc>Prune the members of a server. Requires the KICK_MEMBERS permission
        @param guild_id - The guild to prune in.
        @param days - The number of days to count prune for.
        @param cb - Returns the number of users that were pruned, or an error.</haxe_doc>
		</beginPrune>
		<guildVoiceRegions public="1" set="method" line="792">
			<f a="guild_id:?cb" v=":null">
				<c path="String"/>
				<f a=":">
					<c path="Array"><t path="com.raidandfade.haxicord.types.structs.VoiceRegion"/></c>
					<t path="com.raidandfade.haxicord.endpoints.ErrorReport"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Get a list of voice regions for the guild. Including VIP servers if the server is a VIP-Enabled server.
        @param guild_id - The guild to get the list for.
        @param cb - Returns an array of voiceregion objects, or an error.</haxe_doc>
		</guildVoiceRegions>
		<getIntegrations public="1" set="method" line="806">
			<f a="guild_id:?cb" v=":null">
				<c path="String"/>
				<f a=":">
					<c path="Array"><t path="com.raidandfade.haxicord.types.structs.GuildIntegration"/></c>
					<t path="com.raidandfade.haxicord.endpoints.ErrorReport"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Get a list of integrations for a given guild. Requires the MANAGE_GUILD permission.
        @param guild_id - The guild to get the list for.
        @param cb - Returns an array of guildintegration objects, or an error.</haxe_doc>
		</getIntegrations>
		<addIntegration public="1" set="method" line="818">
			<f a="guild_id:int_data:?cb" v="::null">
				<c path="String"/>
				<t path="com.raidandfade.haxicord.endpoints.IntegrationCreate"/>
				<t path="com.raidandfade.haxicord.endpoints.EmptyResponseCallback"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Add a new integration from the user onto the guild. Requires the MANAGE_GUILD permission.
        @param guild_id - The id to add the integration to.
        @param int_data - The data of the new integration. 
        @param cb - Called on completion, useful for checking for errors.</haxe_doc>
		</addIntegration>
		<editIntegration public="1" set="method" line="831">
			<f a="guild_id:int_id:int_data:?cb" v=":::null">
				<c path="String"/>
				<c path="String"/>
				<t path="com.raidandfade.haxicord.endpoints.IntegrationModify"/>
				<t path="com.raidandfade.haxicord.endpoints.EmptyResponseCallback"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Edit an integration in a guild. Requires the MANAGE_GUILD permission.
        @param guild_id - The guild that contains the integration.
        @param int_id - The id of the integration to change.
        @param int_data - The new data for the integration. All parameters are optional.
        @param cb - Called on completion, useful for checking for errors.</haxe_doc>
		</editIntegration>
		<deleteIntegration public="1" set="method" line="843">
			<f a="guild_id:int_id:?cb" v="::null">
				<c path="String"/>
				<c path="String"/>
				<t path="com.raidandfade.haxicord.endpoints.EmptyResponseCallback"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Remove an integration from a guild. Requires the MANAGE_GUILD permission.
        @param guild_id - The guild that contains the integration.
        @param int_id - The id of the integration to remove.
        @param cb - Called on completion, useful for checking for errors.</haxe_doc>
		</deleteIntegration>
		<syncIntegration public="1" set="method" line="855">
			<f a="guild_id:int_id:?cb" v="::null">
				<c path="String"/>
				<c path="String"/>
				<t path="com.raidandfade.haxicord.endpoints.EmptyResponseCallback"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Sync a given integration in a guild. Requires the MANAGE_GUILD permission.
        @param guild_id - The id of the guild that contains the integration.
        @param int_id - The id of the integration to sync.
        @param cb - Called on completion, useful for checking for errors.</haxe_doc>
		</syncIntegration>
		<getWidget public="1" set="method" line="866">
			<f a="guild_id:?cb" v=":null">
				<c path="String"/>
				<f a=":">
					<t path="com.raidandfade.haxicord.types.structs.GuildEmbed"/>
					<t path="com.raidandfade.haxicord.endpoints.ErrorReport"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Get the widget/embed for a guild. Requires the MANAGE_GUILD permission.
        @param guild_id - The id of the guild to fetch the widget from.
        @param cb - Returns the GuildEmbed object of the guild, or an error.</haxe_doc>
		</getWidget>
		<modifyWidget public="1" set="method" line="878">
			<f a="guild_id:edits:?cb" v="::null">
				<c path="String"/>
				<t path="com.raidandfade.haxicord.types.structs.GuildEmbed"/>
				<f a=":">
					<t path="com.raidandfade.haxicord.types.structs.GuildEmbed"/>
					<t path="com.raidandfade.haxicord.endpoints.ErrorReport"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Change the properties of a guild's embed or widget. Requires the MANAGE_GUILD permission.
        @param guild_id - The guild that contains the widget/embed.
        @param edits - The changes to be made to the widget/embed. All parameters are optional.
        @param cb - Returns the changed GuildEmbed object, or an error.</haxe_doc>
		</modifyWidget>
		<getInvites public="1" set="method" line="890">
			<f a="guild_id:?cb" v=":null">
				<c path="String"/>
				<f a=":">
					<c path="Array"><t path="com.raidandfade.haxicord.types.structs.Invite"/></c>
					<t path="com.raidandfade.haxicord.endpoints.ErrorReport"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Get a list of all invites in a guild. requires the MANAGE_GUILD permission.
        @param guild_id - The id to get the list from.
        @param cb - Returns an array of invites, or an error.</haxe_doc>
		</getInvites>
		<getInvite public="1" set="method" line="902">
			<f a="invite_code:?with_counts:?cb" v=":true:null">
				<c path="String"/>
				<x path="Bool"/>
				<f a=":">
					<t path="com.raidandfade.haxicord.types.structs.Invite"/>
					<t path="com.raidandfade.haxicord.endpoints.ErrorReport"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null, with_counts : true }</e></m></meta>
			<haxe_doc>Get information about an invite code.
        @param invite_code - The invite code.
        @param with_counts - Get some extra data from the invite's server
        @param cb - Returns an Invite object, or an error.</haxe_doc>
		</getInvite>
		<deleteInvite public="1" set="method" line="912">
			<f a="invite_code:?cb" v=":null">
				<c path="String"/>
				<f a=":">
					<t path="com.raidandfade.haxicord.types.structs.Invite"/>
					<t path="com.raidandfade.haxicord.endpoints.ErrorReport"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Delete an invite based on it's invite code. Requires the MANAGE_CHANNELS permission in the guild the invite is from.
        @param invite_code - The invite code of the invite to delete.
        @param cb - Returns the Invite that was removed, or an error.</haxe_doc>
		</deleteInvite>
		<acceptInvite public="1" set="method" line="923">
			<f a="invite_code:?cb" v=":null">
				<c path="String"/>
				<f a=":">
					<t path="com.raidandfade.haxicord.types.structs.Invite"/>
					<t path="com.raidandfade.haxicord.endpoints.ErrorReport"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>(NOT AVAILABLE FOR BOTS) Accept an invite code and join the server.
        @param invite_code - The invite code to join.
        @param cb - Returns the invite that was joined, or an error.</haxe_doc>
		</acceptInvite>
		<getUser public="1" set="method" line="935">
			<f a="?user_id:?cb" v="&quot;@me&quot;:null">
				<c path="String"/>
				<f a=":">
					<c path="com.raidandfade.haxicord.types.User"/>
					<t path="com.raidandfade.haxicord.endpoints.ErrorReport"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null, user_id : "@me" }</e></m></meta>
			<haxe_doc>Get a user based on their Id. 
        @param user_id - Get any user based on their id, or set to "@me" to return self.
        @param cb - Return the user object, or an error.</haxe_doc>
		</getUser>
		<editUser public="1" set="method" line="949">
			<f a="user_data:?cb" v=":null">
				<a>
					<username><c path="String"/></username>
					<avatar><c path="String"/></avatar>
				</a>
				<f a=":">
					<c path="com.raidandfade.haxicord.types.User"/>
					<t path="com.raidandfade.haxicord.endpoints.ErrorReport"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Edit the current user's settings.
        @param user_data - The parameters to change, all fields are optional.
        @param cb - Return the changed user, or an error.</haxe_doc>
		</editUser>
		<getGuilds public="1" set="method" line="963">
			<f a="filter:?cb" v=":null">
				<t path="com.raidandfade.haxicord.endpoints.GetGuildFilter"/>
				<f a=":">
					<c path="Array"><c path="com.raidandfade.haxicord.types.Guild"/></c>
					<t path="com.raidandfade.haxicord.endpoints.ErrorReport"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Get a list of all guilds that the current user is in. Normal users do not need to use the filter and can leave it blank `{}`
        @param filter - Filter the list depending on these parameters, Only one of BEFORE or AFTER can be specified.
        @param cb - Returns the list of Guilds according to the filter specified, or an error.</haxe_doc>
		</getGuilds>
		<leaveGuild public="1" set="method" line="980">
			<f a="guild_id:?cb" v=":null">
				<c path="String"/>
				<t path="com.raidandfade.haxicord.endpoints.EmptyResponseCallback"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Make the current user leave the specified guild.
        @param guild_id - The guild to leave.
        @param cb - Called on completion, useful for checking for errors.</haxe_doc>
		</leaveGuild>
		<getDMChannels public="1" set="method" line="989">
			<f a="?cb" v="null">
				<f a=":">
					<c path="Array"><c path="com.raidandfade.haxicord.types.DMChannel"/></c>
					<t path="com.raidandfade.haxicord.endpoints.ErrorReport"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Get the dm channels that the current user has open.
        @param cb - Returns an array of all dm channels the user currently has open, or an error.</haxe_doc>
		</getDMChannels>
		<createDM public="1" set="method" line="1006">
			<f a="data:?cb" v=":null">
				<a><recipient_id><c path="String"/></recipient_id></a>
				<f a=":">
					<c path="com.raidandfade.haxicord.types.DMChannel"/>
					<t path="com.raidandfade.haxicord.endpoints.ErrorReport"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Create a dm with another individual
        @param data - A struct that contains the recipient's id.
        @param cb - Returns the dm channel requested, or an error.</haxe_doc>
		</createDM>
		<createGroupDM public="1" set="method" line="1023">
			<f a="data:?cb" v=":null">
				<t path="com.raidandfade.haxicord.endpoints.CreateGroupDM"/>
				<f a=":">
					<c path="com.raidandfade.haxicord.types.DMChannel"/>
					<t path="com.raidandfade.haxicord.endpoints.ErrorReport"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Create a DM group. 
        @param data - A struct that contains the necessary arguments required to invite members.
        @param cb - Returns the group dm channel, or an error.</haxe_doc>
		</createGroupDM>
		<getConnections public="1" set="method" line="1039">
			<f a="?cb" v="null">
				<f a=":">
					<c path="Array"><t path="com.raidandfade.haxicord.types.structs.Connection"/></c>
					<t path="com.raidandfade.haxicord.endpoints.ErrorReport"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Get a list of connections hooked up to the current account.
        @param cb - Returns a list of connections, or an error.</haxe_doc>
		</getConnections>
		<listVoiceRegions public="1" set="method" line="1049">
			<f a="?cb" v="null">
				<f a=":">
					<c path="Array"><t path="com.raidandfade.haxicord.types.structs.VoiceRegion"/></c>
					<t path="com.raidandfade.haxicord.endpoints.ErrorReport"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Get a list of voice regions.
        @param cb - Returns a list of voice regions, or an error.</haxe_doc>
		</listVoiceRegions>
		<createWebhook public="1" set="method" line="1066">
			<f a="channel_id:data:?cb" v="::null">
				<c path="String"/>
				<a>
					<name><c path="String"/></name>
					<avatar><c path="String"/></avatar>
				</a>
				<f a=":">
					<t path="com.raidandfade.haxicord.types.structs.Webhook"/>
					<t path="com.raidandfade.haxicord.endpoints.ErrorReport"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Create a webhook for a given channel based on the given data.
        @param channel_id - The channel to create for.
        @param data - The data to create with.
        @param cb - Returns the webhook object, or an error.</haxe_doc>
		</createWebhook>
		<getChannelWebhooks public="1" set="method" line="1076">
			<f a="channel_id:?cb" v=":null">
				<c path="String"/>
				<f a=":">
					<c path="Array"><t path="com.raidandfade.haxicord.types.structs.Webhook"/></c>
					<t path="com.raidandfade.haxicord.endpoints.ErrorReport"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Get all webhooks for a given channel. Requires the MANAGE_WEBHOOKS permission.
        @param channel_id - The channel id to get webhooks about.
        @param cb - Returns an array of webhooks, or an error.</haxe_doc>
		</getChannelWebhooks>
		<getGuildWebhooks public="1" set="method" line="1086">
			<f a="guild_id:?cb" v=":null">
				<c path="String"/>
				<f a=":">
					<c path="Array"><t path="com.raidandfade.haxicord.types.structs.Webhook"/></c>
					<t path="com.raidandfade.haxicord.endpoints.ErrorReport"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Get all webhooks for a given guild. Requires the MANAGE_WEBHOOKS permission.
        @param guild_id - The guild id to get webhooks about.
        @param cb - Returns an array of webhooks, or an error.</haxe_doc>
		</getGuildWebhooks>
		<getWebhook public="1" set="method" line="1096">
			<f a="webhook_id:?cb" v=":null">
				<c path="String"/>
				<f a=":">
					<t path="com.raidandfade.haxicord.types.structs.Webhook"/>
					<t path="com.raidandfade.haxicord.endpoints.ErrorReport"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Get a webhook based on it's id. Requires the MANAGE_WEBHOOKS permission in the guild/channel that the webhook is part of.
        @param webhook_id - The id of the webhook.
        @param cb - Returns a webhook object, or an error.</haxe_doc>
		</getWebhook>
		<editWebhook public="1" set="method" line="1107">
			<f a="webhook_id:data:?cb" v="::null">
				<c path="String"/>
				<a>
					<name>
						<t path="Null"><c path="String"/></t>
						<meta><m n=":optional"/></meta>
					</name>
					<avatar>
						<t path="Null"><c path="String"/></t>
						<meta><m n=":optional"/></meta>
					</avatar>
				</a>
				<f a=":">
					<t path="com.raidandfade.haxicord.types.structs.Webhook"/>
					<t path="com.raidandfade.haxicord.endpoints.ErrorReport"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Edit a webhook based on it's id. Requires the MANAGE_WEBHOOKS permission in the guild/channel that the webhook is part of.
        @param webhook_id - The id of the webhook to change.
        @param data - The updated data for the webhook. All parameters are optional.
        @param cb - Returns a webhook object, or an error.</haxe_doc>
		</editWebhook>
		<deleteWebhook public="1" set="method" line="1117">
			<f a="webhook_id:?cb" v=":null">
				<c path="String"/>
				<t path="com.raidandfade.haxicord.endpoints.EmptyResponseCallback"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Delete a webhook based on it's id. Requires the MANAGE_WEBHOOKS permission in the guild/channel that the webhook is part of.
        @param webhook_id - The id of the webhook to delete.
        @param cb - Called on completion, useful for checking for errors.</haxe_doc>
		</deleteWebhook>
		<getWebhookWithToken public="1" set="method" line="1128">
			<f a="webhook_id:webhook_token:?cb" v="::null">
				<c path="String"/>
				<c path="String"/>
				<f a=":">
					<t path="com.raidandfade.haxicord.types.structs.Webhook"/>
					<t path="com.raidandfade.haxicord.endpoints.ErrorReport"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Get a webhook using it's id and token. 
        @param webhook_id - The webhook's id.
        @param webhook_token - The webhook's token.
        @param cb - Returns a webhook object, or an error.</haxe_doc>
		</getWebhookWithToken>
		<editWebhookWithToken public="1" set="method" line="1140">
			<f a="webhook_id:webhook_token:data:?cb" v=":::null">
				<c path="String"/>
				<c path="String"/>
				<a>
					<name>
						<t path="Null"><c path="String"/></t>
						<meta><m n=":optional"/></meta>
					</name>
					<avatar>
						<t path="Null"><c path="String"/></t>
						<meta><m n=":optional"/></meta>
					</avatar>
				</a>
				<f a=":">
					<t path="com.raidandfade.haxicord.types.structs.Webhook"/>
					<t path="com.raidandfade.haxicord.endpoints.ErrorReport"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Edit a webhook using it's id and token
        @param webhook_id - The webhook's id.
        @param webhook_token - The webhook's token.
        @param data - The updated data for the webhook. All parameters are optional.
        @param cb - Returns a webhook object, or an error.</haxe_doc>
		</editWebhookWithToken>
		<deleteWebhookWithToken public="1" set="method" line="1151">
			<f a="webhook_id:webhook_token:?cb" v="::null">
				<c path="String"/>
				<c path="String"/>
				<t path="com.raidandfade.haxicord.endpoints.EmptyResponseCallback"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Delete a webhook based on it's id and token.
        @param webhook_id - The id of the webhook to delete.
        @param webhook_token - The webhook's token.
        @param cb - Called on completion, useful for checking for errors.</haxe_doc>
		</deleteWebhookWithToken>
		<executeWebhook public="1" set="method" line="1164">
			<f a="webhook_id:webhook_token:data:?wait:?cb" v=":::false:null">
				<c path="String"/>
				<c path="String"/>
				<t path="com.raidandfade.haxicord.endpoints.WebhookMessage"/>
				<x path="Bool"/>
				<t path="com.raidandfade.haxicord.endpoints.EmptyResponseCallback"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null, wait : false }</e></m></meta>
			<haxe_doc>Execute a given webhook and send a message.
        @param webhook_id - The id of the webhook.
        @param webhook_token - The token of the webhook.
        @param data - The message data to send.
        @param wait - Whether or not the request should wait until the message is successfully sent.
        @param cb - Called on completion, useful for checking for errors.</haxe_doc>
		</executeWebhook>
		<globalQueue expr="new Array&lt;EndpointCall&gt;()">
			<c path="Array"><c path="com.raidandfade.haxicord.endpoints.EndpointCall"/></c>
			<meta>
				<m n=":value"><e><![CDATA[new Array<EndpointCall>()]]></e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</globalQueue>
		<globalTimer>
			<x path="Bool"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</globalTimer>
		<callEndpoint public="1" set="method" line="1184">
			<f a="method:endpoint:?callback:?data:?authorized" v="::null:null:true">
				<c path="String"/>
				<c path="com.raidandfade.haxicord.endpoints.EndpointPath"/>
				<f a=":">
					<d/>
					<t path="com.raidandfade.haxicord.endpoints.ErrorReport"/>
					<x path="Void"/>
				</f>
				<a/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ authorized : true, data : null, callback : null }</e></m></meta>
			<haxe_doc>Call an endpoint while respecting ratelimits and such. Only use this if the endpoint call is not a function of its own (and make an issue on the github if that is the case)
        @param method - The HTTP method to use.
        @param endpoint - The method url (not including the discord api part).
        @param callback - The function to callback to.
        @param data - Any extra data to send along (as POST body).
        @param authorized - Whether the endpoint requires a token or not.</haxe_doc>
		</callEndpoint>
		<rawCallEndpoint public="1" set="method" line="1289">
			<f a="method:endpoint:?callback:?data:?authorized" v="::null:null:true">
				<c path="String"/>
				<c path="String"/>
				<f a=":">
					<d/>
					<x path="Map">
						<c path="String"/>
						<c path="String"/>
					</x>
					<x path="Void"/>
				</f>
				<a/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ authorized : true, data : null, callback : null }</e></m></meta>
			<haxe_doc>Call an endpoint directly, no ratelimits no nothin.
        @param method - The HTTP method to use.
        @param endpoint - The method url (not including the discord api part).
        @param callback - The function to callback to.
        @param data - Any extra data to send along (as POST body).
        @param authorized - Whether the endpoint requires a token or not.</haxe_doc>
		</rawCallEndpoint>
		<new public="1" set="method" line="40">
			<f a="_c">
				<c path="com.raidandfade.haxicord.DiscordClient"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="com.raidandfade.haxicord.endpoints.RateLimit" params="" file="src/com/raidandfade/haxicord/endpoints/Endpoints.hx" module="com.raidandfade.haxicord.endpoints.Endpoints">
		<limit public="1"><x path="Int"/></limit>
		<remaining public="1"><x path="Int"/></remaining>
		<reset public="1"><x path="Float"/></reset>
		<toString public="1" set="method" line="1328"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="1322"><f a="_l:_rm:_rs">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
		</meta>
	</class>
	<class path="com.raidandfade.haxicord.endpoints.EndpointCall" params="" file="src/com/raidandfade/haxicord/endpoints/Endpoints.hx" module="com.raidandfade.haxicord.endpoints.Endpoints">
		<method public="1"><c path="String"/></method>
		<endpoint public="1"><c path="com.raidandfade.haxicord.endpoints.EndpointPath"/></endpoint>
		<callback public="1"><t path="Null"><f a=":">
	<d/>
	<c path="String"/>
	<x path="Void"/>
</f></t></callback>
		<data public="1"><a/></data>
		<authorized public="1"><x path="Bool"/></authorized>
		<new public="1" set="method" line="1340">
			<f a="_m:_e:?_c:?_d:?_a" v="::null:null:true">
				<c path="String"/>
				<c path="com.raidandfade.haxicord.endpoints.EndpointPath"/>
				<f a=":">
					<d/>
					<c path="String"/>
					<x path="Void"/>
				</f>
				<a/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ _a : true, _d : null, _c : null }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
		</meta>
	</class>
	<class path="com.raidandfade.haxicord.endpoints.EndpointPath" params="" file="src/com/raidandfade/haxicord/endpoints/Endpoints.hx" module="com.raidandfade.haxicord.endpoints.Endpoints">
		<endpoint public="1"><c path="String"/></endpoint>
		<data public="1"><c path="Array"><c path="String"/></c></data>
		<getRoute public="1" set="method" line="1354"><f a=""><c path="String"/></f></getRoute>
		<getPath public="1" set="method" line="1361"><f a=""><c path="String"/></f></getPath>
		<new public="1" set="method" line="1349"><f a="_e:_d">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
		</meta>
	</class>
	<typedef path="com.raidandfade.haxicord.endpoints.ErrorReport" params="" file="src/com/raidandfade/haxicord/endpoints/Endpoints.hx" module="com.raidandfade.haxicord.endpoints.Endpoints">
		<d/>
		<meta><m n=":dox"><e>hide</e></m></meta>
	</typedef>
	<typedef path="com.raidandfade.haxicord.endpoints.EmptyResponseCallback" params="" file="src/com/raidandfade/haxicord/endpoints/Endpoints.hx" module="com.raidandfade.haxicord.endpoints.Endpoints">
		<f a=":">
			<d/>
			<t path="com.raidandfade.haxicord.endpoints.ErrorReport"/>
			<x path="Void"/>
		</f>
		<meta><m n=":dox"><e>hide</e></m></meta>
	</typedef>
	<typedef path="com.raidandfade.haxicord.endpoints.Gateway" params="" file="src/com/raidandfade/haxicord/endpoints/Typedefs.hx" module="com.raidandfade.haxicord.endpoints.Typedefs"><a>
	<url>
		<c path="String"/>
		<haxe_doc>The url that is suggested.</haxe_doc>
	</url>
	<shards>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
		<haxe_doc>The number of shards suggested (will only be there for bots)</haxe_doc>
	</shards>
</a></typedef>
	<typedef path="com.raidandfade.haxicord.endpoints.MessagesRequest" params="" file="src/com/raidandfade/haxicord/endpoints/Typedefs.hx" module="com.raidandfade.haxicord.endpoints.Typedefs"><a>
	<limit>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
		<haxe_doc>*  Max number of messages to return, (1-100 default 50)</haxe_doc>
	</limit>
	<before>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
		<haxe_doc>Get messages before this ID</haxe_doc>
	</before>
	<around>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
		<haxe_doc>Get messages around this ID</haxe_doc>
	</around>
	<after>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
		<haxe_doc>Get messages after this ID</haxe_doc>
	</after>
</a></typedef>
	<typedef path="com.raidandfade.haxicord.endpoints.MessageEdit" params="" file="src/com/raidandfade/haxicord/endpoints/Typedefs.hx" module="com.raidandfade.haxicord.endpoints.Typedefs"><a>
	<embed>
		<t path="Null"><t path="com.raidandfade.haxicord.types.structs.Embed"/></t>
		<meta><m n=":optional"/></meta>
		<haxe_doc>Rich embed content.</haxe_doc>
	</embed>
	<content>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
		<haxe_doc>The new message contents (up to 2000 characters)</haxe_doc>
	</content>
</a></typedef>
	<typedef path="com.raidandfade.haxicord.endpoints.MessageCreate" params="" file="src/com/raidandfade/haxicord/endpoints/Typedefs.hx" module="com.raidandfade.haxicord.endpoints.Typedefs"><a>
	<tts>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
		<haxe_doc>Whether the message is TTS or not.</haxe_doc>
	</tts>
	<nonce>
		<t path="Null"><c path="com.raidandfade.haxicord.types.Snowflake"/></t>
		<meta><m n=":optional"/></meta>
		<haxe_doc>You really don't need this. This will be returned on the new message object.</haxe_doc>
	</nonce>
	<file>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</file>
	<embed>
		<t path="Null"><t path="com.raidandfade.haxicord.types.structs.Embed"/></t>
		<meta><m n=":optional"/></meta>
		<haxe_doc>A rich embed.</haxe_doc>
	</embed>
	<content>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
		<haxe_doc>The message content (Up to 2000 characters)</haxe_doc>
	</content>
</a></typedef>
	<typedef path="com.raidandfade.haxicord.endpoints.MessageBulkDelete" params="" file="src/com/raidandfade/haxicord/endpoints/Typedefs.hx" module="com.raidandfade.haxicord.endpoints.Typedefs"><a><messages><c path="Array"><c path="String"/></c></messages></a></typedef>
	<typedef path="com.raidandfade.haxicord.endpoints.ChannelCreate" params="" file="src/com/raidandfade/haxicord/endpoints/Typedefs.hx" module="com.raidandfade.haxicord.endpoints.Typedefs"><a>
	<user_limit>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
		<haxe_doc>User limit (only for voice)</haxe_doc>
	</user_limit>
	<type>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
		<haxe_doc>The channel type ("voice" or "text")</haxe_doc>
	</type>
	<topic>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
		<haxe_doc>The channel topic. 0 to 1024 characters.</haxe_doc>
	</topic>
	<permission_overwrites>
		<t path="Null"><c path="Array"><t path="com.raidandfade.haxicord.types.structs.Overwrite"/></c></t>
		<meta><m n=":optional"/></meta>
		<haxe_doc>An array of overwrites to start the channel off with.</haxe_doc>
	</permission_overwrites>
	<parent_id>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
		<haxe_doc>The ID of the category to add the channel to</haxe_doc>
	</parent_id>
	<nsfw>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
		<haxe_doc>Whether the channel is NSFW or not</haxe_doc>
	</nsfw>
	<name>
		<c path="String"/>
		<haxe_doc>The name of the new channel, 2 to 100 characters.</haxe_doc>
	</name>
	<bitrate>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
		<haxe_doc>Bitrate (only for voice)</haxe_doc>
	</bitrate>
</a></typedef>
	<typedef path="com.raidandfade.haxicord.endpoints.ChannelUpdate" params="" file="src/com/raidandfade/haxicord/endpoints/Typedefs.hx" module="com.raidandfade.haxicord.endpoints.Typedefs"><a>
	<user_limit>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
		<haxe_doc>User limit (only for voice)</haxe_doc>
	</user_limit>
	<topic>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
		<haxe_doc>The channel topic. 0 to 1024 characters.</haxe_doc>
	</topic>
	<position>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
		<haxe_doc>the position of the channel in the left-hand listing</haxe_doc>
	</position>
	<permission_overwrites>
		<t path="Null"><c path="Array"><t path="com.raidandfade.haxicord.types.structs.Overwrite"/></c></t>
		<meta><m n=":optional"/></meta>
		<haxe_doc>An array of overwrites to start the channel off with.</haxe_doc>
	</permission_overwrites>
	<parent_id>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
		<haxe_doc>The ID of the category to add the channel to</haxe_doc>
	</parent_id>
	<nsfw>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
		<haxe_doc>Whether the channel is NSFW or not</haxe_doc>
	</nsfw>
	<name>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
		<haxe_doc>The new name of the channel, 2 to 100 characters.</haxe_doc>
	</name>
	<bitrate>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
		<haxe_doc>Bitrate (only for voice)</haxe_doc>
	</bitrate>
</a></typedef>
	<typedef path="com.raidandfade.haxicord.endpoints.GuildCreate" params="" file="src/com/raidandfade/haxicord/endpoints/Typedefs.hx" module="com.raidandfade.haxicord.endpoints.Typedefs"><a>
	<verification_level>
		<x path="Int"/>
		<haxe_doc>Guild verification level</haxe_doc>
	</verification_level>
	<roles>
		<c path="Array"><t path="com.raidandfade.haxicord.types.structs.Role"/></c>
		<haxe_doc>New guild roles.</haxe_doc>
	</roles>
	<region>
		<c path="String"/>
		<haxe_doc>Voice region to create the guild in.</haxe_doc>
	</region>
	<name>
		<c path="String"/>
		<haxe_doc>Name of the guild. (2-100 characters)</haxe_doc>
	</name>
	<icon>
		<c path="String"/>
		<haxe_doc>128x128 base64 image for the guild icon.</haxe_doc>
	</icon>
	<default_message_notifications>
		<x path="Int"/>
		<haxe_doc>Default message notifications setting</haxe_doc>
	</default_message_notifications>
	<channels>
		<c path="Array"><t path="com.raidandfade.haxicord.endpoints.ChannelCreate"/></c>
		<haxe_doc>New guild channels</haxe_doc>
	</channels>
</a></typedef>
	<typedef path="com.raidandfade.haxicord.endpoints.GuildUpdate" params="" file="src/com/raidandfade/haxicord/endpoints/Typedefs.hx" module="com.raidandfade.haxicord.endpoints.Typedefs"><a>
	<verification_level>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
		<haxe_doc>Guild verification level</haxe_doc>
	</verification_level>
	<splash>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
		<haxe_doc>Base64 128x128 jpeg image for the guild splash (VIP only)</haxe_doc>
	</splash>
	<region>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
		<haxe_doc>Voice region to create the guild in.</haxe_doc>
	</region>
	<owner_id>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
		<haxe_doc>An ID of a user to transfer ownership of the server to (Only works if the current user is owner)</haxe_doc>
	</owner_id>
	<name>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
		<haxe_doc>Name of the guild. (2-100 characters)</haxe_doc>
	</name>
	<icon>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
		<haxe_doc>128x128 base64 image for the guild icon.</haxe_doc>
	</icon>
	<default_message_notifications>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
		<haxe_doc>Default message notifications setting</haxe_doc>
	</default_message_notifications>
	<afk_timeout>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
		<haxe_doc>Number of seconds before a user is moved to the afk channel</haxe_doc>
	</afk_timeout>
	<afk_channel_id>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
		<haxe_doc>ID of the afk voice channel</haxe_doc>
	</afk_channel_id>
</a></typedef>
	<typedef path="com.raidandfade.haxicord.endpoints.PositionChange" params="" file="src/com/raidandfade/haxicord/endpoints/Typedefs.hx" module="com.raidandfade.haxicord.endpoints.Typedefs"><c path="Array"><t path="com.raidandfade.haxicord.endpoints.Position"/></c></typedef>
	<typedef path="com.raidandfade.haxicord.endpoints.Position" params="" file="src/com/raidandfade/haxicord/endpoints/Typedefs.hx" module="com.raidandfade.haxicord.endpoints.Typedefs"><a>
	<position>
		<x path="Int"/>
		<haxe_doc>The new position</haxe_doc>
	</position>
	<id>
		<c path="String"/>
		<haxe_doc>Id of the channel/role being moved</haxe_doc>
	</id>
</a></typedef>
	<typedef path="com.raidandfade.haxicord.endpoints.ListGuildMember" params="" file="src/com/raidandfade/haxicord/endpoints/Typedefs.hx" module="com.raidandfade.haxicord.endpoints.Typedefs"><a>
	<limit>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
		<haxe_doc>Max number of members to return (1 to 1000)</haxe_doc>
	</limit>
	<after>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
		<haxe_doc>Highest user id from the previous page.</haxe_doc>
	</after>
</a></typedef>
	<typedef path="com.raidandfade.haxicord.endpoints.AddGuildMember" params="" file="src/com/raidandfade/haxicord/endpoints/Typedefs.hx" module="com.raidandfade.haxicord.endpoints.Typedefs"><a>
	<roles>
		<t path="Null"><c path="Array"><c path="String"/></c></t>
		<meta><m n=":optional"/></meta>
		<haxe_doc>A list of role ids to assign to the user.
        Requires MANAGE_ROLES</haxe_doc>
	</roles>
	<nick>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
		<haxe_doc>A nickname to set for the user
        Requires MANAGE_NICKNAMES</haxe_doc>
	</nick>
	<mute>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
		<haxe_doc>Start the user off muted
        Requires MUTE_MEMBERS</haxe_doc>
	</mute>
	<deaf>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
		<haxe_doc>Start the user off deafened
        Requires DEAFEN_MEMBERS</haxe_doc>
	</deaf>
	<access_token>
		<c path="String"/>
		<haxe_doc>The Oauth2 access token granted through an oauth link with the `guilds.join` scope.</haxe_doc>
	</access_token>
</a></typedef>
	<typedef path="com.raidandfade.haxicord.endpoints.EditGuildMember" params="" file="src/com/raidandfade/haxicord/endpoints/Typedefs.hx" module="com.raidandfade.haxicord.endpoints.Typedefs"><a>
	<roles>
		<t path="Null"><c path="Array"><c path="String"/></c></t>
		<meta><m n=":optional"/></meta>
		<haxe_doc>A list of role ids to assign to the user.
        Requires MANAGE_ROLES</haxe_doc>
	</roles>
	<nick>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
		<haxe_doc>A nickname to set for the user
        Requires MANAGE_NICKNAMES</haxe_doc>
	</nick>
	<mute>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
		<haxe_doc>Start the user off muted
        Requires MUTE_MEMBERS</haxe_doc>
	</mute>
	<deaf>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
		<haxe_doc>Start the user off deafened
        Requires DEAFEN_MEMBERS</haxe_doc>
	</deaf>
	<channel_id>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
		<haxe_doc>Move the member to a different voice channel.
        Only works if the user is connected to voice.
        Requires MOVE_MEMBERS</haxe_doc>
	</channel_id>
</a></typedef>
	<typedef path="com.raidandfade.haxicord.endpoints.RoleInfo" params="" file="src/com/raidandfade/haxicord/endpoints/Typedefs.hx" module="com.raidandfade.haxicord.endpoints.Typedefs"><a>
	<permissions>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
		<haxe_doc>The permissions bitwise int. (Default : Same as @everyone role)</haxe_doc>
	</permissions>
	<name>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
		<haxe_doc>The name of the role (Default : "new role")</haxe_doc>
	</name>
	<mentionable>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
		<haxe_doc>Should the role be mentionable? (Default : False)</haxe_doc>
	</mentionable>
	<hoist>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
		<haxe_doc>Should the role be displayed separately? (Default : False)</haxe_doc>
	</hoist>
	<color>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
		<haxe_doc>The RGB color value. (Default : none)</haxe_doc>
	</color>
</a></typedef>
	<typedef path="com.raidandfade.haxicord.endpoints.InviteCreate" params="" file="src/com/raidandfade/haxicord/endpoints/Typedefs.hx" module="com.raidandfade.haxicord.endpoints.Typedefs"><a>
	<unique>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
		<haxe_doc>If true, don't try to reuse a similar invite (useful for creating many unique one time use invites) (Default False)</haxe_doc>
	</unique>
	<temporary>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
		<haxe_doc>Whether this invite only grants temporary membership (Default False)</haxe_doc>
	</temporary>
	<max_uses>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
		<haxe_doc>Max number of uses or 0 for unlimited (Default 0)</haxe_doc>
	</max_uses>
	<max_age>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
		<haxe_doc>Duration of invite in seconds before expiry, or 0 for never (Default 86400 (or 24h))</haxe_doc>
	</max_age>
</a></typedef>
	<typedef path="com.raidandfade.haxicord.endpoints.GetGuildFilter" params="" file="src/com/raidandfade/haxicord/endpoints/Typedefs.hx" module="com.raidandfade.haxicord.endpoints.Typedefs"><a>
	<limit>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
		<haxe_doc>Max number of guilds to return (1 to 100, Default 100)</haxe_doc>
	</limit>
	<before>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
		<haxe_doc>Get guilds before this guild ID</haxe_doc>
	</before>
	<after>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
		<haxe_doc>Get guilds after this guild ID</haxe_doc>
	</after>
</a></typedef>
	<typedef path="com.raidandfade.haxicord.endpoints.IntegrationCreate" params="" file="src/com/raidandfade/haxicord/endpoints/Typedefs.hx" module="com.raidandfade.haxicord.endpoints.Typedefs"><a>
	<type>
		<c path="String"/>
		<haxe_doc>The integration type.</haxe_doc>
	</type>
	<id>
		<c path="String"/>
		<haxe_doc>The integration id.</haxe_doc>
	</id>
</a></typedef>
	<typedef path="com.raidandfade.haxicord.endpoints.IntegrationModify" params="" file="src/com/raidandfade/haxicord/endpoints/Typedefs.hx" module="com.raidandfade.haxicord.endpoints.Typedefs"><a>
	<expire_grace_period>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
		<haxe_doc>Period (in seconds) where the integration will ignore lapsed subscriptions</haxe_doc>
	</expire_grace_period>
	<expire_behavior>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
		<haxe_doc>The behavior when an integration subscription lapses</haxe_doc>
	</expire_behavior>
	<enable_emoticons>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
		<haxe_doc>Whether emoticons should be synced for this integration (twitch only currently)</haxe_doc>
	</enable_emoticons>
</a></typedef>
	<typedef path="com.raidandfade.haxicord.endpoints.CreateGroupDM" params="" file="src/com/raidandfade/haxicord/endpoints/Typedefs.hx" module="com.raidandfade.haxicord.endpoints.Typedefs"><a>
	<nicks>
		<x path="Map">
			<c path="String"/>
			<c path="String"/>
		</x>
		<haxe_doc>A dictionary of user ids to their respective nicknames</haxe_doc>
	</nicks>
	<access_tokens>
		<c path="Array"><c path="String"/></c>
		<haxe_doc>Access tokens of users that have granted your app the `gdm.join` scope</haxe_doc>
	</access_tokens>
</a></typedef>
	<typedef path="com.raidandfade.haxicord.endpoints.WebhookMessage" params="" file="src/com/raidandfade/haxicord/endpoints/Typedefs.hx" module="com.raidandfade.haxicord.endpoints.Typedefs"><a>
	<username>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
		<haxe_doc>Override the default username of the webhook</haxe_doc>
	</username>
	<tts>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
		<haxe_doc>True if this is a TTS message</haxe_doc>
	</tts>
	<file>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
		<haxe_doc>The contents of the file being sent
        Every webhook requires at least one of either content, file, or embeds.</haxe_doc>
	</file>
	<embeds>
		<t path="Null"><c path="Array"><t path="com.raidandfade.haxicord.types.structs.Embed"/></c></t>
		<meta><m n=":optional"/></meta>
		<haxe_doc>Embedded rich content
        Every webhook requires at least one of either content, file, or embeds.</haxe_doc>
	</embeds>
	<content>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
		<haxe_doc>The message contents (up to 2000 characters)
        Every webhook requires at least one of either content, file, or embeds.</haxe_doc>
	</content>
	<avatar_url>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
		<haxe_doc>Override the default avatar of the webhook</haxe_doc>
	</avatar_url>
</a></typedef>
	<typedef path="com.raidandfade.haxicord.endpoints.AuditLogFilter" params="" file="src/com/raidandfade/haxicord/endpoints/Typedefs.hx" module="com.raidandfade.haxicord.endpoints.Typedefs"><a>
	<user_id>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
		<haxe_doc>Filter the log for a user id</haxe_doc>
	</user_id>
	<limit>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
		<haxe_doc>How many entries are returned (default 50, minimum 1, maximum 100)</haxe_doc>
	</limit>
	<before>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
		<haxe_doc>Filter the log before a certain entry id</haxe_doc>
	</before>
	<action_type>
		<t path="Null"><x path="com.raidandfade.haxicord.types.structs.AuditLogEvent"/></t>
		<meta><m n=":optional"/></meta>
		<haxe_doc>The type of audit log event</haxe_doc>
	</action_type>
</a></typedef>
	<class path="com.raidandfade.haxicord.logger.Logger" params="" file="src/com/raidandfade/haxicord/logger/Logger.hx">
		<outPrefix expr="&quot;[%c{Green}%t%c{Reset}] %c{lightblue}%cn%c{Reset}-&gt;%c{LightBlue}%fn()%c{Reset}:%c{LightRed}%l%c{Reset}: &quot;" line="9" static="1">
			<c path="String"/>
			<meta><m n=":value"><e><![CDATA["[%c{Green}%t%c{Reset}] %c{lightblue}%cn%c{Reset}->%c{LightBlue}%fn()%c{Reset}:%c{LightRed}%l%c{Reset}: "]]></e></m></meta>
		</outPrefix>
		<origTrace static="1"><d/></origTrace>
		<registerLogger public="1" set="method" line="16" static="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Register the logger as your official logger.</haxe_doc>
		</registerLogger>
		<unregisterLogger public="1" set="method" line="27" static="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Use this when you regret having a good logger you filthy black and white terminal person.</haxe_doc>
		</unregisterLogger>
		<getReplaceColor public="1" set="method" line="31" static="1"><f a="col">
	<c path="String"/>
	<c path="String"/>
</f></getReplaceColor>
		<hxTrace public="1" set="method" line="46" static="1"><f a="v:?infos">
	<d/>
	<t path="haxe.PosInfos"/>
	<x path="Void"/>
</f></hxTrace>
		<out public="1" set="method" line="135" static="1"><f a="s">
	<c path="String"/>
	<x path="Void"/>
</f></out>
		<err public="1" set="method" line="145" static="1"><f a="s">
	<c path="String"/>
	<x path="Void"/>
</f></err>
		<haxe_doc>A logger that actually looks good. Use this please. The `no_colors` compile flag will remove colors from the prefix format.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="com.raidandfade.haxicord.types.Channel" params="" file="src/com/raidandfade/haxicord/types/Channel.hx">
		<fromStruct public="1" set="method" line="24" static="1">
			<f a="_chan">
				<t path="com.raidandfade.haxicord.types.structs.Channel"/>
				<f a=":">
					<d/>
					<c path="com.raidandfade.haxicord.DiscordClient"/>
					<c path="com.raidandfade.haxicord.types.Channel"/>
				</f>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</fromStruct>
		<client public="1">
			<c path="com.raidandfade.haxicord.DiscordClient"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</client>
		<type public="1">
			<x path="Int"/>
			<haxe_doc>The type of the channel
        0 = Guild Text Channel
        1 = DM Channel
        2 = Guild Voice Channel
        3 = Group DM
        4 = Category Channel</haxe_doc>
		</type>
		<id public="1">
			<c path="com.raidandfade.haxicord.types.Snowflake"/>
			<haxe_doc>The ID of the channel.</haxe_doc>
		</id>
		<getTag public="1" set="method" line="35">
			<f a=""><c path="String"/></f>
			<haxe_doc>Get the tag for the channel as a string.</haxe_doc>
		</getTag>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="com.raidandfade.haxicord.types.GuildChannel" params="" file="src/com/raidandfade/haxicord/types/GuildChannel.hx">
		<extends path="com.raidandfade.haxicord.types.Channel"/>
		<fromStruct public="1" set="method" line="41" static="1">
			<f a="_chan">
				<a><type set="null"><x path="Int"/></type></a>
				<f a=":">
					<d/>
					<c path="com.raidandfade.haxicord.DiscordClient"/>
					<c path="com.raidandfade.haxicord.types.GuildChannel"/>
				</f>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</fromStruct>
		<guild_id public="1">
			<c path="com.raidandfade.haxicord.types.Snowflake"/>
			<haxe_doc>The ID of the guild this is part of.</haxe_doc>
		</guild_id>
		<name public="1">
			<c path="String"/>
			<haxe_doc>The name of this channel</haxe_doc>
		</name>
		<parent_id public="1">
			<c path="com.raidandfade.haxicord.types.Snowflake"/>
			<haxe_doc>The ID of the category this is under (Or null)</haxe_doc>
		</parent_id>
		<nsfw public="1">
			<x path="Bool"/>
			<haxe_doc>Is this channel nsfw?</haxe_doc>
		</nsfw>
		<position public="1">
			<x path="Int"/>
			<haxe_doc>The position of this channel.</haxe_doc>
		</position>
		<permission_overwrites public="1">
			<c path="Array"><t path="com.raidandfade.haxicord.types.structs.Overwrite"/></c>
			<haxe_doc>A list of this channel's permission overwrites</haxe_doc>
		</permission_overwrites>
		<getGuild public="1" set="method" line="36">
			<f a=""><t path="Null"><c path="com.raidandfade.haxicord.types.Guild"/></t></f>
			<haxe_doc>Get the guild object that this channel is a part of. If this returns null or throws an error something has seriously gone wrong.</haxe_doc>
		</getGuild>
		<getInvites public="1" set="method" line="60">
			<f a="?cb" v="null">
				<f a=":">
					<c path="Array"><t path="com.raidandfade.haxicord.types.structs.Invite"/></c>
					<t path="com.raidandfade.haxicord.endpoints.ErrorReport"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Get the invites of a given channel
        @param cb - Array of Invites (or error).</haxe_doc>
		</getInvites>
		<createInvite public="1" set="method" line="68">
			<f a="invite_data:?cb" v=":null">
				<t path="com.raidandfade.haxicord.endpoints.InviteCreate"/>
				<t path="com.raidandfade.haxicord.endpoints.EmptyResponseCallback"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Create a new invite for a given channel
        @param invite_data - The invite data.
        @param cb - Return the invite or an error.</haxe_doc>
		</createInvite>
		<editChannel public="1" set="method" line="76">
			<f a="cd:?cb" v=":null">
				<t path="com.raidandfade.haxicord.endpoints.ChannelUpdate"/>
				<f a=":">
					<c path="com.raidandfade.haxicord.types.Channel"/>
					<t path="com.raidandfade.haxicord.endpoints.ErrorReport"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Change a channel's parameters
        @param cd - The changed channel data, all fields are optional
        @param cb - Callback to send the new channel object to. Or null if result is not desired.</haxe_doc>
		</editChannel>
		<deleteChannel public="1" set="method" line="83">
			<f a="?cb" v="null">
				<f a=":">
					<c path="com.raidandfade.haxicord.types.Channel"/>
					<t path="com.raidandfade.haxicord.endpoints.ErrorReport"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Delete the given channel.
        @param cb - Callback to send old channel to. Or null if result is not desired.</haxe_doc>
		</deleteChannel>
		<editPermission public="1" set="method" line="92">
			<f a="perm:pid:?cb" v="::null">
				<t path="com.raidandfade.haxicord.types.structs.Overwrite"/>
				<c path="String"/>
				<t path="com.raidandfade.haxicord.endpoints.EmptyResponseCallback"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Edit or Create a channel's overwrite permissions;
        @param perm - The modified overwrite permission object
        @param pid - The overwrite Id, Id of user or role.
        @param cb - Call once finished.</haxe_doc>
		</editPermission>
		<deletePermission public="1" set="method" line="100">
			<f a="pid:?cb" v=":null">
				<c path="String"/>
				<t path="com.raidandfade.haxicord.endpoints.EmptyResponseCallback"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Delete a channel override
        @param pid - The overwrite id to delete
        @param cb - Call once finished.</haxe_doc>
		</deletePermission>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="com.raidandfade.haxicord.types.CategoryChannel" params="" file="src/com/raidandfade/haxicord/types/CategoryChannel.hx">
		<extends path="com.raidandfade.haxicord.types.GuildChannel"/>
		<fromStruct public="1" set="method" line="27" static="1">
			<f a="_chan:_client">
				<t path="com.raidandfade.haxicord.types.structs.GuildChannel"/>
				<c path="com.raidandfade.haxicord.DiscordClient"/>
				<c path="com.raidandfade.haxicord.types.CategoryChannel"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</fromStruct>
		<_update public="1" set="method" line="19">
			<f a="_chan">
				<t path="com.raidandfade.haxicord.types.structs.GuildChannel"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_update>
		<new public="1" set="method" line="5">
			<f a="_chan:_client">
				<t path="com.raidandfade.haxicord.types.structs.GuildChannel"/>
				<c path="com.raidandfade.haxicord.DiscordClient"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="com.raidandfade.haxicord.types.MessageChannel" params="" file="src/com/raidandfade/haxicord/types/MessageChannel.hx" interface="1">
		<client public="1">
			<c path="com.raidandfade.haxicord.DiscordClient"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</client>
		<id public="1">
			<c path="com.raidandfade.haxicord.types.Snowflake"/>
			<haxe_doc>The ID of the channel.</haxe_doc>
		</id>
		<last_message_id public="1">
			<c path="com.raidandfade.haxicord.types.Snowflake"/>
			<haxe_doc>The id of the last Message that was sent in the chat.</haxe_doc>
		</last_message_id>
		<type public="1">
			<x path="Int"/>
			<haxe_doc>The type of the channel
        0 = Guild Text Channel
        1 = DM Channel
        2 = Guild Voice Channel
        3 = Group DM
        4 = Category Channel</haxe_doc>
		</type>
		<getTag public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Get the tag for the channel as a string.</haxe_doc>
		</getTag>
		<sendMessage public="1" set="method">
			<f a="mesg:?cb" v=":null">
				<t path="com.raidandfade.haxicord.endpoints.MessageCreate"/>
				<f a=":">
					<c path="com.raidandfade.haxicord.types.Message"/>
					<c path="String"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Send a message to a channel
        @param mesg - Message data
        @param cb - Return the message sent, or an error</haxe_doc>
		</sendMessage>
		<getMessage public="1" set="method">
			<f a="mid:?cb" v=":null">
				<c path="String"/>
				<f a=":">
					<c path="com.raidandfade.haxicord.types.Message"/>
					<c path="String"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Get a message in a channel
        @param mid - The message id
        @param cb - Return the message, or an error.</haxe_doc>
		</getMessage>
		<getMessages public="1" set="method">
			<f a="?format:?cb" v="null:null">
				<t path="com.raidandfade.haxicord.endpoints.MessagesRequest"/>
				<f a=":">
					<c path="Array"><c path="com.raidandfade.haxicord.types.Message"/></c>
					<c path="String"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null, format : null }</e></m></meta>
			<haxe_doc>Get messages from a given channel according to the given format.
        @param format - Before, After, or Around. 
        @param cb - The array of messages, or an error.</haxe_doc>
		</getMessages>
		<deleteMessage public="1" set="method">
			<f a="mids:?cb" v=":null">
				<c path="String"/>
				<f a=":">
					<d/>
					<c path="String"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Delete a given message. If the author is not the current user, the MANAGE_MESSAGES permission is required
        @param mid - The id of the message.
        @param cb - Return when complete.</haxe_doc>
		</deleteMessage>
		<deleteMessages public="1" set="method">
			<f a="mids:?cb" v=":null">
				<t path="com.raidandfade.haxicord.endpoints.MessageBulkDelete"/>
				<f a=":">
					<d/>
					<c path="String"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Delete a given messages. MANAGE_MESSAGES is required.
        @param ids - an array of id of the messages.
        @param cb - Return when complete.</haxe_doc>
		</deleteMessages>
		<startTyping public="1" set="method">
			<f a="?cb" v="null">
				<f a=":">
					<d/>
					<c path="String"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Send a typing event in the given channel. This lasts for 10 seconds or when a message is sent, whichever comes first.
        @param cb - Return when complete.</haxe_doc>
		</startTyping>
		<getPins public="1" set="method">
			<f a="?cb" v="null">
				<f a=":">
					<c path="Array"><c path="com.raidandfade.haxicord.types.Message"/></c>
					<c path="String"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Get the pins of a channel
        @param cb - Return an array of pins (or an error)</haxe_doc>
		</getPins>
		<pinMessage public="1" set="method">
			<f a="mid:?cb" v=":null">
				<c path="String"/>
				<f a=":">
					<d/>
					<c path="String"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Add a channel pin
        @param mid - The message id
        @param cb - Called once completed. Leave blank to ignore.</haxe_doc>
		</pinMessage>
		<unpinMessage public="1" set="method">
			<f a="mid:?cb" v=":null">
				<c path="String"/>
				<f a=":">
					<d/>
					<c path="String"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Delete a channel's pin
        @param mid - The pin id
        @param cb - Called once completed. Leave blank to ignore.</haxe_doc>
		</unpinMessage>
		<inGuild public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>Returns whether the channel is part of a guild or not. Always true for TextChannels. Always false for DMChannels</haxe_doc>
		</inGuild>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="com.raidandfade.haxicord.types.DMChannel" params="" file="src/com/raidandfade/haxicord/types/DMChannel.hx">
		<extends path="com.raidandfade.haxicord.types.Channel"/>
		<implements path="com.raidandfade.haxicord.types.MessageChannel"/>
		<fromStruct public="1" set="method" line="60" static="1">
			<f a="_chan:_client">
				<t path="com.raidandfade.haxicord.types.structs.DMChannel"/>
				<c path="com.raidandfade.haxicord.DiscordClient"/>
				<c path="com.raidandfade.haxicord.types.DMChannel"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</fromStruct>
		<recipient public="1">
			<c path="com.raidandfade.haxicord.types.User"/>
			<haxe_doc>The other person in the DM chat. Will be null for Group DMs</haxe_doc>
		</recipient>
		<recipients public="1">
			<c path="Array"><c path="com.raidandfade.haxicord.types.User"/></c>
			<haxe_doc>A list of all others in the dm channel.</haxe_doc>
		</recipients>
		<last_message_id public="1">
			<c path="com.raidandfade.haxicord.types.Snowflake"/>
			<haxe_doc>The id of the last Message that was sent in the chat.</haxe_doc>
		</last_message_id>
		<_update public="1" set="method" line="42">
			<f a="_chan">
				<t path="com.raidandfade.haxicord.types.structs.DMChannel"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_update>
		<inGuild public="1" set="method" line="68">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>Returns whether the channel is in a guild or not (Always false for DM channels)</haxe_doc>
		</inGuild>
		<sendMessage public="1" set="method" line="76">
			<f a="mesg:?cb" v=":null">
				<t path="com.raidandfade.haxicord.endpoints.MessageCreate"/>
				<f a=":">
					<c path="com.raidandfade.haxicord.types.Message"/>
					<t path="com.raidandfade.haxicord.endpoints.ErrorReport"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Send a message to a channel
        @param mesg - Message data
        @param cb - Return the message sent, or an error</haxe_doc>
		</sendMessage>
		<addMember public="1" set="method" line="86">
			<f a="user_id:access_token:nick:?cb" v=":::null">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<t path="com.raidandfade.haxicord.endpoints.EmptyResponseCallback"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Add a user to a group dm.
        @param user_id - The user to be added.
        @param access_token - An OAUTH2 token received from authenticating the user.
        @param nick - The nickname of the user.
        @param cb - Called once completed.</haxe_doc>
		</addMember>
		<kickMember public="1" set="method" line="94">
			<f a="user_id:?cb" v=":null">
				<c path="String"/>
				<t path="com.raidandfade.haxicord.endpoints.EmptyResponseCallback"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Remove a user from a group dm.
        @param user_id - The user to be removed
        @param cb - Called once completed, or errored</haxe_doc>
		</kickMember>
		<getMessages public="1" set="method" line="102">
			<f a="?format:?cb" v="null:null">
				<a/>
				<f a=":">
					<c path="Array"><c path="com.raidandfade.haxicord.types.Message"/></c>
					<t path="com.raidandfade.haxicord.endpoints.ErrorReport"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null, format : null }</e></m></meta>
			<haxe_doc>Get messages from a given channel according to the given format.
        @param format - Before, After, or Around. 
        @param cb - The array of messages, or an error.</haxe_doc>
		</getMessages>
		<getMessage public="1" set="method" line="111">
			<f a="mid:?cb" v=":null">
				<c path="String"/>
				<f a=":">
					<c path="com.raidandfade.haxicord.types.Message"/>
					<t path="com.raidandfade.haxicord.endpoints.ErrorReport"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Get a message in a channel
        @param mid - The message id
        @param cb - Return the message, or an error.</haxe_doc>
		</getMessage>
		<deleteMessage public="1" set="method" line="119">
			<f a="mid:?cb" v=":null">
				<c path="String"/>
				<t path="com.raidandfade.haxicord.endpoints.EmptyResponseCallback"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Delete a given message. If the author is not the current user, the MANAGE_MESSAGES permission is required
        @param mid - The id of the message.
        @param cb - Return when complete.</haxe_doc>
		</deleteMessage>
		<deleteMessages public="1" set="method" line="127">
			<f a="ids:?cb" v=":null">
				<t path="com.raidandfade.haxicord.endpoints.MessageBulkDelete"/>
				<t path="com.raidandfade.haxicord.endpoints.EmptyResponseCallback"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Delete a given messages. MANAGE_MESSAGES is required.
        @param ids - an array of id of the messages.
        @param cb - Return when complete.</haxe_doc>
		</deleteMessages>
		<startTyping public="1" set="method" line="134">
			<f a="?cb" v="null">
				<t path="com.raidandfade.haxicord.endpoints.EmptyResponseCallback"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Send a typing event in the given channel. This lasts for 10 seconds or when a message is sent, whichever comes first.
        @param cb - Return when complete.</haxe_doc>
		</startTyping>
		<getPins public="1" set="method" line="141">
			<f a="?cb" v="null">
				<f a=":">
					<c path="Array"><c path="com.raidandfade.haxicord.types.Message"/></c>
					<t path="com.raidandfade.haxicord.endpoints.ErrorReport"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Get the pins of a channel
        @param cb - Return an array of pins (or an error)</haxe_doc>
		</getPins>
		<pinMessage public="1" set="method" line="149">
			<f a="mid:?cb" v=":null">
				<c path="String"/>
				<t path="com.raidandfade.haxicord.endpoints.EmptyResponseCallback"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Add a channel pin
        @param mid - The message
        @param cb - Called once completed. Leave blank to ignore.</haxe_doc>
		</pinMessage>
		<unpinMessage public="1" set="method" line="157">
			<f a="mid:?cb" v=":null">
				<c path="String"/>
				<t path="com.raidandfade.haxicord.endpoints.EmptyResponseCallback"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Delete a channel's pin
        @param mid - The pin id
        @param cb - Called once completed. Leave blank to ignore.</haxe_doc>
		</unpinMessage>
		<new public="1" set="method" line="20">
			<f a="_chan:_client">
				<t path="com.raidandfade.haxicord.types.structs.DMChannel"/>
				<c path="com.raidandfade.haxicord.DiscordClient"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="com.raidandfade.haxicord.types.Guild" params="" file="src/com/raidandfade/haxicord/types/Guild.hx">
		<client><c path="com.raidandfade.haxicord.DiscordClient"/></client>
		<id public="1">
			<c path="com.raidandfade.haxicord.types.Snowflake"/>
			<haxe_doc>The guild Id</haxe_doc>
		</id>
		<name public="1">
			<c path="String"/>
			<haxe_doc>The guild Name (2-100 characters)</haxe_doc>
		</name>
		<icon public="1">
			<c path="String"/>
			<haxe_doc>The guild Icon hash</haxe_doc>
		</icon>
		<splash public="1">
			<c path="String"/>
			<haxe_doc>The guild Splash hash</haxe_doc>
		</splash>
		<owner_id public="1">
			<c path="com.raidandfade.haxicord.types.Snowflake"/>
			<haxe_doc>The guild owner's id</haxe_doc>
		</owner_id>
		<region public="1">
			<c path="String"/>
			<haxe_doc>The guild voice region id</haxe_doc>
		</region>
		<afk_channel_id public="1">
			<c path="com.raidandfade.haxicord.types.Snowflake"/>
			<haxe_doc>The guild's afk channel's id</haxe_doc>
		</afk_channel_id>
		<afk_timeout public="1">
			<x path="Int"/>
			<haxe_doc>The guild's afk timeout in seconds</haxe_doc>
		</afk_timeout>
		<embed_enabled public="1">
			<x path="Bool"/>
			<haxe_doc>Does the guild have widgets enabled?</haxe_doc>
		</embed_enabled>
		<embed_channel_id public="1">
			<c path="com.raidandfade.haxicord.types.Snowflake"/>
			<haxe_doc>The channel that is featured in the widget.</haxe_doc>
		</embed_channel_id>
		<verification_level public="1">
			<x path="Int"/>
			<haxe_doc>The level of verification required for the guild</haxe_doc>
		</verification_level>
		<default_message_notifications public="1">
			<x path="Int"/>
			<haxe_doc>The guild's default message notifications level</haxe_doc>
		</default_message_notifications>
		<explicit_content_filter public="1">
			<x path="Int"/>
			<haxe_doc>The guild's default explicit content filter</haxe_doc>
		</explicit_content_filter>
		<roles public="1" expr="new Map&lt;String,Role&gt;()">
			<x path="Map">
				<c path="String"/>
				<c path="com.raidandfade.haxicord.types.Role"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new Map<String,Role>()]]></e></m></meta>
			<haxe_doc>A dictionary of roles in the guild by Id</haxe_doc>
		</roles>
		<emojis public="1" expr="new Array&lt;Emoji&gt;()">
			<c path="Array"><t path="com.raidandfade.haxicord.types.structs.Emoji"/></c>
			<meta><m n=":value"><e><![CDATA[new Array<Emoji>()]]></e></m></meta>
			<haxe_doc>A list of emojis in the guild</haxe_doc>
		</emojis>
		<features public="1" expr="new Array&lt;String&gt;()">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e><![CDATA[new Array<String>()]]></e></m></meta>
			<haxe_doc>A list of enabled guild features</haxe_doc>
		</features>
		<mfa_level public="1">
			<x path="Int"/>
			<haxe_doc>The guild's required MFA level.</haxe_doc>
		</mfa_level>
		<joined_at public="1">
			<c path="Date"/>
			<haxe_doc>When the current user joined the guild.</haxe_doc>
		</joined_at>
		<large public="1">
			<x path="Bool"/>
			<haxe_doc>Is the guild classified by discord as "Large"?</haxe_doc>
		</large>
		<unavailable public="1">
			<x path="Bool"/>
			<haxe_doc>Is this guild unavailable? If so things are going wrong :(</haxe_doc>
		</unavailable>
		<member_count public="1">
			<x path="Int"/>
			<haxe_doc>The guild's member count</haxe_doc>
		</member_count>
		<members public="1" expr="new Map&lt;String,GuildMember&gt;()">
			<x path="Map">
				<c path="String"/>
				<c path="com.raidandfade.haxicord.types.GuildMember"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new Map<String,GuildMember>()]]></e></m></meta>
			<haxe_doc>A dictionary of members in the guild by Id</haxe_doc>
		</members>
		<textChannels public="1" expr="new Map&lt;String,TextChannel&gt;()">
			<x path="Map">
				<c path="String"/>
				<c path="com.raidandfade.haxicord.types.TextChannel"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new Map<String,TextChannel>()]]></e></m></meta>
			<haxe_doc>A dictionary of textChannels in the guild by Id</haxe_doc>
		</textChannels>
		<voiceChannels public="1" expr="new Map&lt;String,VoiceChannel&gt;()">
			<x path="Map">
				<c path="String"/>
				<c path="com.raidandfade.haxicord.types.VoiceChannel"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new Map<String,VoiceChannel>()]]></e></m></meta>
			<haxe_doc>A dictionary of voiceChannels in the guild by Id</haxe_doc>
		</voiceChannels>
		<categoryChannels public="1" expr="new Map&lt;String,CategoryChannel&gt;()">
			<x path="Map">
				<c path="String"/>
				<c path="com.raidandfade.haxicord.types.CategoryChannel"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new Map<String,CategoryChannel>()]]></e></m></meta>
			<haxe_doc>A dictionary of categoryChannels in the guild by Id</haxe_doc>
		</categoryChannels>
		<presences public="1">
			<c path="Array"><t path="com.raidandfade.haxicord.types.structs.Presence"/></c>
			<haxe_doc>An array of partial presence updates of users in the guild.</haxe_doc>
		</presences>
		<nextChancb public="1" expr="new Array&lt;GuildChannel&gt;()">
			<c path="Array"><f a="">
	<c path="com.raidandfade.haxicord.types.GuildChannel"/>
	<x path="Void"/>
</f></c>
			<meta>
				<m n=":value"><e><![CDATA[new Array<GuildChannel>()]]></e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</nextChancb>
		<bans public="1" expr="new Array&lt;User&gt;()">
			<c path="Array"><c path="com.raidandfade.haxicord.types.User"/></c>
			<meta><m n=":value"><e><![CDATA[new Array<User>()]]></e></m></meta>
			<haxe_doc>A list of banned users.</haxe_doc>
		</bans>
		<owner public="1">
			<c path="com.raidandfade.haxicord.types.GuildMember"/>
			<haxe_doc>The owner of the guild</haxe_doc>
		</owner>
		<_update public="1" set="method" line="180">
			<f a="_guild">
				<t path="com.raidandfade.haxicord.types.structs.Update"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_update>
		<_updateEmojis public="1" set="method" line="222">
			<f a="e">
				<c path="Array"><t path="com.raidandfade.haxicord.types.structs.Emoji"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_updateEmojis>
		<_addChannel public="1" set="method" line="227">
			<f a="c">
				<c path="com.raidandfade.haxicord.types.GuildChannel"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_addChannel>
		<_addBan public="1" set="method" line="238">
			<f a="user">
				<c path="com.raidandfade.haxicord.types.User"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_addBan>
		<_removeBan public="1" set="method" line="243">
			<f a="user">
				<c path="com.raidandfade.haxicord.types.User"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_removeBan>
		<_newMember public="1" set="method" line="248">
			<f a="memberStruct">
				<t path="com.raidandfade.haxicord.types.structs.GuildMember"/>
				<t path="Null"><c path="com.raidandfade.haxicord.types.GuildMember"/></t>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_newMember>
		<_newRole public="1" set="method" line="260">
			<f a="roleStruct">
				<t path="com.raidandfade.haxicord.types.structs.Role"/>
				<t path="Null"><c path="com.raidandfade.haxicord.types.Role"/></t>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_newRole>
		<getChannels public="1" set="method" line="275">
			<f a="?cb" v="null">
				<f a=":">
					<c path="Array"><c path="com.raidandfade.haxicord.types.Channel"/></c>
					<t path="com.raidandfade.haxicord.endpoints.ErrorReport"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Get the channels in a guild
        @param cb - Return an array of channel objects, or an error.</haxe_doc>
		</getChannels>
		<createChannel public="1" set="method" line="284">
			<f a="cs:?cb" v=":null">
				<t path="com.raidandfade.haxicord.endpoints.ChannelCreate"/>
				<f a=":">
					<c path="com.raidandfade.haxicord.types.GuildChannel"/>
					<c path="String"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Create a channel in a guild
        @param cs - The channel's starting data 
        @param cb - Callback to send the new channel object to. Or null if result is not desired.</haxe_doc>
		</createChannel>
		<getChannel public="1" set="method" line="298">
			<f a="cid:?cb" v=":null">
				<c path="String"/>
				<f a="">
					<c path="com.raidandfade.haxicord.types.Channel"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Get a channel based on a given channel id.
        @param channel_id - The channel id to get the channel from
        @param cb - Callback to send the receivied channel object to. Or null if result is not desired.</haxe_doc>
		</getChannel>
		<moveChannels public="1" set="method" line="302"><f a=""><x path="Void"/></f></moveChannels>
		<getInvites public="1" set="method" line="309">
			<f a="?cb" v="null">
				<f a=":">
					<c path="Array"><t path="com.raidandfade.haxicord.types.structs.Invite"/></c>
					<t path="com.raidandfade.haxicord.endpoints.ErrorReport"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Get a list of all invites in a guild. requires the MANAGE_GUILD permission.
        @param cb - Returns an array of invites, or an error.</haxe_doc>
		</getInvites>
		<getRoles public="1" set="method" line="316">
			<f a="?cb" v="null">
				<f a=":">
					<c path="Array"><c path="com.raidandfade.haxicord.types.Role"/></c>
					<t path="com.raidandfade.haxicord.endpoints.ErrorReport"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Get the roles of a guild. Requires the MANAGE_ROLES permission.
        @param cb - Returns an array of guilds, or an error.</haxe_doc>
		</getRoles>
		<createRole public="1" set="method" line="325">
			<f a="rs:?cb" v=":null">
				<t path="com.raidandfade.haxicord.endpoints.RoleInfo"/>
				<f a=":">
					<c path="com.raidandfade.haxicord.types.Role"/>
					<t path="com.raidandfade.haxicord.endpoints.ErrorReport"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Create a role. Requires the MANAGE_ROLES permission.
        @param rs - The role's data.
        @param cb - Returns the new role, or an error.</haxe_doc>
		</createRole>
		<moveRole public="1" set="method" line="329">
			<f a="rs:?cb" v=":null">
				<unknown/>
				<unknown/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
		</moveRole>
		<getMember public="1" set="method" line="338">
			<f a="mid:cb">
				<c path="String"/>
				<f a="">
					<c path="com.raidandfade.haxicord.types.GuildMember"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>Get a member of the guild.
        @param mid - The member's id.
        @param cb - Return a member instance of the user. Or an error.</haxe_doc>
		</getMember>
		<getMemberUnsafe public="1" set="method" line="349"><f a="id">
	<c path="String"/>
	<t path="Null"><c path="com.raidandfade.haxicord.types.GuildMember"/></t>
</f></getMemberUnsafe>
		<getAllMembers public="1" set="method" line="360">
			<f a="cb">
				<c path="List"><c path="com.raidandfade.haxicord.types.GuildMember"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>To be finished. Will return all members in one callback.</haxe_doc>
		</getAllMembers>
		<getMembers public="1" set="method" line="369">
			<f a="format:?cb" v=":null">
				<t path="com.raidandfade.haxicord.endpoints.ListGuildMember"/>
				<f a=":">
					<c path="Array"><c path="com.raidandfade.haxicord.types.GuildMember"/></c>
					<c path="String"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Get all members of a guild. 
        @param format - The limit, and after. both are optional. used for paginating.
        @param cb - The array of guild members. or an error.</haxe_doc>
		</getMembers>
		<addMember public="1" set="method" line="379">
			<f a="uid:mdata:?cb" v="::null">
				<c path="String"/>
				<t path="com.raidandfade.haxicord.endpoints.AddGuildMember"/>
				<f a=":">
					<c path="com.raidandfade.haxicord.types.GuildMember"/>
					<c path="String"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Add a guild member using a token received through Oauth2. 
        Requires the CREATE_INSTANT_INVITE permission along with various other permissions depending on `member_data` parameters
        @param uid - The id of the user
        @param mdata - The access token, along with other optional parameters.
        @param cb - The added guildmember. or an error.</haxe_doc>
		</addMember>
		<changeNickname public="1" set="method" line="388">
			<f a="s:?m:?cb" v=":null:null">
				<c path="String"/>
				<c path="com.raidandfade.haxicord.types.GuildMember"/>
				<f a=":">
					<c path="String"/>
					<t path="com.raidandfade.haxicord.endpoints.ErrorReport"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null, m : null }</e></m></meta>
			<haxe_doc>Change this user's nickname.
        @param s - The nickname to change to.
        @param cb - Returns the nickname, or an error.</haxe_doc>
		</changeNickname>
		<getBans public="1" set="method" line="399">
			<f a="?cb" v="null">
				<f a=":">
					<c path="Array"><c path="com.raidandfade.haxicord.types.User"/></c>
					<t path="com.raidandfade.haxicord.endpoints.ErrorReport"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>List all the bans in a guild. Requires the BAN_MEMBERS permission.
        @param cb - Returns an array of users, or an error.</haxe_doc>
		</getBans>
		<getPruneCount public="1" set="method" line="408">
			<f a="days:?cb" v=":null">
				<x path="Int"/>
				<f a=":">
					<x path="Int"/>
					<t path="com.raidandfade.haxicord.endpoints.ErrorReport"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Get the number of users that will be pruned if a prune was run. Requires the KICK_MEMBERS permission.
        @param days - The number of days to count prune for.
        @param cb - Returns the number of users that would be pruned on a real request, or an error.</haxe_doc>
		</getPruneCount>
		<getAuditLog public="1" set="method" line="417">
			<f a="?filter:?cb" v="null:null">
				<t path="com.raidandfade.haxicord.endpoints.AuditLogFilter"/>
				<f a=":">
					<t path="com.raidandfade.haxicord.types.structs.AuditLog"/>
					<t path="com.raidandfade.haxicord.endpoints.ErrorReport"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null, filter : null }</e></m></meta>
			<haxe_doc>Get a guild's audit logs
        @param filter - Filter audit logs by these parameters.
        @param cb - Returns the AuditLog object, or an error.</haxe_doc>
		</getAuditLog>
		<beginPrune public="1" set="method" line="425">
			<f a="days:?cb" v=":null">
				<x path="Int"/>
				<f a=":">
					<x path="Int"/>
					<t path="com.raidandfade.haxicord.endpoints.ErrorReport"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Prune the members of a server. Requires the KICK_MEMBERS permission
        @param days - The number of days to count prune for.
        @param cb - Returns the number of users that were pruned, or an error.</haxe_doc>
		</beginPrune>
		<getVoiceRegions public="1" set="method" line="433">
			<f a="?cb" v="null">
				<f a=":">
					<c path="Array"><t path="com.raidandfade.haxicord.types.structs.VoiceRegion"/></c>
					<t path="com.raidandfade.haxicord.endpoints.ErrorReport"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Get a list of voice regions for the guild. Including VIP servers if the server is a VIP-Enabled server.
        @param cb - Returns an array of voiceregion objects, or an error.</haxe_doc>
		</getVoiceRegions>
		<getIntegrations public="1" set="method" line="441">
			<f a="?cb" v="null">
				<f a=":">
					<c path="Array"><t path="com.raidandfade.haxicord.types.structs.GuildIntegration"/></c>
					<t path="com.raidandfade.haxicord.endpoints.ErrorReport"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Get a list of integrations for a given guild. Requires the MANAGE_GUILD permission.
        @param cb - Returns an array of guildintegration objects, or an error.</haxe_doc>
		</getIntegrations>
		<addIntegration public="1" set="method" line="450">
			<f a="intd:?cb" v=":null">
				<t path="com.raidandfade.haxicord.endpoints.IntegrationCreate"/>
				<t path="com.raidandfade.haxicord.endpoints.EmptyResponseCallback"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Add a new integration from the user onto the guild. Requires the MANAGE_GUILD permission.
        @param intd - The data of the new integration. 
        @param cb - Called on completion, useful for checking for errors.</haxe_doc>
		</addIntegration>
		<editIntegration public="1" set="method" line="460">
			<f a="intid:intd:?cb" v="::null">
				<c path="String"/>
				<t path="com.raidandfade.haxicord.endpoints.IntegrationModify"/>
				<t path="com.raidandfade.haxicord.endpoints.EmptyResponseCallback"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Edit an integration in a guild. Requires the MANAGE_GUILD permission.
        @param intid - The id of the integration to change.
        @param intd - The new data for the integration. All parameters are optional.
        @param cb - Called on completion, useful for checking for errors.</haxe_doc>
		</editIntegration>
		<syncIntegration public="1" set="method" line="469">
			<f a="intid:?cb" v=":null">
				<c path="String"/>
				<t path="com.raidandfade.haxicord.endpoints.EmptyResponseCallback"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Sync a given integration in a guild. Requires the MANAGE_GUILD permission.
        @param intid - The id of the integration to sync.
        @param cb - Called on completion, useful for checking for errors.</haxe_doc>
		</syncIntegration>
		<deleteIntegration public="1" set="method" line="478">
			<f a="intid:?cb" v=":null">
				<c path="String"/>
				<t path="com.raidandfade.haxicord.endpoints.EmptyResponseCallback"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Remove an integration from a guild. Requires the MANAGE_GUILD permission.
        @param intid - The id of the integration to remove.
        @param cb - Called on completion, useful for checking for errors.</haxe_doc>
		</deleteIntegration>
		<getWidget public="1" set="method" line="486">
			<f a="?cb" v="null">
				<f a=":">
					<t path="com.raidandfade.haxicord.types.structs.GuildEmbed"/>
					<t path="com.raidandfade.haxicord.endpoints.ErrorReport"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Get the widget/embed for a guild. Requires the MANAGE_GUILD permission.
        @param cb - Returns the GuildEmbed object of the guild, or an error.</haxe_doc>
		</getWidget>
		<editWidget public="1" set="method" line="495">
			<f a="wd:?cb" v=":null">
				<t path="com.raidandfade.haxicord.types.structs.GuildEmbed"/>
				<f a=":">
					<t path="com.raidandfade.haxicord.types.structs.GuildEmbed"/>
					<t path="com.raidandfade.haxicord.endpoints.ErrorReport"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Change the properties of a guild's embed or widget. Requires the MANAGE_GUILD permission.
        @param wd - The changes to be made to the widget/embed. All parameters are optional.
        @param cb - Returns the changed GuildEmbed object, or an error.</haxe_doc>
		</editWidget>
		<edit public="1" set="method" line="504">
			<f a="gd:?cb" v=":null">
				<t path="com.raidandfade.haxicord.endpoints.GuildUpdate"/>
				<f a=":">
					<c path="com.raidandfade.haxicord.types.Guild"/>
					<t path="com.raidandfade.haxicord.endpoints.ErrorReport"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Edit a guild's settings. Requires the MANAGE_GUILD permission
        @param gd - The data to be changed, All fields are optional.
        @param cb - Returns the new guild object, or an error.</haxe_doc>
		</edit>
		<delete public="1" set="method" line="512">
			<f a="?cb" v="null">
				<t path="com.raidandfade.haxicord.endpoints.EmptyResponseCallback"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Delete a guild. The account must be the owner of the guild.
        @param cb - Return the old guild object, or an error.</haxe_doc>
		</delete>
		<leave public="1" set="method" line="520">
			<f a="?cb" v="null">
				<t path="com.raidandfade.haxicord.endpoints.EmptyResponseCallback"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Make the current user leave the specified guild.
        @param cb - Called on completion, useful for checking for errors.</haxe_doc>
		</leave>
		<new public="1" set="method" line="134">
			<f a="_guild:_client">
				<t path="com.raidandfade.haxicord.types.structs.Guild"/>
				<c path="com.raidandfade.haxicord.DiscordClient"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="com.raidandfade.haxicord.types.GuildMember" params="" file="src/com/raidandfade/haxicord/types/GuildMember.hx">
		<client><c path="com.raidandfade.haxicord.DiscordClient"/></client>
		<user public="1">
			<c path="com.raidandfade.haxicord.types.User"/>
			<haxe_doc>The user object of this member</haxe_doc>
		</user>
		<displayName public="1">
			<c path="String"/>
			<haxe_doc>This member's displayname (Their nickname if they have one, otherwise their username)</haxe_doc>
		</displayName>
		<roles public="1">
			<c path="Array"><c path="String"/></c>
			<haxe_doc>The ids of roles this member has</haxe_doc>
		</roles>
		<joined_at public="1">
			<c path="Date"/>
			<haxe_doc>The date this member joined</haxe_doc>
		</joined_at>
		<deaf public="1">
			<x path="Bool"/>
			<haxe_doc>Is this member deafened?</haxe_doc>
		</deaf>
		<mute public="1">
			<x path="Bool"/>
			<haxe_doc>Is this member muted?</haxe_doc>
		</mute>
		<guild public="1">
			<c path="com.raidandfade.haxicord.types.Guild"/>
			<haxe_doc>The guild object that this member is a part of.</haxe_doc>
		</guild>
		<_update public="1" set="method" line="51">
			<f a="_mem">
				<t path="com.raidandfade.haxicord.types.structs.GuildMember"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_update>
		<_updatePresence public="1" set="method" line="58">
			<f a="_pre">
				<t path="com.raidandfade.haxicord.types.structs.Presence"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_updatePresence>
		<addRole public="1" set="method" line="71">
			<f a="rid:?cb" v=":null">
				<c path="String"/>
				<t path="com.raidandfade.haxicord.endpoints.EmptyResponseCallback"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Give a role to a member. Requires the MANAGE_ROLES permission
        @param rid - The id of the role desired to be added.
        @param cb - Called on completion, useful for checking for errors.</haxe_doc>
		</addRole>
		<removeRole public="1" set="method" line="80">
			<f a="rid:?cb" v=":null">
				<c path="String"/>
				<t path="com.raidandfade.haxicord.endpoints.EmptyResponseCallback"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Take a role away from a member. Requires the MANAGE_ROLES permission
        @param rid - The id of the role to take away.
        @param cb - Called on completion, useful for checking for errors.</haxe_doc>
		</removeRole>
		<hasRole public="1" set="method" line="88">
			<f a="rid">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Check if this user has a role by id
        @param rid - The id of the role to check for.</haxe_doc>
		</hasRole>
		<edit public="1" set="method" line="101">
			<f a="data:?cb" v=":null">
				<t path="com.raidandfade.haxicord.endpoints.EditGuildMember"/>
				<t path="com.raidandfade.haxicord.endpoints.EmptyResponseCallback"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Edit a guild member's properties, requires various permissions depending on the data provided. 
        @param data - The updated data, all parameters are optional. All parameters require a different permission.
        @param cb - Called on completion, useful for checking for errors.</haxe_doc>
		</edit>
		<changeNickname public="1" set="method" line="110">
			<f a="s:?cb" v=":null">
				<c path="String"/>
				<f a=":">
					<c path="String"/>
					<t path="com.raidandfade.haxicord.endpoints.ErrorReport"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Change this user's nickname.
        @param s - The nickname to change to.
        @param cb - Returns the nickname, or an error.</haxe_doc>
		</changeNickname>
		<kick public="1" set="method" line="118">
			<f a="?cb" v="null">
				<t path="com.raidandfade.haxicord.endpoints.EmptyResponseCallback"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Kick a member from the guild. Requires the KICK_MEMBERS permission
        @param cb - Called on completion, useful for checking for errors.</haxe_doc>
		</kick>
		<ban public="1" set="method" line="127">
			<f a="?days:?cb" v="0:null">
				<x path="Int"/>
				<t path="com.raidandfade.haxicord.endpoints.EmptyResponseCallback"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null, days : 0 }</e></m></meta>
			<haxe_doc>Ban a member of the guild. Requires the BAN_MEMBERS permission.
        @param days - Number of days (from 0-7) to remove the user's messages server wide.
        @param cb - Called on completion, useful for checking for errors.</haxe_doc>
		</ban>
		<new public="1" set="method" line="38">
			<f a="_mem:_guild:_client">
				<t path="com.raidandfade.haxicord.types.structs.GuildMember"/>
				<c path="com.raidandfade.haxicord.types.Guild"/>
				<c path="com.raidandfade.haxicord.DiscordClient"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="com.raidandfade.haxicord.types.Message" params="" file="src/com/raidandfade/haxicord/types/Message.hx">
		<id public="1">
			<c path="com.raidandfade.haxicord.types.Snowflake"/>
			<haxe_doc>The id of this message</haxe_doc>
		</id>
		<channel_id public="1">
			<c path="com.raidandfade.haxicord.types.Snowflake"/>
			<haxe_doc>The id of the channel this message is in</haxe_doc>
		</channel_id>
		<author public="1">
			<c path="com.raidandfade.haxicord.types.User"/>
			<haxe_doc>The user object of this message's author.</haxe_doc>
		</author>
		<content public="1">
			<c path="String"/>
			<haxe_doc>The message content.</haxe_doc>
		</content>
		<timestamp public="1">
			<c path="Date"/>
			<haxe_doc>When the message was sent.</haxe_doc>
		</timestamp>
		<edited_timestamp public="1">
			<c path="Date"/>
			<haxe_doc>Last time the message was edited (or null)</haxe_doc>
		</edited_timestamp>
		<tts public="1">
			<x path="Bool"/>
			<haxe_doc>Was the message TTS?</haxe_doc>
		</tts>
		<mention_everyone public="1">
			<x path="Bool"/>
			<haxe_doc>Did the message mention everyone?</haxe_doc>
		</mention_everyone>
		<mentions public="1" expr="new Array&lt;User&gt;()">
			<c path="Array"><c path="com.raidandfade.haxicord.types.User"/></c>
			<meta><m n=":value"><e><![CDATA[new Array<User>()]]></e></m></meta>
			<haxe_doc>A list of users that were mentioned in the message.</haxe_doc>
		</mentions>
		<mention_roles public="1" expr="new Array&lt;Role&gt;()">
			<c path="Array"><c path="com.raidandfade.haxicord.types.Role"/></c>
			<meta><m n=":value"><e><![CDATA[new Array<Role>()]]></e></m></meta>
			<haxe_doc>A list of roles that were mentioned in the message.</haxe_doc>
		</mention_roles>
		<attachments public="1" expr="new Array&lt;Attachment&gt;()">
			<c path="Array"><t path="com.raidandfade.haxicord.types.structs.Attachment"/></c>
			<meta><m n=":value"><e><![CDATA[new Array<Attachment>()]]></e></m></meta>
			<haxe_doc>A list of attachments on this message.</haxe_doc>
		</attachments>
		<embeds public="1" expr="new Array&lt;Dynamic&gt;()">
			<c path="Array"><d/></c>
			<meta><m n=":value"><e><![CDATA[new Array<Dynamic>()]]></e></m></meta>
			<haxe_doc>A list of embeds on this message.</haxe_doc>
		</embeds>
		<reactions public="1" expr="new Array&lt;Reaction&gt;()">
			<c path="Array"><t path="com.raidandfade.haxicord.types.structs.Reaction"/></c>
			<meta><m n=":value"><e><![CDATA[new Array<Reaction>()]]></e></m></meta>
			<haxe_doc>A list of reactions on this message.</haxe_doc>
		</reactions>
		<nonce public="1">
			<c path="com.raidandfade.haxicord.types.Snowflake"/>
			<haxe_doc>A nonce, only seen when you are the author and have sent a nonce. otherwise Null.</haxe_doc>
		</nonce>
		<pinned public="1">
			<x path="Bool"/>
			<haxe_doc>Is this message pinned?</haxe_doc>
		</pinned>
		<webhook_id public="1">
			<c path="String"/>
			<haxe_doc>If the message was created by a webhook, this will be the webhook's id</haxe_doc>
		</webhook_id>
		<client><c path="com.raidandfade.haxicord.DiscordClient"/></client>
		<_update public="1" set="method" line="103">
			<f a="_msg">
				<t path="com.raidandfade.haxicord.types.structs.MessageStruct"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_update>
		<_addReaction public="1" set="method" line="118">
			<f a="_u:_e">
				<c path="com.raidandfade.haxicord.types.User"/>
				<t path="com.raidandfade.haxicord.types.structs.Emoji"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_addReaction>
		<_delReaction public="1" set="method" line="123">
			<f a="_u:_e">
				<c path="com.raidandfade.haxicord.types.User"/>
				<t path="com.raidandfade.haxicord.types.structs.Emoji"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_delReaction>
		<_purgeReactions public="1" set="method" line="128">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_purgeReactions>
		<pin public="1" set="method" line="136">
			<f a="?cb" v="null">
				<f a=":">
					<d/>
					<c path="String"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Pin this message
        @param cb - Called once completed. Leave blank to ignore.</haxe_doc>
		</pin>
		<unpin public="1" set="method" line="144">
			<f a="?cb" v="null">
				<f a=":">
					<d/>
					<c path="String"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Unpin this message
        @param cb - Called once completed. Leave blank to ignore.</haxe_doc>
		</unpin>
		<getChannel public="1" set="method" line="152">
			<f a=""><c path="com.raidandfade.haxicord.types.MessageChannel"/></f>
			<haxe_doc>Return the channel this message is part of
       @return MessageChannel : The channel this message is part of, either a TextChannel or a DMChannel</haxe_doc>
		</getChannel>
		<inGuild public="1" set="method" line="159">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>Return whether this message is in a guild or not.</haxe_doc>
		</inGuild>
		<getMember public="1" set="method" line="166">
			<f a=""><t path="Null"><c path="com.raidandfade.haxicord.types.GuildMember"/></t></f>
			<haxe_doc>If this message was in a guild, get the guildmember object of the member who sent it, otherwise return null.</haxe_doc>
		</getMember>
		<getGuild public="1" set="method" line="176">
			<f a=""><t path="Null"><c path="com.raidandfade.haxicord.types.Guild"/></t></f>
			<haxe_doc>If this message was in a guild, get the guild object this was sent in, otherwise return null.</haxe_doc>
		</getGuild>
		<reply public="1" set="method" line="188">
			<f a="msg:?cb" v=":null">
				<t path="com.raidandfade.haxicord.endpoints.MessageCreate"/>
				<f a=":">
					<c path="com.raidandfade.haxicord.types.Message"/>
					<t path="com.raidandfade.haxicord.endpoints.ErrorReport"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Send a message to a channel
        @param msg - Message data
        @param cb - Return the message sent, or an error</haxe_doc>
		</reply>
		<edit public="1" set="method" line="197">
			<f a="msg:?cb" v=":null">
				<t path="com.raidandfade.haxicord.endpoints.MessageEdit"/>
				<f a=":">
					<c path="com.raidandfade.haxicord.types.Message"/>
					<t path="com.raidandfade.haxicord.endpoints.ErrorReport"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Edit a message previously sent by you.
        @param msg - The new content of the message, all fields are optional.
        @param cb - Return the new message, or an error.</haxe_doc>
		</edit>
		<delete public="1" set="method" line="205">
			<f a="?cb" v="null">
				<t path="com.raidandfade.haxicord.endpoints.EmptyResponseCallback"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Delete a given message. If the author is not the current user, the MANAGE_MESSAGES permission is required
        @param cb - Return when complete.</haxe_doc>
		</delete>
		<getReactions public="1" set="method" line="214">
			<f a="e:?cb" v=":null">
				<c path="String"/>
				<f a=":">
					<c path="Array"><t path="com.raidandfade.haxicord.types.structs.Reaction"/></c>
					<c path="String"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Get all reactions of emoji by user on a message.
        @param e - The emoji to look for.
        @param cb - Returns an array of Reaction objects, or an error.</haxe_doc>
		</getReactions>
		<react public="1" set="method" line="223">
			<f a="e:?cb" v=":null">
				<c path="String"/>
				<t path="com.raidandfade.haxicord.endpoints.EmptyResponseCallback"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Add a reaction to a message. requires READ_MESSAGE_HISTORY and ADD_REACTIONS if the emoji is not already present.
        @param e - The emote to be added, Custom emotes require their TAG.
        @param cb - Called when completed, good for checking for errors.</haxe_doc>
		</react>
		<unreact public="1" set="method" line="232">
			<f a="e:?cb" v=":null">
				<c path="String"/>
				<t path="com.raidandfade.haxicord.endpoints.EmptyResponseCallback"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Delete a reaction of your own off of a message.
        @param e - The emote to be removed. Custom emotes require their TAG
        @param cb - Called when completed, good for checking for errors.</haxe_doc>
		</unreact>
		<removeReaction public="1" set="method" line="242">
			<f a="e:uid:?cb" v="::null">
				<c path="String"/>
				<c path="String"/>
				<t path="com.raidandfade.haxicord.endpoints.EmptyResponseCallback"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Delete another user's reaction off of a message.
        @param uid - The user to delete the reaction from.
        @param e - The emote to be removed. Custom emotes require their TAG
        @param cb - Called when completed, good for checking for errors.</haxe_doc>
		</removeReaction>
		<removeAllReactions public="1" set="method" line="250">
			<f a="?cb" v="null">
				<t path="com.raidandfade.haxicord.endpoints.EmptyResponseCallback"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Delete all reactions from a message. Requires the MANAGE_MESSAGES permission.
        @param cb - Called when completed, good for looking for errors.</haxe_doc>
		</removeAllReactions>
		<new public="1" set="method" line="81">
			<f a="_msg:_client">
				<t path="com.raidandfade.haxicord.types.structs.MessageStruct"/>
				<c path="com.raidandfade.haxicord.DiscordClient"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="com.raidandfade.haxicord.types.Role" params="" file="src/com/raidandfade/haxicord/types/Role.hx">
		<client><c path="com.raidandfade.haxicord.DiscordClient"/></client>
		<id public="1">
			<c path="com.raidandfade.haxicord.types.Snowflake"/>
			<haxe_doc>The ID of the role</haxe_doc>
		</id>
		<name public="1">
			<c path="String"/>
			<haxe_doc>The name of the role</haxe_doc>
		</name>
		<color public="1">
			<x path="Int"/>
			<haxe_doc>The RGB integer of the color of the role</haxe_doc>
		</color>
		<hoist public="1">
			<x path="Bool"/>
			<haxe_doc>Is the role listed separately?</haxe_doc>
		</hoist>
		<position public="1">
			<x path="Int"/>
			<haxe_doc>The position of the role</haxe_doc>
		</position>
		<permissions public="1">
			<x path="Int"/>
			<haxe_doc>The bitwise integer of permissions the role has</haxe_doc>
		</permissions>
		<managed public="1">
			<x path="Bool"/>
			<haxe_doc>Is this role managed by an integration?</haxe_doc>
		</managed>
		<mentionable public="1">
			<x path="Bool"/>
			<haxe_doc>Is this role mentionable?</haxe_doc>
		</mentionable>
		<guild public="1">
			<c path="com.raidandfade.haxicord.types.Guild"/>
			<haxe_doc>The Guild this role is a part of</haxe_doc>
		</guild>
		<_update public="1" set="method" line="60">
			<f a="_role">
				<t path="com.raidandfade.haxicord.types.structs.Role"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_update>
		<edit public="1" set="method" line="76">
			<f a="rd:?cb" v=":null">
				<t path="com.raidandfade.haxicord.endpoints.RoleInfo"/>
				<f a=":">
					<c path="com.raidandfade.haxicord.types.Role"/>
					<t path="com.raidandfade.haxicord.endpoints.ErrorReport"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Edit a role's data. Requires the MANAGE_ROLES permission.
        @param rd - The new data, All fields are optional. 
        @param cb - Returns the new role, or an error.</haxe_doc>
		</edit>
		<delete public="1" set="method" line="84">
			<f a="?cb" v="null">
				<t path="com.raidandfade.haxicord.endpoints.EmptyResponseCallback"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Delete a role from a guild. Requires the MANAGE_ROLES permission.
        @param cb - Called on completion, useful for checking for errors.</haxe_doc>
		</delete>
		<new public="1" set="method" line="46">
			<f a="_role:_guild:_client">
				<t path="com.raidandfade.haxicord.types.structs.Role"/>
				<c path="com.raidandfade.haxicord.types.Guild"/>
				<c path="com.raidandfade.haxicord.DiscordClient"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="com.raidandfade.haxicord.types.Snowflake" params="" file="src/com/raidandfade/haxicord/types/Snowflake.hx">
		<generate public="1" set="method" line="30" static="1">
			<f a=""><c path="com.raidandfade.haxicord.types.Snowflake"/></f>
			<haxe_doc>Generate a snowflake with the current time.</haxe_doc>
		</generate>
		<eq get="inline" set="null" line="51" static="1"><f a="a:b">
	<c path="com.raidandfade.haxicord.types.Snowflake"/>
	<c path="com.raidandfade.haxicord.types.Snowflake"/>
	<x path="Bool"/>
</f></eq>
		<id public="1">
			<c path="String"/>
			<haxe_doc>The id string of the snowflake</haxe_doc>
		</id>
		<timestamp public="1">
			<x path="Float"/>
			<haxe_doc>The timestamp representation of the snowflake</haxe_doc>
		</timestamp>
		<toString public="1" set="method" line="41">
			<f a=""><c path="String"/></f>
			<haxe_doc>Return the snowflake in the form of a string.</haxe_doc>
		</toString>
		<equals public="1" set="method" line="48">
			<f a="b">
				<c path="com.raidandfade.haxicord.types.Snowflake"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Check if the snowflake is equal to another snowflake
       @param b - The other snowflake</haxe_doc>
		</equals>
		<new public="1" set="method" line="15">
			<f a="?flake" v="null">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ flake : null }</e></m></meta>
			<haxe_doc>Create a snowflake object given a snowflake string.</haxe_doc>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="com.raidandfade.haxicord.types.TextChannel" params="" file="src/com/raidandfade/haxicord/types/TextChannel.hx">
		<extends path="com.raidandfade.haxicord.types.GuildChannel"/>
		<implements path="com.raidandfade.haxicord.types.MessageChannel"/>
		<fromStruct public="1" set="method" line="39" static="1">
			<f a="_chan:_client">
				<t path="com.raidandfade.haxicord.types.structs.TextChannel"/>
				<c path="com.raidandfade.haxicord.DiscordClient"/>
				<c path="com.raidandfade.haxicord.types.TextChannel"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</fromStruct>
		<topic public="1">
			<c path="String"/>
			<haxe_doc>The topic of the channel.</haxe_doc>
		</topic>
		<last_message_id public="1">
			<c path="com.raidandfade.haxicord.types.Snowflake"/>
			<haxe_doc>The id of the last Message that was sent in the chat.</haxe_doc>
		</last_message_id>
		<_update public="1" set="method" line="30">
			<f a="_chan">
				<t path="com.raidandfade.haxicord.types.structs.TextChannel"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_update>
		<inGuild public="1" set="method" line="47">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>Returns whether the channel is part of a guild or not. Always true for TextChannels</haxe_doc>
		</inGuild>
		<sendMessage public="1" set="method" line="56">
			<f a="mesg:?cb" v=":null">
				<t path="com.raidandfade.haxicord.endpoints.MessageCreate"/>
				<f a=":">
					<c path="com.raidandfade.haxicord.types.Message"/>
					<t path="com.raidandfade.haxicord.endpoints.ErrorReport"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Send a message to a channel
        @param mesg - Message data
        @param cb - Return the message sent, or an error</haxe_doc>
		</sendMessage>
		<getMessages public="1" set="method" line="65">
			<f a="?format:?cb" v="null:null">
				<a/>
				<f a=":">
					<c path="Array"><c path="com.raidandfade.haxicord.types.Message"/></c>
					<t path="com.raidandfade.haxicord.endpoints.ErrorReport"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null, format : null }</e></m></meta>
			<haxe_doc>Get messages from a given channel according to the given format.
        @param format - Before, After, or Around. 
        @param cb - The array of messages, or an error.</haxe_doc>
		</getMessages>
		<getMessage public="1" set="method" line="75">
			<f a="mid:?cb" v=":null">
				<c path="String"/>
				<f a=":">
					<c path="com.raidandfade.haxicord.types.Message"/>
					<t path="com.raidandfade.haxicord.endpoints.ErrorReport"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Get a message in a channel
        @param mid - The message id
        @param cb - Return the message, or an error.</haxe_doc>
		</getMessage>
		<deleteMessage public="1" set="method" line="84">
			<f a="mid:?cb" v=":null">
				<c path="String"/>
				<t path="com.raidandfade.haxicord.endpoints.EmptyResponseCallback"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Delete a given message. If the author is not the current user, the MANAGE_MESSAGES permission is required
        @param mid - The id of the message.
        @param cb - Return when complete.</haxe_doc>
		</deleteMessage>
		<deleteMessages public="1" set="method" line="93">
			<f a="ids:?cb" v=":null">
				<t path="com.raidandfade.haxicord.endpoints.MessageBulkDelete"/>
				<t path="com.raidandfade.haxicord.endpoints.EmptyResponseCallback"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Delete a given messages. MANAGE_MESSAGES is required.
        @param ids - an array of id of the messages.
        @param cb - Return when complete.</haxe_doc>
		</deleteMessages>
		<startTyping public="1" set="method" line="101">
			<f a="?cb" v="null">
				<t path="com.raidandfade.haxicord.endpoints.EmptyResponseCallback"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Send a typing event in the given channel. This lasts for 10 seconds or when a message is sent, whichever comes first.
        @param cb - Return when complete.</haxe_doc>
		</startTyping>
		<getPins public="1" set="method" line="109">
			<f a="?cb" v="null">
				<f a=":">
					<c path="Array"><c path="com.raidandfade.haxicord.types.Message"/></c>
					<t path="com.raidandfade.haxicord.endpoints.ErrorReport"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Get the pins of a channel
        @param cb - Return an array of pins (or an error)</haxe_doc>
		</getPins>
		<pinMessage public="1" set="method" line="118">
			<f a="mid:?cb" v=":null">
				<c path="String"/>
				<t path="com.raidandfade.haxicord.endpoints.EmptyResponseCallback"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Add a channel pin
        @param mid - The message
        @param cb - Called once completed. Leave blank to ignore.</haxe_doc>
		</pinMessage>
		<unpinMessage public="1" set="method" line="127">
			<f a="mid:?cb" v=":null">
				<c path="String"/>
				<t path="com.raidandfade.haxicord.endpoints.EmptyResponseCallback"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cb : null }</e></m></meta>
			<haxe_doc>Delete a channel's pin
        @param mid - The pin id
        @param cb - Called once completed. Leave blank to ignore.</haxe_doc>
		</unpinMessage>
		<new public="1" set="method" line="14">
			<f a="_chan:_client">
				<t path="com.raidandfade.haxicord.types.structs.TextChannel"/>
				<c path="com.raidandfade.haxicord.DiscordClient"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="com.raidandfade.haxicord.types.User" params="" file="src/com/raidandfade/haxicord/types/User.hx">
		<client><c path="com.raidandfade.haxicord.DiscordClient"/></client>
		<id public="1">
			<c path="com.raidandfade.haxicord.types.Snowflake"/>
			<haxe_doc>The id of the user</haxe_doc>
		</id>
		<tag public="1">
			<c path="String"/>
			<haxe_doc>The mention string (tag) of the user</haxe_doc>
		</tag>
		<username public="1">
			<c path="String"/>
			<haxe_doc>The username of the user</haxe_doc>
		</username>
		<discriminator public="1">
			<c path="String"/>
			<haxe_doc>The discriminator of the user</haxe_doc>
		</discriminator>
		<avatar public="1">
			<c path="String"/>
			<haxe_doc>The avatar hash of the user</haxe_doc>
		</avatar>
		<avatarUrl public="1">
			<c path="String"/>
			<haxe_doc>The avatar url of the user</haxe_doc>
		</avatarUrl>
		<bot public="1">
			<x path="Bool"/>
			<haxe_doc>Is the user a bot?</haxe_doc>
		</bot>
		<mfa_enabled public="1">
			<x path="Bool"/>
			<haxe_doc>Does the user have MFA enabled?
        Only set for the bot user.</haxe_doc>
		</mfa_enabled>
		<game public="1">
			<t path="com.raidandfade.haxicord.types.structs.PresenceGame"/>
			<haxe_doc>The game that the current user is playing.</haxe_doc>
		</game>
		<verified public="1">
			<x path="Bool"/>
			<haxe_doc>Has the user verified their email?
        PLACEHOLDER. WILL NEVER CONTAIN ANYTHING</haxe_doc>
		</verified>
		<email public="1">
			<c path="String"/>
			<haxe_doc>The user's email
        PLACEHOLDER. WILL NEVER CONTAIN ANYTHING</haxe_doc>
		</email>
		<_update public="1" set="method" line="75">
			<f a="_user">
				<t path="com.raidandfade.haxicord.types.structs.User"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_update>
		<new public="1" set="method" line="59">
			<f a="_user:_client">
				<t path="com.raidandfade.haxicord.types.structs.User"/>
				<c path="com.raidandfade.haxicord.DiscordClient"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="com.raidandfade.haxicord.types.VoiceChannel" params="" file="src/com/raidandfade/haxicord/types/VoiceChannel.hx">
		<extends path="com.raidandfade.haxicord.types.GuildChannel"/>
		<fromStruct public="1" set="method" line="41" static="1">
			<f a="_chan:_client">
				<t path="com.raidandfade.haxicord.types.structs.VoiceChannel"/>
				<c path="com.raidandfade.haxicord.DiscordClient"/>
				<c path="com.raidandfade.haxicord.types.VoiceChannel"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</fromStruct>
		<bitrate public="1">
			<x path="Int"/>
			<haxe_doc>The bitrate of the channel</haxe_doc>
		</bitrate>
		<user_limit public="1">
			<x path="Int"/>
			<haxe_doc>The user limit of the channel (or 0 if unlimited)</haxe_doc>
		</user_limit>
		<_update public="1" set="method" line="31">
			<f a="_chan">
				<t path="com.raidandfade.haxicord.types.structs.VoiceChannel"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_update>
		<new public="1" set="method" line="15">
			<f a="_chan:_client">
				<t path="com.raidandfade.haxicord.types.structs.VoiceChannel"/>
				<c path="com.raidandfade.haxicord.DiscordClient"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="com.raidandfade.haxicord.types.structs.AuditLog" params="" file="src/com/raidandfade/haxicord/types/structs/AuditLog.hx"><a>
	<webhooks><c path="Array"><t path="com.raidandfade.haxicord.types.structs.Webhook"/></c></webhooks>
	<users><c path="Array"><t path="com.raidandfade.haxicord.types.structs.User"/></c></users>
	<audit_log_entries><c path="Array"><t path="com.raidandfade.haxicord.types.structs.AuditLogEntry"/></c></audit_log_entries>
</a></typedef>
	<typedef path="com.raidandfade.haxicord.types.structs.AuditLogEntry" params="" file="src/com/raidandfade/haxicord/types/structs/AuditLog.hx" module="com.raidandfade.haxicord.types.structs.AuditLog"><a>
	<user_id><c path="String"/></user_id>
	<target_id><c path="String"/></target_id>
	<reason><c path="String"/></reason>
	<options><c path="Array"><t path="com.raidandfade.haxicord.types.structs.AuditLogOptionalEntryInfo"/></c></options>
	<id><c path="String"/></id>
	<changes><c path="Array"><t path="com.raidandfade.haxicord.types.structs.AuditLogChange"/></c></changes>
	<action_type><x path="com.raidandfade.haxicord.types.structs.AuditLogEvent"/></action_type>
</a></typedef>
	<abstract path="com.raidandfade.haxicord.types.structs.AuditLogEvent" params="" file="src/com/raidandfade/haxicord/types/structs/AuditLog.hx" module="com.raidandfade.haxicord.types.structs.AuditLog">
		<this><x path="Int"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="com.raidandfade.haxicord.types.structs._AuditLog.AuditLogEvent_Impl_" params="" file="src/com/raidandfade/haxicord/types/structs/AuditLog.hx" private="1" module="com.raidandfade.haxicord.types.structs.AuditLog" extern="1">
	<GUILD_UPDATE public="1" get="inline" set="null" expr="cast 1" line="21" static="1">
		<x path="com.raidandfade.haxicord.types.structs.AuditLogEvent"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</GUILD_UPDATE>
	<CHANNEL_CREATE public="1" get="inline" set="null" expr="cast 10" line="22" static="1">
		<x path="com.raidandfade.haxicord.types.structs.AuditLogEvent"/>
		<meta>
			<m n=":value"><e>cast 10</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</CHANNEL_CREATE>
	<CHANNEL_UPDATE public="1" get="inline" set="null" expr="cast 11" line="23" static="1">
		<x path="com.raidandfade.haxicord.types.structs.AuditLogEvent"/>
		<meta>
			<m n=":value"><e>cast 11</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</CHANNEL_UPDATE>
	<CHANNEL_DELETE public="1" get="inline" set="null" expr="cast 12" line="24" static="1">
		<x path="com.raidandfade.haxicord.types.structs.AuditLogEvent"/>
		<meta>
			<m n=":value"><e>cast 12</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</CHANNEL_DELETE>
	<CHANNEL_OVERWRITE_CREATE public="1" get="inline" set="null" expr="cast 13" line="25" static="1">
		<x path="com.raidandfade.haxicord.types.structs.AuditLogEvent"/>
		<meta>
			<m n=":value"><e>cast 13</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</CHANNEL_OVERWRITE_CREATE>
	<CHANNEL_OVERWRITE_UPDATE public="1" get="inline" set="null" expr="cast 14" line="26" static="1">
		<x path="com.raidandfade.haxicord.types.structs.AuditLogEvent"/>
		<meta>
			<m n=":value"><e>cast 14</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</CHANNEL_OVERWRITE_UPDATE>
	<CHANNEL_OVERWRITE_DELETE public="1" get="inline" set="null" expr="cast 15" line="27" static="1">
		<x path="com.raidandfade.haxicord.types.structs.AuditLogEvent"/>
		<meta>
			<m n=":value"><e>cast 15</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</CHANNEL_OVERWRITE_DELETE>
	<MEMBER_KICK public="1" get="inline" set="null" expr="cast 20" line="28" static="1">
		<x path="com.raidandfade.haxicord.types.structs.AuditLogEvent"/>
		<meta>
			<m n=":value"><e>cast 20</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</MEMBER_KICK>
	<MEMBER_PRUNE public="1" get="inline" set="null" expr="cast 21" line="29" static="1">
		<x path="com.raidandfade.haxicord.types.structs.AuditLogEvent"/>
		<meta>
			<m n=":value"><e>cast 21</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</MEMBER_PRUNE>
	<MEMBER_BAN_ADD public="1" get="inline" set="null" expr="cast 22" line="30" static="1">
		<x path="com.raidandfade.haxicord.types.structs.AuditLogEvent"/>
		<meta>
			<m n=":value"><e>cast 22</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</MEMBER_BAN_ADD>
	<MEMBER_BAN_REMOVE public="1" get="inline" set="null" expr="cast 23" line="31" static="1">
		<x path="com.raidandfade.haxicord.types.structs.AuditLogEvent"/>
		<meta>
			<m n=":value"><e>cast 23</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</MEMBER_BAN_REMOVE>
	<MEMBER_UPDATE public="1" get="inline" set="null" expr="cast 24" line="32" static="1">
		<x path="com.raidandfade.haxicord.types.structs.AuditLogEvent"/>
		<meta>
			<m n=":value"><e>cast 24</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</MEMBER_UPDATE>
	<MEMBER_ROLE_UPDATE public="1" get="inline" set="null" expr="cast 25" line="33" static="1">
		<x path="com.raidandfade.haxicord.types.structs.AuditLogEvent"/>
		<meta>
			<m n=":value"><e>cast 25</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</MEMBER_ROLE_UPDATE>
	<ROLE_CREATE public="1" get="inline" set="null" expr="cast 30" line="34" static="1">
		<x path="com.raidandfade.haxicord.types.structs.AuditLogEvent"/>
		<meta>
			<m n=":value"><e>cast 30</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ROLE_CREATE>
	<ROLE_UPDATE public="1" get="inline" set="null" expr="cast 31" line="35" static="1">
		<x path="com.raidandfade.haxicord.types.structs.AuditLogEvent"/>
		<meta>
			<m n=":value"><e>cast 31</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ROLE_UPDATE>
	<ROLE_DELETE public="1" get="inline" set="null" expr="cast 32" line="36" static="1">
		<x path="com.raidandfade.haxicord.types.structs.AuditLogEvent"/>
		<meta>
			<m n=":value"><e>cast 32</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ROLE_DELETE>
	<INVITE_CREATE public="1" get="inline" set="null" expr="cast 40" line="37" static="1">
		<x path="com.raidandfade.haxicord.types.structs.AuditLogEvent"/>
		<meta>
			<m n=":value"><e>cast 40</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</INVITE_CREATE>
	<INVITE_UPDATE public="1" get="inline" set="null" expr="cast 41" line="38" static="1">
		<x path="com.raidandfade.haxicord.types.structs.AuditLogEvent"/>
		<meta>
			<m n=":value"><e>cast 41</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</INVITE_UPDATE>
	<INVITE_DELETE public="1" get="inline" set="null" expr="cast 42" line="39" static="1">
		<x path="com.raidandfade.haxicord.types.structs.AuditLogEvent"/>
		<meta>
			<m n=":value"><e>cast 42</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</INVITE_DELETE>
	<WEBHOOK_CREATE public="1" get="inline" set="null" expr="cast 50" line="40" static="1">
		<x path="com.raidandfade.haxicord.types.structs.AuditLogEvent"/>
		<meta>
			<m n=":value"><e>cast 50</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</WEBHOOK_CREATE>
	<WEBHOOK_UPDATE public="1" get="inline" set="null" expr="cast 51" line="41" static="1">
		<x path="com.raidandfade.haxicord.types.structs.AuditLogEvent"/>
		<meta>
			<m n=":value"><e>cast 51</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</WEBHOOK_UPDATE>
	<WEBHOOK_DELETE public="1" get="inline" set="null" expr="cast 52" line="42" static="1">
		<x path="com.raidandfade.haxicord.types.structs.AuditLogEvent"/>
		<meta>
			<m n=":value"><e>cast 52</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</WEBHOOK_DELETE>
	<EMOJI_CREATE public="1" get="inline" set="null" expr="cast 60" line="43" static="1">
		<x path="com.raidandfade.haxicord.types.structs.AuditLogEvent"/>
		<meta>
			<m n=":value"><e>cast 60</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</EMOJI_CREATE>
	<EMOJI_UPDATE public="1" get="inline" set="null" expr="cast 61" line="44" static="1">
		<x path="com.raidandfade.haxicord.types.structs.AuditLogEvent"/>
		<meta>
			<m n=":value"><e>cast 61</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</EMOJI_UPDATE>
	<EMOJI_DELETE public="1" get="inline" set="null" expr="cast 62" line="45" static="1">
		<x path="com.raidandfade.haxicord.types.structs.AuditLogEvent"/>
		<meta>
			<m n=":value"><e>cast 62</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</EMOJI_DELETE>
	<MESSAGE_DELETE public="1" get="inline" set="null" expr="cast 72" line="46" static="1">
		<x path="com.raidandfade.haxicord.types.structs.AuditLogEvent"/>
		<meta>
			<m n=":value"><e>cast 72</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</MESSAGE_DELETE>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="com.raidandfade.haxicord.types.structs._AuditLog.AuditLogEvent_Impl_" params="" file="src/com/raidandfade/haxicord/types/structs/AuditLog.hx" private="1" module="com.raidandfade.haxicord.types.structs.AuditLog" extern="1">
		<GUILD_UPDATE public="1" get="inline" set="null" expr="cast 1" line="21" static="1">
			<x path="com.raidandfade.haxicord.types.structs.AuditLogEvent"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</GUILD_UPDATE>
		<CHANNEL_CREATE public="1" get="inline" set="null" expr="cast 10" line="22" static="1">
			<x path="com.raidandfade.haxicord.types.structs.AuditLogEvent"/>
			<meta>
				<m n=":value"><e>cast 10</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</CHANNEL_CREATE>
		<CHANNEL_UPDATE public="1" get="inline" set="null" expr="cast 11" line="23" static="1">
			<x path="com.raidandfade.haxicord.types.structs.AuditLogEvent"/>
			<meta>
				<m n=":value"><e>cast 11</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</CHANNEL_UPDATE>
		<CHANNEL_DELETE public="1" get="inline" set="null" expr="cast 12" line="24" static="1">
			<x path="com.raidandfade.haxicord.types.structs.AuditLogEvent"/>
			<meta>
				<m n=":value"><e>cast 12</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</CHANNEL_DELETE>
		<CHANNEL_OVERWRITE_CREATE public="1" get="inline" set="null" expr="cast 13" line="25" static="1">
			<x path="com.raidandfade.haxicord.types.structs.AuditLogEvent"/>
			<meta>
				<m n=":value"><e>cast 13</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</CHANNEL_OVERWRITE_CREATE>
		<CHANNEL_OVERWRITE_UPDATE public="1" get="inline" set="null" expr="cast 14" line="26" static="1">
			<x path="com.raidandfade.haxicord.types.structs.AuditLogEvent"/>
			<meta>
				<m n=":value"><e>cast 14</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</CHANNEL_OVERWRITE_UPDATE>
		<CHANNEL_OVERWRITE_DELETE public="1" get="inline" set="null" expr="cast 15" line="27" static="1">
			<x path="com.raidandfade.haxicord.types.structs.AuditLogEvent"/>
			<meta>
				<m n=":value"><e>cast 15</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</CHANNEL_OVERWRITE_DELETE>
		<MEMBER_KICK public="1" get="inline" set="null" expr="cast 20" line="28" static="1">
			<x path="com.raidandfade.haxicord.types.structs.AuditLogEvent"/>
			<meta>
				<m n=":value"><e>cast 20</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</MEMBER_KICK>
		<MEMBER_PRUNE public="1" get="inline" set="null" expr="cast 21" line="29" static="1">
			<x path="com.raidandfade.haxicord.types.structs.AuditLogEvent"/>
			<meta>
				<m n=":value"><e>cast 21</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</MEMBER_PRUNE>
		<MEMBER_BAN_ADD public="1" get="inline" set="null" expr="cast 22" line="30" static="1">
			<x path="com.raidandfade.haxicord.types.structs.AuditLogEvent"/>
			<meta>
				<m n=":value"><e>cast 22</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</MEMBER_BAN_ADD>
		<MEMBER_BAN_REMOVE public="1" get="inline" set="null" expr="cast 23" line="31" static="1">
			<x path="com.raidandfade.haxicord.types.structs.AuditLogEvent"/>
			<meta>
				<m n=":value"><e>cast 23</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</MEMBER_BAN_REMOVE>
		<MEMBER_UPDATE public="1" get="inline" set="null" expr="cast 24" line="32" static="1">
			<x path="com.raidandfade.haxicord.types.structs.AuditLogEvent"/>
			<meta>
				<m n=":value"><e>cast 24</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</MEMBER_UPDATE>
		<MEMBER_ROLE_UPDATE public="1" get="inline" set="null" expr="cast 25" line="33" static="1">
			<x path="com.raidandfade.haxicord.types.structs.AuditLogEvent"/>
			<meta>
				<m n=":value"><e>cast 25</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</MEMBER_ROLE_UPDATE>
		<ROLE_CREATE public="1" get="inline" set="null" expr="cast 30" line="34" static="1">
			<x path="com.raidandfade.haxicord.types.structs.AuditLogEvent"/>
			<meta>
				<m n=":value"><e>cast 30</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ROLE_CREATE>
		<ROLE_UPDATE public="1" get="inline" set="null" expr="cast 31" line="35" static="1">
			<x path="com.raidandfade.haxicord.types.structs.AuditLogEvent"/>
			<meta>
				<m n=":value"><e>cast 31</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ROLE_UPDATE>
		<ROLE_DELETE public="1" get="inline" set="null" expr="cast 32" line="36" static="1">
			<x path="com.raidandfade.haxicord.types.structs.AuditLogEvent"/>
			<meta>
				<m n=":value"><e>cast 32</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ROLE_DELETE>
		<INVITE_CREATE public="1" get="inline" set="null" expr="cast 40" line="37" static="1">
			<x path="com.raidandfade.haxicord.types.structs.AuditLogEvent"/>
			<meta>
				<m n=":value"><e>cast 40</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</INVITE_CREATE>
		<INVITE_UPDATE public="1" get="inline" set="null" expr="cast 41" line="38" static="1">
			<x path="com.raidandfade.haxicord.types.structs.AuditLogEvent"/>
			<meta>
				<m n=":value"><e>cast 41</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</INVITE_UPDATE>
		<INVITE_DELETE public="1" get="inline" set="null" expr="cast 42" line="39" static="1">
			<x path="com.raidandfade.haxicord.types.structs.AuditLogEvent"/>
			<meta>
				<m n=":value"><e>cast 42</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</INVITE_DELETE>
		<WEBHOOK_CREATE public="1" get="inline" set="null" expr="cast 50" line="40" static="1">
			<x path="com.raidandfade.haxicord.types.structs.AuditLogEvent"/>
			<meta>
				<m n=":value"><e>cast 50</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</WEBHOOK_CREATE>
		<WEBHOOK_UPDATE public="1" get="inline" set="null" expr="cast 51" line="41" static="1">
			<x path="com.raidandfade.haxicord.types.structs.AuditLogEvent"/>
			<meta>
				<m n=":value"><e>cast 51</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</WEBHOOK_UPDATE>
		<WEBHOOK_DELETE public="1" get="inline" set="null" expr="cast 52" line="42" static="1">
			<x path="com.raidandfade.haxicord.types.structs.AuditLogEvent"/>
			<meta>
				<m n=":value"><e>cast 52</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</WEBHOOK_DELETE>
		<EMOJI_CREATE public="1" get="inline" set="null" expr="cast 60" line="43" static="1">
			<x path="com.raidandfade.haxicord.types.structs.AuditLogEvent"/>
			<meta>
				<m n=":value"><e>cast 60</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</EMOJI_CREATE>
		<EMOJI_UPDATE public="1" get="inline" set="null" expr="cast 61" line="44" static="1">
			<x path="com.raidandfade.haxicord.types.structs.AuditLogEvent"/>
			<meta>
				<m n=":value"><e>cast 61</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</EMOJI_UPDATE>
		<EMOJI_DELETE public="1" get="inline" set="null" expr="cast 62" line="45" static="1">
			<x path="com.raidandfade.haxicord.types.structs.AuditLogEvent"/>
			<meta>
				<m n=":value"><e>cast 62</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</EMOJI_DELETE>
		<MESSAGE_DELETE public="1" get="inline" set="null" expr="cast 72" line="46" static="1">
			<x path="com.raidandfade.haxicord.types.structs.AuditLogEvent"/>
			<meta>
				<m n=":value"><e>cast 72</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</MESSAGE_DELETE>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<typedef path="com.raidandfade.haxicord.types.structs.AuditLogOptionalEntryInfo" params="" file="src/com/raidandfade/haxicord/types/structs/AuditLog.hx" module="com.raidandfade.haxicord.types.structs.AuditLog"><a>
	<type>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</type>
	<role_name>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</role_name>
	<members_removed>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</members_removed>
	<id>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</id>
	<delete_member_days>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</delete_member_days>
	<count>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</count>
	<channel_id>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</channel_id>
</a></typedef>
	<typedef path="com.raidandfade.haxicord.types.structs.AuditLogChange" params="" file="src/com/raidandfade/haxicord/types/structs/AuditLog.hx" module="com.raidandfade.haxicord.types.structs.AuditLog"><a>
	<old_value>
		<t path="Null"><d/></t>
		<meta><m n=":optional"/></meta>
	</old_value>
	<new_value>
		<t path="Null"><d/></t>
		<meta><m n=":optional"/></meta>
	</new_value>
	<key>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</key>
</a></typedef>
	<typedef path="com.raidandfade.haxicord.types.structs.Channel" params="" file="src/com/raidandfade/haxicord/types/structs/Channel.hx"><a>
	<type><x path="Int"/></type>
	<id><c path="String"/></id>
</a></typedef>
	<typedef path="com.raidandfade.haxicord.types.structs.Connection" params="" file="src/com/raidandfade/haxicord/types/structs/Connection.hx"><a>
	<type><c path="String"/></type>
	<revoked><x path="Bool"/></revoked>
	<name><c path="String"/></name>
	<integrations><c path="Array"><t path="com.raidandfade.haxicord.types.structs.GuildIntegration"/></c></integrations>
	<id><c path="String"/></id>
</a></typedef>
	<typedef path="com.raidandfade.haxicord.types.structs.DMChannel" params="" file="src/com/raidandfade/haxicord/types/structs/DMChannel.hx"><a>
	<type><x path="Int"/></type>
	<recipients>
		<t path="Null"><c path="Array"><t path="com.raidandfade.haxicord.types.structs.User"/></c></t>
		<meta><m n=":optional"/></meta>
	</recipients>
	<recipient>
		<t path="Null"><t path="com.raidandfade.haxicord.types.structs.User"/></t>
		<meta><m n=":optional"/></meta>
	</recipient>
	<last_message_id>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</last_message_id>
	<id><c path="String"/></id>
</a></typedef>
	<typedef path="com.raidandfade.haxicord.types.structs.Embed" params="" file="src/com/raidandfade/haxicord/types/structs/Embed.hx"><a>
	<video>
		<t path="Null"><t path="com.raidandfade.haxicord.types.structs.EmbedVideo"/></t>
		<meta><m n=":optional"/></meta>
	</video>
	<url>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</url>
	<type>
		<t path="Null"><c path="String"/></t>
		<meta>
			<m n=":optional"/>
			<m n="serverSide"/>
		</meta>
	</type>
	<title>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</title>
	<timestamp>
		<t path="Null"><c path="Date"/></t>
		<meta>
			<m n=":optional"/>
			<m n="serverSide"/>
		</meta>
	</timestamp>
	<thumbnail>
		<t path="Null"><t path="com.raidandfade.haxicord.types.structs.EmbedThumbnail"/></t>
		<meta><m n=":optional"/></meta>
	</thumbnail>
	<provider>
		<t path="Null"><t path="com.raidandfade.haxicord.types.structs.EmbedProvider"/></t>
		<meta><m n=":optional"/></meta>
	</provider>
	<image>
		<t path="Null"><t path="com.raidandfade.haxicord.types.structs.EmbedImage"/></t>
		<meta><m n=":optional"/></meta>
	</image>
	<footer>
		<t path="Null"><t path="com.raidandfade.haxicord.types.structs.EmbedFooter"/></t>
		<meta><m n=":optional"/></meta>
	</footer>
	<fields>
		<t path="Null"><c path="Array"><t path="com.raidandfade.haxicord.types.structs.EmbedField"/></c></t>
		<meta><m n=":optional"/></meta>
	</fields>
	<description>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</description>
	<color>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</color>
	<author>
		<t path="Null"><t path="com.raidandfade.haxicord.types.structs.EmbedAuthor"/></t>
		<meta><m n=":optional"/></meta>
	</author>
</a></typedef>
	<typedef path="com.raidandfade.haxicord.types.structs.EmbedFooter" params="" file="src/com/raidandfade/haxicord/types/structs/Embed.hx" module="com.raidandfade.haxicord.types.structs.Embed"><a>
	<text>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</text>
	<proxy_icon_url>
		<t path="Null"><c path="String"/></t>
		<meta>
			<m n=":optional"/>
			<m n="serverSide"/>
		</meta>
	</proxy_icon_url>
	<icon_url>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</icon_url>
</a></typedef>
	<typedef path="com.raidandfade.haxicord.types.structs.EmbedImage" params="" file="src/com/raidandfade/haxicord/types/structs/Embed.hx" module="com.raidandfade.haxicord.types.structs.Embed"><a>
	<width>
		<t path="Null"><x path="Int"/></t>
		<meta>
			<m n=":optional"/>
			<m n="serverSide"/>
		</meta>
	</width>
	<url>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</url>
	<proxy_url>
		<t path="Null"><c path="String"/></t>
		<meta>
			<m n=":optional"/>
			<m n="serverSide"/>
		</meta>
	</proxy_url>
	<height>
		<t path="Null"><x path="Int"/></t>
		<meta>
			<m n=":optional"/>
			<m n="serverSide"/>
		</meta>
	</height>
</a></typedef>
	<typedef path="com.raidandfade.haxicord.types.structs.EmbedThumbnail" params="" file="src/com/raidandfade/haxicord/types/structs/Embed.hx" module="com.raidandfade.haxicord.types.structs.Embed"><a>
	<width>
		<t path="Null"><x path="Int"/></t>
		<meta>
			<m n=":optional"/>
			<m n="serverSide"/>
		</meta>
	</width>
	<url>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</url>
	<proxy_url>
		<t path="Null"><c path="String"/></t>
		<meta>
			<m n=":optional"/>
			<m n="serverSide"/>
		</meta>
	</proxy_url>
	<height>
		<t path="Null"><x path="Int"/></t>
		<meta>
			<m n=":optional"/>
			<m n="serverSide"/>
		</meta>
	</height>
</a></typedef>
	<typedef path="com.raidandfade.haxicord.types.structs.EmbedVideo" params="" file="src/com/raidandfade/haxicord/types/structs/Embed.hx" module="com.raidandfade.haxicord.types.structs.Embed"><a>
	<width>
		<t path="Null"><x path="Int"/></t>
		<meta>
			<m n=":optional"/>
			<m n="serverSide"/>
		</meta>
	</width>
	<url>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</url>
	<height>
		<t path="Null"><x path="Int"/></t>
		<meta>
			<m n=":optional"/>
			<m n="serverSide"/>
		</meta>
	</height>
</a></typedef>
	<typedef path="com.raidandfade.haxicord.types.structs.EmbedProvider" params="" file="src/com/raidandfade/haxicord/types/structs/Embed.hx" module="com.raidandfade.haxicord.types.structs.Embed"><a>
	<url>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</url>
	<name>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</name>
</a></typedef>
	<typedef path="com.raidandfade.haxicord.types.structs.EmbedAuthor" params="" file="src/com/raidandfade/haxicord/types/structs/Embed.hx" module="com.raidandfade.haxicord.types.structs.Embed"><a>
	<url>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</url>
	<proxy_icon_url>
		<t path="Null"><c path="String"/></t>
		<meta>
			<m n=":optional"/>
			<m n="serverSide"/>
		</meta>
	</proxy_icon_url>
	<name>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</name>
	<icon_url>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</icon_url>
</a></typedef>
	<typedef path="com.raidandfade.haxicord.types.structs.EmbedField" params="" file="src/com/raidandfade/haxicord/types/structs/Embed.hx" module="com.raidandfade.haxicord.types.structs.Embed"><a>
	<value>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</value>
	<name>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</name>
	<_inline>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</_inline>
</a></typedef>
	<typedef path="com.raidandfade.haxicord.types.structs.Emoji" params="" file="src/com/raidandfade/haxicord/types/structs/Emoji.hx"><a>
	<roles>
		<t path="Null"><c path="Array"><t path="com.raidandfade.haxicord.types.structs.Role"/></c></t>
		<meta><m n=":optional"/></meta>
	</roles>
	<require_colons>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</require_colons>
	<name><c path="String"/></name>
	<managed>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</managed>
	<id><c path="String"/></id>
</a></typedef>
	<typedef path="com.raidandfade.haxicord.types.structs.Guild" params="" file="src/com/raidandfade/haxicord/types/structs/Guild.hx"><a>
	<verification_level><x path="Int"/></verification_level>
	<unavailable>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</unavailable>
	<splash><c path="String"/></splash>
	<roles><c path="Array"><t path="com.raidandfade.haxicord.types.structs.Role"/></c></roles>
	<region><c path="String"/></region>
	<presences>
		<t path="Null"><c path="Array"><t path="com.raidandfade.haxicord.types.structs.Presence"/></c></t>
		<meta><m n=":optional"/></meta>
	</presences>
	<owner_id><c path="String"/></owner_id>
	<name><c path="String"/></name>
	<mfa_level><x path="Int"/></mfa_level>
	<members>
		<t path="Null"><c path="Array"><t path="com.raidandfade.haxicord.types.structs.GuildMember"/></c></t>
		<meta><m n=":optional"/></meta>
	</members>
	<member_count>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</member_count>
	<large>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</large>
	<joined_at>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</joined_at>
	<id><c path="String"/></id>
	<icon><c path="String"/></icon>
	<features><c path="Array"><c path="String"/></c></features>
	<explicit_content_filter><x path="Int"/></explicit_content_filter>
	<emojis><c path="Array"><t path="com.raidandfade.haxicord.types.structs.Emoji"/></c></emojis>
	<embed_enabled><x path="Bool"/></embed_enabled>
	<embed_channel_id><c path="String"/></embed_channel_id>
	<default_message_notifications><x path="Int"/></default_message_notifications>
	<channels>
		<t path="Null"><c path="Array"><t path="com.raidandfade.haxicord.types.structs.GuildChannelTypes"/></c></t>
		<meta><m n=":optional"/></meta>
	</channels>
	<afk_timeout><x path="Int"/></afk_timeout>
	<afk_channel_id><c path="String"/></afk_channel_id>
</a></typedef>
	<typedef path="com.raidandfade.haxicord.types.structs.Update" params="" file="src/com/raidandfade/haxicord/types/structs/Guild.hx" module="com.raidandfade.haxicord.types.structs.Guild"><a>
	<verification_level>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</verification_level>
	<unavailable>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</unavailable>
	<splash>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</splash>
	<roles>
		<t path="Null"><c path="Array"><t path="com.raidandfade.haxicord.types.structs.Role"/></c></t>
		<meta><m n=":optional"/></meta>
	</roles>
	<region>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</region>
	<presences>
		<t path="Null"><c path="Array"><t path="com.raidandfade.haxicord.types.structs.Presence"/></c></t>
		<meta><m n=":optional"/></meta>
	</presences>
	<owner_id>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</owner_id>
	<name>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</name>
	<mfa_level>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</mfa_level>
	<members>
		<t path="Null"><c path="Array"><t path="com.raidandfade.haxicord.types.structs.GuildMember"/></c></t>
		<meta><m n=":optional"/></meta>
	</members>
	<member_count>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</member_count>
	<large>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</large>
	<joined_at>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</joined_at>
	<id><c path="String"/></id>
	<icon>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</icon>
	<features>
		<t path="Null"><c path="Array"><c path="String"/></c></t>
		<meta><m n=":optional"/></meta>
	</features>
	<emojis>
		<t path="Null"><c path="Array"><t path="com.raidandfade.haxicord.types.structs.Emoji"/></c></t>
		<meta><m n=":optional"/></meta>
	</emojis>
	<embed_enabled>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</embed_enabled>
	<embed_channel_id>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</embed_channel_id>
	<default_message_notifications>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</default_message_notifications>
	<channels>
		<t path="Null"><c path="Array"><t path="com.raidandfade.haxicord.types.structs.GuildChannelTypes"/></c></t>
		<meta><m n=":optional"/></meta>
	</channels>
	<afk_timeout>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</afk_timeout>
	<afk_channel_id>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</afk_channel_id>
</a></typedef>
	<typedef path="com.raidandfade.haxicord.types.structs.GuildChannelTypes" params="" file="src/com/raidandfade/haxicord/types/structs/Guild.hx" module="com.raidandfade.haxicord.types.structs.Guild"><x path="haxe.extern.EitherType">
	<t path="com.raidandfade.haxicord.types.structs.TextChannel"/>
	<t path="com.raidandfade.haxicord.types.structs.VoiceChannel"/>
</x></typedef>
	<typedef path="com.raidandfade.haxicord.types.structs.GuildChannel" params="" file="src/com/raidandfade/haxicord/types/structs/GuildChannel.hx"><a>
	<type><x path="Int"/></type>
	<position>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</position>
	<permission_overwrites>
		<t path="Null"><c path="Array"><t path="com.raidandfade.haxicord.types.structs.Overwrite"/></c></t>
		<meta><m n=":optional"/></meta>
	</permission_overwrites>
	<parent_id>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</parent_id>
	<nsfw>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</nsfw>
	<name>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</name>
	<id><c path="String"/></id>
	<guild_id><c path="String"/></guild_id>
</a></typedef>
	<typedef path="com.raidandfade.haxicord.types.structs.TextChannel" params="" file="src/com/raidandfade/haxicord/types/structs/GuildChannel.hx" module="com.raidandfade.haxicord.types.structs.GuildChannel"><a>
	<type><x path="Int"/></type>
	<topic>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</topic>
	<position>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</position>
	<permission_overwrites>
		<t path="Null"><c path="Array"><t path="com.raidandfade.haxicord.types.structs.Overwrite"/></c></t>
		<meta><m n=":optional"/></meta>
	</permission_overwrites>
	<parent_id>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</parent_id>
	<nsfw>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</nsfw>
	<name>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</name>
	<last_message_id>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</last_message_id>
	<id><c path="String"/></id>
	<guild_id><c path="String"/></guild_id>
</a></typedef>
	<typedef path="com.raidandfade.haxicord.types.structs.VoiceChannel" params="" file="src/com/raidandfade/haxicord/types/structs/GuildChannel.hx" module="com.raidandfade.haxicord.types.structs.GuildChannel"><a>
	<user_limit>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</user_limit>
	<type><x path="Int"/></type>
	<position>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</position>
	<permission_overwrites>
		<t path="Null"><c path="Array"><t path="com.raidandfade.haxicord.types.structs.Overwrite"/></c></t>
		<meta><m n=":optional"/></meta>
	</permission_overwrites>
	<parent_id>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</parent_id>
	<nsfw>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</nsfw>
	<name>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</name>
	<id><c path="String"/></id>
	<guild_id><c path="String"/></guild_id>
	<bitrate>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</bitrate>
</a></typedef>
	<enum path="com.raidandfade.haxicord.types.structs.OverwriteType" params="" file="src/com/raidandfade/haxicord/types/structs/GuildChannel.hx" module="com.raidandfade.haxicord.types.structs.GuildChannel">
		<Role/>
		<Member/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<typedef path="com.raidandfade.haxicord.types.structs.Overwrite" params="" file="src/com/raidandfade/haxicord/types/structs/GuildChannel.hx" module="com.raidandfade.haxicord.types.structs.GuildChannel"><a>
	<type><e path="com.raidandfade.haxicord.types.structs.OverwriteType"/></type>
	<id><x path="Int"/></id>
	<deny><x path="Int"/></deny>
	<allow><x path="Int"/></allow>
</a></typedef>
	<typedef path="com.raidandfade.haxicord.types.structs.GuildEmbed" params="" file="src/com/raidandfade/haxicord/types/structs/GuildEmbed.hx"><a>
	<enabled><x path="Bool"/></enabled>
	<channel_id><c path="String"/></channel_id>
</a></typedef>
	<typedef path="com.raidandfade.haxicord.types.structs.GuildIntegration" params="" file="src/com/raidandfade/haxicord/types/structs/GuildIntegration.hx"><a>
	<user><t path="com.raidandfade.haxicord.types.structs.User"/></user>
	<type><c path="String"/></type>
	<syncing><x path="Bool"/></syncing>
	<synced_at><x path="Float"/></synced_at>
	<role_id><c path="String"/></role_id>
	<name><c path="String"/></name>
	<id><c path="String"/></id>
	<expire_grace_period><x path="Int"/></expire_grace_period>
	<expire_behavior><x path="Int"/></expire_behavior>
	<enabled><x path="Bool"/></enabled>
	<account><t path="com.raidandfade.haxicord.types.structs.IntegrationAccount"/></account>
</a></typedef>
	<typedef path="com.raidandfade.haxicord.types.structs.IntegrationAccount" params="" file="src/com/raidandfade/haxicord/types/structs/GuildIntegration.hx" module="com.raidandfade.haxicord.types.structs.GuildIntegration"><a>
	<name><c path="String"/></name>
	<id><c path="String"/></id>
</a></typedef>
	<typedef path="com.raidandfade.haxicord.types.structs.GuildMember" params="" file="src/com/raidandfade/haxicord/types/structs/GuildMember.hx"><a>
	<user><t path="com.raidandfade.haxicord.types.structs.User"/></user>
	<roles><c path="Array"><c path="String"/></c></roles>
	<nick><t path="Null"><c path="String"/></t></nick>
	<mute>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</mute>
	<joined_at>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</joined_at>
	<guild_id>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</guild_id>
	<deaf>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</deaf>
</a></typedef>
	<typedef path="com.raidandfade.haxicord.types.structs.Invite" params="" file="src/com/raidandfade/haxicord/types/structs/Invite.hx"><a>
	<guild><t path="com.raidandfade.haxicord.types.structs.InviteGuild"/></guild>
	<code><c path="String"/></code>
	<channel><t path="com.raidandfade.haxicord.types.structs.InviteChannel"/></channel>
	<approximate_presence_count>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</approximate_presence_count>
	<approximate_member_count>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</approximate_member_count>
</a></typedef>
	<typedef path="com.raidandfade.haxicord.types.structs.InviteGuild" params="" file="src/com/raidandfade/haxicord/types/structs/Invite.hx" module="com.raidandfade.haxicord.types.structs.Invite"><a>
	<voice_channel_count>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</voice_channel_count>
	<text_channel_count>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</text_channel_count>
	<spash><c path="String"/></spash>
	<name><c path="String"/></name>
	<id><c path="com.raidandfade.haxicord.types.Snowflake"/></id>
	<icon><c path="String"/></icon>
</a></typedef>
	<typedef path="com.raidandfade.haxicord.types.structs.InviteChannel" params="" file="src/com/raidandfade/haxicord/types/structs/Invite.hx" module="com.raidandfade.haxicord.types.structs.Invite"><a>
	<type><x path="Int"/></type>
	<name><c path="String"/></name>
	<id><c path="String"/></id>
</a></typedef>
	<typedef path="com.raidandfade.haxicord.types.structs.MessageStruct" params="" file="src/com/raidandfade/haxicord/types/structs/MessageStruct.hx"><a>
	<webhook_id>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</webhook_id>
	<tts>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</tts>
	<timestamp>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</timestamp>
	<reactions>
		<t path="Null"><c path="Array"><t path="com.raidandfade.haxicord.types.structs.Reaction"/></c></t>
		<meta><m n=":optional"/></meta>
	</reactions>
	<pinned>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</pinned>
	<nonce>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</nonce>
	<mentions>
		<t path="Null"><c path="Array"><t path="com.raidandfade.haxicord.types.structs.User"/></c></t>
		<meta><m n=":optional"/></meta>
	</mentions>
	<mention_roles>
		<t path="Null"><c path="Array"><t path="com.raidandfade.haxicord.types.structs.Role"/></c></t>
		<meta><m n=":optional"/></meta>
	</mention_roles>
	<mention_everyone>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</mention_everyone>
	<id><c path="String"/></id>
	<embeds>
		<t path="Null"><c path="Array"><t path="com.raidandfade.haxicord.types.structs.Embed"/></c></t>
		<meta><m n=":optional"/></meta>
	</embeds>
	<edited_timestamp>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</edited_timestamp>
	<content>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</content>
	<channel_id><c path="String"/></channel_id>
	<author>
		<t path="Null"><t path="com.raidandfade.haxicord.types.structs.User"/></t>
		<meta><m n=":optional"/></meta>
	</author>
	<attachments>
		<t path="Null"><c path="Array"><t path="com.raidandfade.haxicord.types.structs.Attachment"/></c></t>
		<meta><m n=":optional"/></meta>
	</attachments>
</a></typedef>
	<typedef path="com.raidandfade.haxicord.types.structs.Attachment" params="" file="src/com/raidandfade/haxicord/types/structs/MessageStruct.hx" module="com.raidandfade.haxicord.types.structs.MessageStruct"><a>
	<width><x path="Int"/></width>
	<url><c path="String"/></url>
	<size><x path="Int"/></size>
	<proxy_url><c path="String"/></proxy_url>
	<id><c path="String"/></id>
	<height><x path="Int"/></height>
	<filename><c path="String"/></filename>
</a></typedef>
	<typedef path="com.raidandfade.haxicord.types.structs.Reaction" params="" file="src/com/raidandfade/haxicord/types/structs/MessageStruct.hx" module="com.raidandfade.haxicord.types.structs.MessageStruct"><a>
	<who>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</who>
	<me>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</me>
	<emoji><t path="com.raidandfade.haxicord.types.structs.Emoji"/></emoji>
	<count>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</count>
</a></typedef>
	<typedef path="com.raidandfade.haxicord.types.structs.Presence" params="" file="src/com/raidandfade/haxicord/types/structs/Presence.hx"><a>
	<user>
		<t path="Null"><t path="com.raidandfade.haxicord.types.structs.User"/></t>
		<meta><m n=":optional"/></meta>
	</user>
	<status>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</status>
	<roles>
		<t path="Null"><c path="Array"><c path="String"/></c></t>
		<meta><m n=":optional"/></meta>
	</roles>
	<nick>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</nick>
	<idle_since>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</idle_since>
	<guild_id>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</guild_id>
	<game>
		<t path="Null"><t path="com.raidandfade.haxicord.types.structs.PresenceGame"/></t>
		<meta><m n=":optional"/></meta>
	</game>
</a></typedef>
	<typedef path="com.raidandfade.haxicord.types.structs.PresenceGame" params="" file="src/com/raidandfade/haxicord/types/structs/Presence.hx" module="com.raidandfade.haxicord.types.structs.Presence"><a><name><c path="String"/></name></a></typedef>
	<typedef path="com.raidandfade.haxicord.types.structs.Role" params="" file="src/com/raidandfade/haxicord/types/structs/Role.hx"><a>
	<position>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</position>
	<permissions>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</permissions>
	<name><c path="String"/></name>
	<mentionable>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</mentionable>
	<managed>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</managed>
	<id><c path="String"/></id>
	<hoist>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</hoist>
	<color>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</color>
</a></typedef>
	<typedef path="com.raidandfade.haxicord.types.structs.User" params="" file="src/com/raidandfade/haxicord/types/structs/User.hx"><a>
	<verified>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</verified>
	<username><c path="String"/></username>
	<mfa_enabled>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</mfa_enabled>
	<id><c path="String"/></id>
	<guild_id>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</guild_id>
	<email>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</email>
	<discriminator>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</discriminator>
	<bot>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</bot>
	<avatar>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</avatar>
</a></typedef>
	<typedef path="com.raidandfade.haxicord.types.structs.VoiceState" params="" file="src/com/raidandfade/haxicord/types/structs/Voice.hx" module="com.raidandfade.haxicord.types.structs.Voice"><a>
	<user_id><c path="String"/></user_id>
	<suppress><x path="Bool"/></suppress>
	<session_id><c path="String"/></session_id>
	<self_mute><x path="Bool"/></self_mute>
	<self_deaf><x path="Bool"/></self_deaf>
	<mute><x path="Bool"/></mute>
	<guild_id><c path="String"/></guild_id>
	<deaf><x path="Bool"/></deaf>
	<channel_id><c path="String"/></channel_id>
</a></typedef>
	<typedef path="com.raidandfade.haxicord.types.structs.VoiceRegion" params="" file="src/com/raidandfade/haxicord/types/structs/Voice.hx" module="com.raidandfade.haxicord.types.structs.Voice"><a>
	<vip><x path="Bool"/></vip>
	<sample_port><x path="Int"/></sample_port>
	<sample_hostname><c path="String"/></sample_hostname>
	<optimal><x path="Bool"/></optimal>
	<name><c path="String"/></name>
	<id><c path="String"/></id>
	<deprecated><x path="Bool"/></deprecated>
	<custom><x path="Bool"/></custom>
</a></typedef>
	<typedef path="com.raidandfade.haxicord.types.structs.Webhook" params="" file="src/com/raidandfade/haxicord/types/structs/Webhook.hx"><a>
	<user>
		<t path="Null"><t path="com.raidandfade.haxicord.types.structs.User"/></t>
		<meta><m n=":optional"/></meta>
	</user>
	<token>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</token>
	<name>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</name>
	<id><c path="String"/></id>
	<guild_id><c path="String"/></guild_id>
	<channel_id><c path="String"/></channel_id>
	<avatar>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</avatar>
</a></typedef>
	<class path="com.raidandfade.haxicord.websocket.WebSocketConnection" params="" file="src/com/raidandfade/haxicord/websocket/WebSocketConnection.hx">
		<ws static="1"><c path="haxe.net.WebSocket"/></ws>
		<host static="1"><c path="String"/></host>
		<queue expr="new Array&lt;String&gt;()">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e><![CDATA[new Array<String>()]]></e></m></meta>
		</queue>
		<ready expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</ready>
		<create set="method" line="39">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</create>
		<sendJson public="1" set="method" line="85">
			<f a="d">
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>Send any object as json.
        @param d - The object to send.</haxe_doc>
		</sendJson>
		<send public="1" set="method" line="93">
			<f a="m">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Send a raw string as a message.
        @param m - The string to send.</haxe_doc>
		</send>
		<_onClose set="method" line="106"><f a=""><x path="Void"/></f></_onClose>
		<onClose public="1" set="dynamic" line="114">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Event listener for when the socket is closed</haxe_doc>
		</onClose>
		<onReady public="1" set="dynamic" line="119">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Event listener for when the socket is open and connected</haxe_doc>
		</onReady>
		<onError public="1" set="dynamic" line="125">
			<f a="s">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event listener for when the socket errors
        @param s - The error.</haxe_doc>
		</onError>
		<onMessage public="1" set="dynamic" line="131">
			<f a="m">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Event listener for when a message is received
        @param m - The message recieved;</haxe_doc>
		</onMessage>
		<new public="1" set="method" line="22">
			<f a="_host">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Connect to the given host (works for wss and ws)
        @param _host - The url of the host</haxe_doc>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="haxe.StackItem" params="" file="/usr/lib/haxe/std/haxe/CallStack.hx" module="haxe.CallStack">
		<CFunction/>
		<Module a="m"><c path="String"/></Module>
		<FilePos a="s:file:line">
			<t path="Null"><e path="haxe.StackItem"/></t>
			<c path="String"/>
			<x path="Int"/>
		</FilePos>
		<Method a="classname:method">
			<c path="String"/>
			<c path="String"/>
		</Method>
		<LocalFunction a="?v"><x path="Int"/></LocalFunction>
		<haxe_doc>Elements return by `CallStack` methods.</haxe_doc>
	</enum>
	<class path="haxe.CallStack" params="" file="/usr/lib/haxe/std/haxe/CallStack.hx">
		<callStack public="1" set="method" line="77" static="1">
			<f a=""><c path="Array"><e path="haxe.StackItem"/></c></f>
			<haxe_doc>Return the call stack elements, or an empty array if not available.</haxe_doc>
		</callStack>
		<exceptionStack public="1" set="method" line="163" static="1">
			<f a=""><c path="Array"><e path="haxe.StackItem"/></c></f>
			<haxe_doc>Return the exception stack : this is the stack elements between
		the place the last exception was thrown and the place it was
		caught, or an empty array if not available.</haxe_doc>
		</exceptionStack>
		<toString public="1" set="method" line="231" static="1">
			<f a="stack">
				<c path="Array"><e path="haxe.StackItem"/></c>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a representation of the stack as a printable string.</haxe_doc>
		</toString>
		<itemToString set="method" line="240" static="1"><f a="b:s">
	<c path="StringBuf"/>
	<e path="haxe.StackItem"/>
	<x path="Void"/>
</f></itemToString>
		<haxe_doc>Get information about the call stack.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<abstract path="haxe.Function" params="" file="/usr/lib/haxe/std/haxe/Constraints.hx" module="haxe.Constraints">
		<this><d/></this>
		<haxe_doc>This type unifies with any function type.

	It is intended to be used as a type parameter constraint. If used as a real
	type, the underlying type will be `Dynamic`.</haxe_doc>
		<meta><m n=":callable"/></meta>
		<impl><class path="haxe._Constraints.Function_Impl_" params="" file="/usr/lib/haxe/std/haxe/Constraints.hx" private="1" module="haxe.Constraints"><meta>
	<m n=":keep"/>
	<m n=":final"/>
</meta></class></impl>
	</abstract>
	<abstract path="haxe.FlatEnum" params="" file="/usr/lib/haxe/std/haxe/Constraints.hx" module="haxe.Constraints">
		<this><d/></this>
		<haxe_doc>This type unifies with an enum instance if all constructors of the enum
	require no arguments.

	It is intended to be used as a type parameter constraint. If used as a real
	type, the underlying type will be `Dynamic`.</haxe_doc>
		<impl><class path="haxe._Constraints.FlatEnum_Impl_" params="" file="/usr/lib/haxe/std/haxe/Constraints.hx" private="1" module="haxe.Constraints"><meta>
	<m n=":keep"/>
	<m n=":final"/>
</meta></class></impl>
	</abstract>
	<abstract path="haxe.Constructible" params="T" file="/usr/lib/haxe/std/haxe/Constraints.hx" module="haxe.Constraints">
		<this><d/></this>
		<haxe_doc><![CDATA[This type unifies with any instance of classes that have a constructor
	which
		* is public and
		* unifies with the type used for type parameter `T`.

	If a type parameter A is assigned to a type parameter B which is constrained
	to `Constructible<T>`, A must be explicitly constrained to
	`Constructible<T>` as well.

	It is intended to be used as a type parameter constraint. If used as a real
	type, the underlying type will be `Dynamic`.]]></haxe_doc>
		<impl><class path="haxe._Constraints.Constructible_Impl_" params="" file="/usr/lib/haxe/std/haxe/Constraints.hx" private="1" module="haxe.Constraints"><meta>
	<m n=":keep"/>
	<m n=":final"/>
</meta></class></impl>
	</abstract>
	<class path="haxe.IMap" params="K:V" file="/usr/lib/haxe/std/haxe/Constraints.hx" module="haxe.Constraints" interface="1">
		<remove public="1" set="method"><f a="k">
	<c path="haxe.IMap.K"/>
	<x path="Bool"/>
</f></remove>
		<iterator public="1" set="method"><f a=""><t path="Iterator"><c path="haxe.IMap.V"/></t></f></iterator>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="haxe.DateUtils" params="" file="src/haxe/DateUtils.hx">
		<fromISO8601 public="1" set="method" line="6" static="1"><f a="iso">
	<c path="String"/>
	<c path="Date"/>
</f></fromISO8601>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="haxe._EntryPoint.Lock" params="" file="/usr/lib/haxe/std/haxe/EntryPoint.hx" private="1" module="haxe.EntryPoint">
		<new public="1" set="method" line="17"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe._EntryPoint.Mutex" params="" file="/usr/lib/haxe/std/haxe/EntryPoint.hx" private="1" module="haxe.EntryPoint">
		<new public="1" set="method" line="25"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.EntryPoint" params="" file="/usr/lib/haxe/std/haxe/EntryPoint.hx">
		<sleepLock expr="new Lock()" line="46" static="1">
			<c path="haxe._EntryPoint.Lock"/>
			<meta><m n=":value"><e>new Lock()</e></m></meta>
		</sleepLock>
		<mutex expr="new Mutex()" line="47" static="1">
			<c path="haxe._EntryPoint.Mutex"/>
			<meta><m n=":value"><e>new Mutex()</e></m></meta>
		</mutex>
		<pending expr="new Array&lt;Void&gt;()" line="49" static="1">
			<c path="Array"><f a=""><x path="Void"/></f></c>
			<meta><m n=":value"><e><![CDATA[new Array<Void>()]]></e></m></meta>
		</pending>
		<threadCount public="1" set="null" expr="0" line="51" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</threadCount>
		<processEvents set="method" line="91" static="1"><f a=""><x path="Float"/></f></processEvents>
		<run public="1" set="method" line="112" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>Start the main loop. Depending on the platform, this can return immediately or will only return when the application exits.</haxe_doc>
		</run>
		<haxe_doc>If haxe.MainLoop is kept from DCE, then we will insert an haxe.EntryPoint.run() call just at then end of main().
	This class can be redefined by custom frameworks so they can handle their own main loop logic.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.EnumTools" params="" file="/usr/lib/haxe/std/haxe/EnumTools.hx" extern="1">
		<getName public="1" params="T" get="inline" set="null" line="50" static="1">
			<f a="e">
				<x path="Enum"><c path="getName.T"/></x>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the name of enum `e`, including its path.

		If `e` is inside a package, the package structure is returned dot-
		separated, with another dot separating the enum name:
			pack1.pack2.(...).packN.EnumName
		If `e` is a sub-type of a Haxe module, that module is not part of the
		package structure.

		If `e` has no package, the enum name is returned.

		If `e` is `null`, the result is unspecified.

		The enum name does not include any type parameters.</haxe_doc>
		</getName>
		<createByName public="1" params="T" get="inline" set="null" line="63" static="1">
			<f a="e:constr:?params">
				<x path="Enum"><c path="createByName.T"/></x>
				<c path="String"/>
				<c path="Array"><d/></c>
				<c path="createByName.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor `constr` with
		arguments `params`.

		If `e` or `constr` is `null`, or if enum `e` has no constructor named
		`constr`, or if the number of elements in `params` does not match the
		expected number of constructor arguments, or if any argument has an
		invalid type, the result is unspecified.</haxe_doc>
		</createByName>
		<createByIndex public="1" params="T" get="inline" set="null" line="79" static="1">
			<f a="e:index:?params">
				<x path="Enum"><c path="createByIndex.T"/></x>
				<x path="Int"/>
				<c path="Array"><d/></c>
				<c path="createByIndex.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor number
		`index` with arguments `params`.

		The constructor indices are preserved from Haxe syntax, so the first
		declared is index 0, the next index 1 etc.

		If `e` or `index` is `null`, or if enum `e` has no constructor
		corresponding to index `index`, or if the number of elements in `params`
		does not match the expected number of constructor arguments, or if any
		argument has an invalid type, the result is unspecified.</haxe_doc>
		</createByIndex>
		<createAll public="1" params="T" get="inline" set="null" line="96" static="1">
			<f a="e">
				<x path="Enum"><c path="createAll.T"/></x>
				<c path="Array"><c path="createAll.T"/></c>
			</f>
			<haxe_doc>Returns a list of all constructors of enum `e` that require no
		arguments.

		This may return the empty Array `[]` if all constructors of `e` require
		arguments.

		Otherwise an instance of `e` constructed through each of its non-
		argument constructors is returned, in the order of the constructor
		declaration.

		If `e` is `null`, the result is unspecified.</haxe_doc>
		</createAll>
		<getConstructors public="1" params="T" get="inline" set="null" line="108" static="1">
			<f a="e">
				<x path="Enum"><c path="getConstructors.T"/></x>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns a list of the names of all constructors of enum `e`.

		The order of the constructor names in the returned Array is preserved
		from the original syntax.

		If `c` is `null`, the result is unspecified.</haxe_doc>
		</getConstructors>
		<haxe_doc>This class provides advanced methods on enums. It is ideally used with
	`using EnumTools` and then acts as an 
  [extension](https://haxe.org/manual/lf-static-extension.html) to the 
  `enum` types.

	If the first argument to any of the methods is null, the result is
	unspecified.</haxe_doc>
	</class>
	<class path="haxe.EnumValueTools" params="" file="/usr/lib/haxe/std/haxe/EnumTools.hx" module="haxe.EnumTools" extern="1">
		<equals public="1" params="T" get="inline" set="null" line="132" static="1">
			<f a="a:b">
				<c path="equals.T"/>
				<c path="equals.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Recursively compares two enum instances `a` and `b` by value.

		Unlike `a == b`, this function performs a deep equality check on the
		arguments of the constructors (if there are any).

		If `a` or `b` are `null`, the result is unspecified.</haxe_doc>
		</equals>
		<getName public="1" get="inline" set="null" line="143" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the constructor name of enum instance `e`.

		The result String does not contain any constructor arguments.

		If `e` is `null`, the result is unspecified.</haxe_doc>
		</getName>
		<getParameters public="1" get="inline" set="null" line="157" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="Array"><d/></c>
			</f>
			<haxe_doc>Returns a list of the constructor arguments of enum instance `e`.

		If `e` has no arguments, the result is `[]`.

		Otherwise the result are the values that were used as arguments to `e`,
		in the order of their declaration.

		If `e` is `null`, the result is unspecified.</haxe_doc>
		</getParameters>
		<getIndex public="1" get="inline" set="null" line="169" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the index of enum instance `e`.

		This corresponds to the original syntactic position of `e`. The index of
		the first declared constructor is 0, the next one is 1 etc.

		If `e` is `null`, the result is unspecified.</haxe_doc>
		</getIndex>
		<match public="1" set="method" static="1">
			<f a="e:pattern">
				<x path="EnumValue"/>
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Matches enum instance `e` against pattern `pattern`, returning `true` if
		matching succeeded and `false` otherwise.

		Example usage:

		```haxe
		if (e.match(pattern)) {
			// codeIfTrue
		} else {
			// codeIfFalse
		}
		```

		This is equivalent to the following code:

		```haxe
		switch (e) {
			case pattern:
				// codeIfTrue
			case _:
				// codeIfFalse
		}
		```

		This method is implemented in the compiler. This definition exists only
		for documentation.</haxe_doc>
		</match>
		<haxe_doc>This class provides advanced methods on enum values. It is ideally used with
	`using EnumValueTools` and then acts as an 
  [extension](https://haxe.org/manual/lf-static-extension.html) to the 
  `EnumValue` types.

	If the first argument to any of the methods is null, the result is
	unspecified.</haxe_doc>
	</class>
	<class path="haxe.Http" params="" file="src/haxe/Http.hx">
		<PROXY public="1" expr="null" line="66" static="1">
			<a>
				<port><x path="Int"/></port>
				<host><c path="String"/></host>
				<auth><a>
	<user><c path="String"/></user>
	<pass><c path="String"/></pass>
</a></auth>
			</a>
			<meta><m n=":value"><e>null</e></m></meta>
		</PROXY>
		<requestUrl public="1" set="method" line="832" static="1">
			<f a="url">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Makes a synchronous request to `url`.

		This creates a new Http instance and makes a GET request by calling its
		`request(false)` method.

		If `url` is null, the result is unspecified.</haxe_doc>
		</requestUrl>
		<url public="1">
			<c path="String"/>
			<haxe_doc>The url of `this` request. It is used only by the `request()` method and
		can be changed in order to send the same request to different target
		Urls.</haxe_doc>
		</url>
		<responseData public="1" set="null"><t path="Null"><c path="String"/></t></responseData>
		<noShutdown public="1"><x path="Bool"/></noShutdown>
		<cnxTimeout public="1"><x path="Float"/></cnxTimeout>
		<responseHeaders public="1"><x path="Map">
	<c path="String"/>
	<c path="String"/>
</x></responseHeaders>
		<chunk_size><t path="Null"><x path="Int"/></t></chunk_size>
		<chunk_buf><c path="haxe.io.Bytes"/></chunk_buf>
		<file><a>
	<size><x path="Int"/></size>
	<param><c path="String"/></param>
	<mimeType><c path="String"/></mimeType>
	<io><c path="haxe.io.Input"/></io>
	<filename><c path="String"/></filename>
</a></file>
		<postData><c path="String"/></postData>
		<headers><c path="List"><a>
	<value><c path="String"/></value>
	<header><c path="String"/></header>
</a></c></headers>
		<params><c path="List"><a>
	<value><c path="String"/></value>
	<param><c path="String"/></param>
</a></c></params>
		<setHeader public="1" set="method" line="103">
			<f a="header:value">
				<c path="String"/>
				<c path="String"/>
				<c path="haxe.Http"/>
			</f>
			<haxe_doc>Sets the header identified as `header` to value `value`.

		If `header` or `value` are null, the result is unspecified.

		This method provides a fluent interface.</haxe_doc>
		</setHeader>
		<addHeader public="1" set="method" line="109"><f a="header:value">
	<c path="String"/>
	<c path="String"/>
	<c path="haxe.Http"/>
</f></addHeader>
		<setParameter public="1" set="method" line="121">
			<f a="param:value">
				<c path="String"/>
				<c path="String"/>
				<c path="haxe.Http"/>
			</f>
			<haxe_doc>Sets the parameter identified as `param` to value `value`.

		If `header` or `value` are null, the result is unspecified.

		This method provides a fluent interface.</haxe_doc>
		</setParameter>
		<addParameter public="1" set="method" line="127"><f a="param:value">
	<c path="String"/>
	<c path="String"/>
	<c path="haxe.Http"/>
</f></addParameter>
		<setPostData public="1" set="method" line="142">
			<f a="data">
				<c path="String"/>
				<c path="haxe.Http"/>
			</f>
			<haxe_doc>Sets the post data of `this` Http request to `data`.

		There can only be one post data per request. Subsequent calls overwrite
		the previously set value.

		If `data` is null, the post data is considered to be absent.

		This method provides a fluent interface.</haxe_doc>
		</setPostData>
		<request public="1" set="method" line="190">
			<f a="?post">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sends `this` Http request to the Url specified by `this.url`.

		If `post` is true, the request is sent as POST request, otherwise it is
		sent as GET request.

		Depending on the outcome of the request, this method calls the
		`onStatus()`, `onError()` or `onData()` callback functions.

		If `this.url` is null, the result is unspecified.

		If `this.url` is an invalid or inaccessible Url, the `onError()` callback
		function is called.

		[js] If `this.async` is false, the callback functions are called before
		this method returns.</haxe_doc>
		</request>
		<fileTransfert public="1" get="inline" set="null" line="419">
			<f a="argname:filename:file:size:?mimeType" v="::::&quot;application/octet-stream&quot;">
				<c path="String"/>
				<c path="String"/>
				<c path="haxe.io.Input"/>
				<x path="Int"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ mimeType : "application/octet-stream" }</e></m>
				<m n=":noCompletion"/>
			</meta>
			<haxe_doc>Note: Deprecated in 4.0</haxe_doc>
		</fileTransfert>
		<fileTransfer public="1" set="method" line="423">
			<f a="argname:filename:file:size:?mimeType" v="::::&quot;application/octet-stream&quot;">
				<c path="String"/>
				<c path="String"/>
				<c path="haxe.io.Input"/>
				<x path="Int"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ mimeType : "application/octet-stream" }</e></m></meta>
		</fileTransfer>
		<customRequest public="1" set="method" line="427"><f a="post:api:?sock:?method">
	<x path="Bool"/>
	<c path="haxe.io.Output"/>
	<c path="sys.net.Socket"/>
	<c path="String"/>
	<x path="Void"/>
</f></customRequest>
		<readHttpResponse set="method" line="588"><f a="api:sock">
	<c path="haxe.io.Output"/>
	<c path="sys.net.Socket"/>
	<x path="Void"/>
</f></readHttpResponse>
		<readChunk set="method" line="734"><f a="chunk_re:api:buf:len">
	<c path="EReg"/>
	<c path="haxe.io.Output"/>
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></readChunk>
		<onData public="1" set="dynamic" line="800">
			<f a="data">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>This method is called upon a successful request, with `data` containing
		the result String.

		The intended usage is to bind it to a custom function:
		`httpInstance.onData = function(data) { // handle result }`</haxe_doc>
		</onData>
		<onError public="1" set="dynamic" line="810">
			<f a="msg">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>This method is called upon a request error, with `msg` containing the
		error description.

		The intended usage is to bind it to a custom function:
		`httpInstance.onError = function(msg) { // handle error }`</haxe_doc>
		</onError>
		<onStatus public="1" set="dynamic" line="820">
			<f a="status">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>This method is called upon a Http status change, with `status` being the
		new status.

		The intended usage is to bind it to a custom function:
		`httpInstance.onStatus = function(status) { // handle status }`</haxe_doc>
		</onStatus>
		<new public="1" set="method" line="80">
			<f a="url">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new Http instance with `url` as parameter.

		This does not do a request until `request()` is called.

		If `url` is null, the field url must be set to a value before making the
		call to `request()`, or the result is unspecified.

		(Php) Https (SSL) connections are allowed only if the OpenSSL extension
		is enabled.</haxe_doc>
		</new>
		<haxe_doc>This class can be used to handle Http requests consistently across
	platforms. There are two intended usages:

	- call `haxe.Http.requestUrl(url)` and receive the result as a `String`
	(not available on flash)
	- create a `new haxe.Http(url)`, register your callbacks for `onData`,
	`onError` and `onStatus`, then call `request()`.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="haxe.Https" params="" file="src/haxe/Https.hx">
		<stringify public="1" set="method" line="51" static="1"><f a="d">
	<d/>
	<c path="String"/>
</f></stringify>
		<queryString public="1" set="method" line="55" static="1">
			<f a="datar:?startMark" v=":true">
				<a/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ startMark : true }</e></m></meta>
		</queryString>
		<makeRequest public="1" set="method" line="70" static="1">
			<f a="url:?method:?_callback:?_d:?_headers:?async" v=":&quot;GET&quot;:null:null:null:true">
				<c path="String"/>
				<c path="String"/>
				<f a=":">
					<d/>
					<x path="Map">
						<c path="String"/>
						<c path="String"/>
					</x>
					<x path="Void"/>
				</f>
				<d/>
				<x path="Map">
					<c path="String"/>
					<c path="String"/>
				</x>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ async : true, _headers : null, _d : null, _callback : null, method : "GET" }</e></m></meta>
		</makeRequest>
		<parseJson public="1" set="method" line="78" static="1">
			<f a="st:j:?forceError" v="::false">
				<x path="Int"/>
				<c path="String"/>
				<x path="Bool"/>
				<d/>
			</f>
			<meta><m n=":value"><e>{ forceError : false }</e></m></meta>
		</parseJson>
		<_makeRequest set="method" line="89" static="1">
			<f a="url:?method:?_callback:?_d:?_headers" v=":&quot;GET&quot;:null:null:null">
				<c path="String"/>
				<c path="String"/>
				<f a=":">
					<d/>
					<x path="Map">
						<c path="String"/>
						<c path="String"/>
					</x>
					<x path="Void"/>
				</f>
				<d/>
				<x path="Map">
					<c path="String"/>
					<c path="String"/>
				</x>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ _headers : null, _d : null, _callback : null, method : "GET" }</e></m></meta>
		</_makeRequest>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="haxe.Int32" params="" file="/usr/lib/haxe/std/haxe/Int32.hx">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to>
			<icast><x path="Int"/></icast>
			<icast field="toFloat"><x path="Float"/></icast>
		</to>
		<haxe_doc>Int32 provides a 32-bit integer with consistent overflow behavior across
 	all platforms.</haxe_doc>
		<impl><class path="haxe._Int32.Int32_Impl_" params="" file="/usr/lib/haxe/std/haxe/Int32.hx" private="1" module="haxe.Int32"><meta>
	<m n=":keep"/>
	<m n=":final"/>
</meta></class></impl>
	</abstract>
	<abstract path="haxe.Int64" params="" file="/usr/lib/haxe/std/haxe/Int64.hx">
		<from>
			<icast><t path="haxe._Int64.__Int64"/></icast>
			<icast field="ofInt"><x path="Int"/></icast>
		</from>
		<this><t path="haxe._Int64.__Int64"/></this>
		<to><icast><t path="haxe._Int64.__Int64"/></icast></to>
		<haxe_doc>A cross-platform signed 64-bit integer.
	Int64 instances can be created from two 32-bit words using `Int64.make()`.</haxe_doc>
		<impl><class path="haxe._Int64.Int64_Impl_" params="" file="/usr/lib/haxe/std/haxe/Int64.hx" private="1" module="haxe.Int64">
	<high public="1" get="accessor" set="null" static="1">
		<x path="haxe.Int32"/>
		<meta><m n=":impl"/></meta>
	</high>
	<low public="1" get="accessor" set="null" static="1">
		<x path="haxe.Int32"/>
		<meta><m n=":impl"/></meta>
	</low>
	<meta>
		<m n=":keep"/>
		<m n=":final"/>
	</meta>
</class></impl>
	</abstract>
	<typedef path="haxe._Int64.__Int64" params="" file="/usr/lib/haxe/std/haxe/Int64.hx" private="1" module="haxe.Int64">
		<c path="haxe._Int64.___Int64"/>
		<haxe_doc>* This typedef will fool @:coreApi into thinking that we are using
  * the same underlying type, even though it might be different on
  * specific platforms.</haxe_doc>
	</typedef>
	<class path="haxe.Log" params="" file="/usr/lib/haxe/std/haxe/Log.hx">
		<trace public="1" set="dynamic" line="47" static="1">
			<f a="v:?infos">
				<d/>
				<t path="haxe.PosInfos"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Outputs `v` in a platform-dependent way.

		The second parameter `infos` is injected by the compiler and contains
		information about the position where the `trace()` call was made.

		This method can be rebound to a custom function:
			var oldTrace = haxe.Log.trace; // store old function
			haxe.Log.trace = function(v, ?infos) {
			  // handle trace
			}
			...
			haxe.Log.trace = oldTrace;

		If it is bound to null, subsequent calls to `trace()` will cause an
		exception.</haxe_doc>
		</trace>
		<haxe_doc>Log primarily provides the `trace()` method, which is invoked upon a call to
	`trace()` in Haxe code.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.MainEvent" params="" file="/usr/lib/haxe/std/haxe/MainLoop.hx" module="haxe.MainLoop">
		<f><f a=""><x path="Void"/></f></f>
		<prev><c path="haxe.MainEvent"/></prev>
		<next><c path="haxe.MainEvent"/></next>
		<nextRun public="1" set="null"><x path="Float"/></nextRun>
		<priority public="1" set="null"><x path="Int"/></priority>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="haxe.MainLoop" params="" file="/usr/lib/haxe/std/haxe/MainLoop.hx">
		<pending expr="null" line="53" static="1">
			<c path="haxe.MainEvent"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</pending>
		<threadCount public="1" get="null" set="null" static="1"><x path="Int"/></threadCount>
		<sortEvents set="method" line="85" static="1"><f a=""><x path="Void"/></f></sortEvents>
		<tick set="method" line="146" static="1">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Run the pending events. Return the time for next event.</haxe_doc>
		</tick>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":access"><e>haxe.MainEvent</e></m>
		</meta>
	</class>
	<typedef path="haxe.PosInfos" params="" file="/usr/lib/haxe/std/haxe/PosInfos.hx">
		<a>
			<methodName><c path="String"/></methodName>
			<lineNumber><x path="Int"/></lineNumber>
			<fileName><c path="String"/></fileName>
			<customParams>
				<t path="Null"><c path="Array"><d/></c></t>
				<meta><m n=":optional"/></meta>
			</customParams>
			<className><c path="String"/></className>
		</a>
		<haxe_doc>PosInfos is a magic type which can be used to generate position information
	into the output for debugging use.

	If a function has a final optional argument of this type, i.e.
	(..., ?pos:haxe.PosInfos), each call to that function which does not assign
	a value to that argument has its position added as call argument.

	This can be used to track positions of calls in e.g. a unit testing
	framework.</haxe_doc>
	</typedef>
	<class path="haxe.Timer" params="" file="src/haxe/Timer.hx">
		<delay public="1" set="method" line="151" static="1">
			<f a="f:time_ms">
				<f a=""><x path="Void"/></f>
				<x path="Int"/>
				<c path="haxe.Timer"/>
			</f>
			<haxe_doc>Invokes `f` after `time_ms` milliseconds.

		This is a convenience function for creating a new Timer instance with
		`time_ms` as argument, binding its run() method to `f` and then stopping
		`this` Timer upon the first invocation.

		If `f` is null, the result is unspecified.</haxe_doc>
		</delay>
		<measure public="1" params="T" set="method" line="171" static="1">
			<f a="f:?pos">
				<f a=""><c path="measure.T"/></f>
				<t path="haxe.PosInfos"/>
				<c path="measure.T"/>
			</f>
			<haxe_doc>Measures the time it takes to execute `f`, in seconds with fractions.

		This is a convenience function for calculating the difference between
		Timer.stamp() before and after the invocation of `f`.

		The difference is passed as argument to Log.trace(), with "s" appended
		to denote the unit. The optional `pos` argument is passed through.

		If `f` is null, the result is unspecified.</haxe_doc>
		</measure>
		<stamp public="1" get="inline" set="null" line="184" static="1">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns a timestamp, in seconds with fractions.

		The value itself might differ depending on platforms, only differences
		between two values make sense.</haxe_doc>
		</stamp>
		<event><c path="haxe.MainEvent"/></event>
		<stopped expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</stopped>
		<runDelay expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</runDelay>
		<fn public="1" set="method" line="91"><f a=""><x path="Void"/></f></fn>
		<stop public="1" set="method" line="106">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Stops `this` Timer.

		After calling this method, no additional invocations of `this.run`
		will occur.

		It is not possible to restart `this` Timer once stopped.</haxe_doc>
		</stop>
		<run public="1" set="dynamic" line="138">
			<f a=""><x path="Void"/></f>
			<haxe_doc>This method is invoked repeatedly on `this` Timer.

		It can be overridden in a subclass, or rebound directly to a custom
		function:
			var timer = new haxe.Timer(1000); // 1000ms delay
			timer.run = function() { ... }

		Once bound, it can still be rebound to different functions until `this`
		Timer is stopped through a call to `this.stop`.</haxe_doc>
		</run>
		<isStopped public="1" set="method" line="204"><f a=""><x path="Bool"/></f></isStopped>
		<new public="1" set="method" line="62">
			<f a="time_ms">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new timer that will run every `time_ms` milliseconds.

		After creating the Timer instance, it calls `this.run` repeatedly,
		with delays of `time_ms` milliseconds,  until `this.stop` is called.

		The first invocation occurs after `time_ms` milliseconds, not
		immediately.

		The accuracy of this may be platform-dependent.</haxe_doc>
		</new>
		<haxe_doc>The Timer class allows you to create asynchronous timers on platforms that
	support events.

	The intended usage is to create an instance of the Timer class with a given
	interval, set its run() method to a custom function to be invoked and
	eventually call stop() to stop the Timer.

	Note that a running Timer may or may not prevent the program to exit
	automatically when main() returns.

	It is also possible to extend this class and override its run() method in
	the child class.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="haxe.io.Bytes" params="" file="/usr/lib/haxe/std/haxe/io/Bytes.hx">
		<alloc public="1" set="method" line="462" static="1"><f a="length">
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></alloc>
		<ofString public="1" set="method" line="490" static="1"><f a="s">
	<c path="String"/>
	<c path="haxe.io.Bytes"/>
</f></ofString>
		<length public="1" set="null"><x path="Int"/></length>
		<b><t path="haxe.io.BytesData"/></b>
		<sub public="1" set="method" line="133"><f a="pos:len">
	<x path="Int"/>
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></sub>
		<getString public="1" set="method" line="360"><f a="pos:len">
	<x path="Int"/>
	<x path="Int"/>
	<c path="String"/>
</f></getString>
		<toString public="1" set="method" line="423"><f a=""><c path="String"/></f></toString>
		<new set="method" line="33"><f a="length:b">
	<x path="Int"/>
	<t path="haxe.io.BytesData"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.crypto.Base64" params="" file="/usr/lib/haxe/std/haxe/crypto/Base64.hx">
		<CHARS public="1" set="null" expr="&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;" line="29" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"</e></m></meta>
		</CHARS>
		<BYTES public="1" set="null" expr="haxe.io.Bytes.ofString(CHARS)" line="30" static="1">
			<c path="haxe.io.Bytes"/>
			<meta><m n=":value"><e>haxe.io.Bytes.ofString(CHARS)</e></m></meta>
		</BYTES>
		<encode public="1" set="method" line="32" static="1">
			<f a="bytes:?complement" v=":true">
				<c path="haxe.io.Bytes"/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ complement : true }</e></m></meta>
		</encode>
		<haxe_doc>Allows to encode/decode String and bytes using Base64 encoding.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.crypto.BaseCode" params="" file="/usr/lib/haxe/std/haxe/crypto/BaseCode.hx">
		<base><c path="haxe.io.Bytes"/></base>
		<nbits><x path="Int"/></nbits>
		<encodeBytes public="1" set="method" line="44"><f a="b">
	<c path="haxe.io.Bytes"/>
	<c path="haxe.io.Bytes"/>
</f></encodeBytes>
		<new public="1" set="method" line="33"><f a="base">
	<c path="haxe.io.Bytes"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Allows to encode/decode String and bytes using a power of two base dictionary.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.crypto.Sha1" params="" file="/usr/lib/haxe/std/haxe/crypto/Sha1.hx">
		<make public="1" set="method" line="39" static="1"><f a="b">
	<c path="haxe.io.Bytes"/>
	<c path="haxe.io.Bytes"/>
</f></make>
		<bytes2blks set="method" line="127" static="1"><f a="b">
	<c path="haxe.io.Bytes"/>
	<c path="Array"><x path="Int"/></c>
</f></bytes2blks>
		<doEncode set="method" line="61"><f a="x">
	<c path="Array"><x path="Int"/></c>
	<c path="Array"><x path="Int"/></c>
</f></doEncode>
		<ft set="method" line="154">
			<f a="t:b:c:d">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Perform the appropriate triplet combination function for the current iteration</haxe_doc>
		</ft>
		<kt set="method" line="164">
			<f a="t">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Determine the appropriate additive constant for the current iteration</haxe_doc>
		</kt>
		<new set="method" line="58"><f a=""><x path="Void"/></f></new>
		<haxe_doc>Creates a Sha1 of a String.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<abstract path="haxe.ds.HashMap" params="K:V" file="/usr/lib/haxe/std/haxe/ds/HashMap.hx">
		<this><c path="haxe.ds._HashMap.HashMapData">
	<c path="haxe.ds.HashMap.K"/>
	<c path="haxe.ds.HashMap.V"/>
</c></this>
		<haxe_doc>HashMap allows mapping of hashable objects to arbitrary values.

	See `Map` for documentation details.

	@see https://haxe.org/manual/std-Map.html</haxe_doc>
		<impl><class path="haxe.ds._HashMap.HashMap_Impl_" params="" file="/usr/lib/haxe/std/haxe/ds/HashMap.hx" private="1" module="haxe.ds.HashMap"><meta>
	<m n=":keep"/>
	<m n=":final"/>
</meta></class></impl>
	</abstract>
	<class path="haxe.ds.IntMap" params="T" file="/usr/lib/haxe/std/haxe/ds/IntMap.hx" extern="1">
		<implements path="haxe.IMap">
			<x path="Int"/>
			<c path="haxe.ds.IntMap.T"/>
		</implements>
		<set public="1" set="method">
			<f a="key:value">
				<x path="Int"/>
				<c path="haxe.ds.IntMap.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>See `Map.set`</haxe_doc>
		</set>
		<get public="1" set="method">
			<f a="key">
				<x path="Int"/>
				<t path="Null"><c path="haxe.ds.IntMap.T"/></t>
			</f>
			<haxe_doc>See `Map.get`</haxe_doc>
		</get>
		<exists public="1" set="method">
			<f a="key">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.exists`</haxe_doc>
		</exists>
		<remove public="1" set="method">
			<f a="key">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.remove`</haxe_doc>
		</remove>
		<keys public="1" set="method">
			<f a=""><t path="Iterator"><x path="Int"/></t></f>
			<haxe_doc>See `Map.keys`</haxe_doc>
		</keys>
		<iterator public="1" set="method">
			<f a=""><t path="Iterator"><c path="haxe.ds.IntMap.T"/></t></f>
			<haxe_doc>See `Map.iterator`</haxe_doc>
		</iterator>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>See `Map.toString`</haxe_doc>
		</toString>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new IntMap.</haxe_doc>
		</new>
		<haxe_doc>IntMap allows mapping of Int keys to arbitrary values.

	See `Map` for documentation details.

	@see https://haxe.org/manual/std-Map.html</haxe_doc>
	</class>
	<class path="haxe.ds.ObjectMap" params="K:V" file="/usr/lib/haxe/std/haxe/ds/ObjectMap.hx" extern="1">
		<implements path="haxe.IMap">
			<c path="haxe.ds.ObjectMap.K"/>
			<c path="haxe.ds.ObjectMap.V"/>
		</implements>
		<set public="1" set="method">
			<f a="key:value">
				<c path="haxe.ds.ObjectMap.K"/>
				<c path="haxe.ds.ObjectMap.V"/>
				<x path="Void"/>
			</f>
			<haxe_doc>See `Map.set`</haxe_doc>
		</set>
		<get public="1" set="method">
			<f a="key">
				<c path="haxe.ds.ObjectMap.K"/>
				<t path="Null"><c path="haxe.ds.ObjectMap.V"/></t>
			</f>
			<haxe_doc>See `Map.get`</haxe_doc>
		</get>
		<exists public="1" set="method">
			<f a="key">
				<c path="haxe.ds.ObjectMap.K"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.exists`</haxe_doc>
		</exists>
		<remove public="1" set="method">
			<f a="key">
				<c path="haxe.ds.ObjectMap.K"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.remove`</haxe_doc>
		</remove>
		<keys public="1" set="method">
			<f a=""><t path="Iterator"><c path="haxe.ds.ObjectMap.K"/></t></f>
			<haxe_doc>See `Map.keys`</haxe_doc>
		</keys>
		<iterator public="1" set="method">
			<f a=""><t path="Iterator"><c path="haxe.ds.ObjectMap.V"/></t></f>
			<haxe_doc>See `Map.iterator`</haxe_doc>
		</iterator>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>See `Map.toString`</haxe_doc>
		</toString>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new ObjectMap.</haxe_doc>
		</new>
		<haxe_doc>ObjectMap allows mapping of object keys to arbitrary values.

	On static targets, the keys are considered to be strong references. Refer
	to `haxe.ds.WeakMap` for a weak reference version.

	See `Map` for documentation details.

	@see https://haxe.org/manual/std-Map.html</haxe_doc>
	</class>
	<class path="haxe.ds.StringMap" params="T" file="/usr/lib/haxe/std/haxe/ds/StringMap.hx" extern="1">
		<implements path="haxe.IMap">
			<c path="String"/>
			<c path="haxe.ds.StringMap.T"/>
		</implements>
		<set public="1" set="method">
			<f a="key:value">
				<c path="String"/>
				<c path="haxe.ds.StringMap.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>See `Map.set`</haxe_doc>
		</set>
		<get public="1" set="method">
			<f a="key">
				<c path="String"/>
				<t path="Null"><c path="haxe.ds.StringMap.T"/></t>
			</f>
			<haxe_doc>See `Map.get`</haxe_doc>
		</get>
		<exists public="1" set="method">
			<f a="key">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.exists`</haxe_doc>
		</exists>
		<remove public="1" set="method">
			<f a="key">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.remove`</haxe_doc>
		</remove>
		<keys public="1" set="method">
			<f a=""><t path="Iterator"><c path="String"/></t></f>
			<haxe_doc>See `Map.keys`</haxe_doc>
		</keys>
		<iterator public="1" set="method">
			<f a=""><t path="Iterator"><c path="haxe.ds.StringMap.T"/></t></f>
			<haxe_doc>See `Map.iterator`</haxe_doc>
		</iterator>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>See `Map.toString`</haxe_doc>
		</toString>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new StringMap.</haxe_doc>
		</new>
		<haxe_doc>StringMap allows mapping of String keys to arbitrary values.

	See `Map` for documentation details.

	@see https://haxe.org/manual/std-Map.html</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="haxe.extern.EitherType" params="T1:T2" file="/usr/lib/haxe/std/haxe/extern/EitherType.hx">
		<from>
			<icast><c path="haxe.extern.EitherType.T2"/></icast>
			<icast><c path="haxe.extern.EitherType.T1"/></icast>
		</from>
		<this><d/></this>
		<to>
			<icast><c path="haxe.extern.EitherType.T2"/></icast>
			<icast><c path="haxe.extern.EitherType.T1"/></icast>
		</to>
		<haxe_doc><![CDATA[An abstract type allowing values to be either of `T1` or `T2` type.
	Supports implicit casts from/to either types.

	It is useful for interfacing with external code on dynamic platforms
	such as JavaScript or Python.

	Otherwise, use of this type is discouraged.
	
	@see <https://haxe.org/manual/lf-externs.html>]]></haxe_doc>
		<impl><class path="haxe.extern._EitherType.EitherType_Impl_" params="" file="/usr/lib/haxe/std/haxe/extern/EitherType.hx" private="1" module="haxe.extern.EitherType"><meta>
	<m n=":keep"/>
	<m n=":final"/>
</meta></class></impl>
	</abstract>
	<class path="haxe.format.JsonParser" params="" file="/usr/lib/haxe/std/haxe/format/JsonParser.hx">
		<str><c path="String"/></str>
		<pos><x path="Int"/></pos>
		<parseRec set="method" line="56"><f a=""><d/></f></parseRec>
		<parseString set="method" line="138"><f a=""><c path="String"/></f></parseString>
		<invalidChar set="method" line="249"><f a=""><x path="Void"/></f></invalidChar>
		<invalidNumber set="method" line="254"><f a="start">
	<x path="Int"/>
	<x path="Void"/>
</f></invalidNumber>
		<new set="method" line="51"><f a="str">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>An implementation of JSON parser in Haxe.

	This class is used by `haxe.Json` when native JSON implementation
	is not available.

	@see https://haxe.org/manual/std-Json-parsing.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.format.JsonPrinter" params="" file="/usr/lib/haxe/std/haxe/format/JsonPrinter.hx">
		<print public="1" set="method" line="44" static="1">
			<f a="o:?replacer:?space">
				<d/>
				<f a=":">
					<d/>
					<d/>
					<d/>
				</f>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Encodes `o`'s value and returns the resulting JSON string.

		If `replacer` is given and is not null, it is used to retrieve
		actual object to be encoded. The `replacer` function takes two parameters,
		the key and the value being encoded. Initial key value is an empty string.

		If `space` is given and is not null, the result will be pretty-printed.
		Successive levels will be indented by this string.</haxe_doc>
		</print>
		<buf><c path="StringBuf"/></buf>
		<replacer><f a=":">
	<d/>
	<d/>
	<d/>
</f></replacer>
		<indent><c path="String"/></indent>
		<pretty><x path="Bool"/></pretty>
		<nind><x path="Int"/></nind>
		<write set="method" line="79"><f a="k:v">
	<d/>
	<d/>
	<x path="Void"/>
</f></write>
		<fieldsString set="method" line="167"><f a="v:fields">
	<d/>
	<c path="Array"><c path="String"/></c>
	<x path="Void"/>
</f></fieldsString>
		<quote set="method" line="193"><f a="s">
	<c path="String"/>
	<x path="Void"/>
</f></quote>
		<new set="method" line="56"><f a="replacer:space">
	<f a=":">
		<d/>
		<d/>
		<d/>
	</f>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>An implementation of JSON printer in Haxe.

	This class is used by `haxe.Json` when native JSON implementation
	is not available.

	@see https://haxe.org/manual/std-Json-encoding.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.io.BytesBuffer" params="" file="/usr/lib/haxe/std/haxe/io/BytesBuffer.hx">
		<b><c path="Array"><x path="Int"/></c></b>
		<length public="1" get="null" set="null">
			<x path="Int"/>
			<haxe_doc>The length of the buffer in bytes.</haxe_doc>
		</length>
		<getBytes public="1" set="method" line="191">
			<f a=""><c path="haxe.io.Bytes"/></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns either a copy or a reference of the current bytes.
		Once called, the buffer can no longer be used.</haxe_doc>
		</getBytes>
		<new public="1" set="method" line="45"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<typedef path="haxe.io.BytesData" params="" file="/usr/lib/haxe/std/haxe/io/BytesData.hx"><c path="Array"><x path="Int"/></c></typedef>
	<class path="haxe.io.Input" params="" file="/usr/lib/haxe/std/haxe/io/Input.hx">
		<readByte public="1" set="method" line="49">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Read and return one byte.</haxe_doc>
		</readByte>
		<readBytes public="1" set="method" line="64">
			<f a="s:pos:len">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Read `len` bytes and write them into `s` to the position specified by `pos`.

		Returns the actual length of read data that can be smaller than `len`.

		See `readFullBytes` that tries to read the exact amount of specified bytes.</haxe_doc>
		</readBytes>
		<haxe_doc>An Input is an abstract reader. See other classes in the `haxe.io` package
	for several possible implementations.

	All functions which read data throw `Eof` when the end of the stream
	is reached.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="haxe.io.Output" params="" file="/usr/lib/haxe/std/haxe/io/Output.hx">
		<writeByte public="1" set="method" line="46">
			<f a="c">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Write one byte.</haxe_doc>
		</writeByte>
		<writeBytes public="1" set="method" line="57">
			<f a="s:pos:len">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Write `len` bytes from `s` starting by position specified by `pos`.

		Returns the actual length of written data that can differ from `len`.

		See `writeFullBytes` that tries to write the exact amount of specified bytes.</haxe_doc>
		</writeBytes>
		<flush public="1" set="method" line="85">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Flush any buffered data.</haxe_doc>
		</flush>
		<close public="1" set="method" line="93">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Close the output.

		Behaviour while writing after calling this method is unspecified.</haxe_doc>
		</close>
		<write public="1" set="method" line="106">
			<f a="s">
				<c path="haxe.io.Bytes"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Write all bytes stored in `s`.</haxe_doc>
		</write>
		<writeFullBytes public="1" set="method" line="122">
			<f a="s:pos:len">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Write `len` bytes from `s` starting by position specified by `pos`.

		Unlike `writeBytes`, this method tries to write the exact `len` amount of bytes.</haxe_doc>
		</writeFullBytes>
		<prepare public="1" set="method" line="244">
			<f a="nbytes">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Inform that we are about to write at least `nbytes` bytes.

		The underlying implementation can allocate proper working space depending
		on this information, or simply ignore it. This is not a mandatory call
		but a tip and is only used in some specific cases.</haxe_doc>
		</prepare>
		<writeString public="1" set="method" line="278">
			<f a="s">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Write `s` string.</haxe_doc>
		</writeString>
		<haxe_doc>An Output is an abstract write. A specific output implementation will only
	have to override the `writeByte` and maybe the `write`, `flush` and `close`
	methods. See `File.write` and `String.write` for two ways of creating an
	Output.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="haxe.io.BytesOutput" params="" file="/usr/lib/haxe/std/haxe/io/BytesOutput.hx">
		<extends path="haxe.io.Output"/>
		<b><c path="haxe.io.BytesBuffer"/></b>
		<length public="1" get="null" set="null">
			<x path="Int"/>
			<haxe_doc>The length of the stream in bytes.</haxe_doc>
		</length>
		<writeByte public="1" set="method" line="51" override="1"><f a="c">
	<x path="Int"/>
	<x path="Void"/>
</f></writeByte>
		<writeBytes public="1" set="method" line="59" override="1"><f a="buf:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></writeBytes>
		<getBytes public="1" set="method" line="131">
			<f a=""><c path="haxe.io.Bytes"/></f>
			<haxe_doc>Returns the `Bytes` of this output.

		This function should not be called more than once on a given
		`BytesOutput` instance.</haxe_doc>
		</getBytes>
		<new public="1" set="method" line="35"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.io.Eof" params="" file="/usr/lib/haxe/std/haxe/io/Eof.hx">
		<toString set="method" line="30">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
		</toString>
		<haxe_doc>This exception is raised when reading while data is no longer available in the `haxe.io.Input`.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<enum path="haxe.io.Error" params="" file="/usr/lib/haxe/std/haxe/io/Error.hx">
		<Blocked><haxe_doc>The IO is set into nonblocking mode and some data cannot be read or written</haxe_doc></Blocked>
		<Overflow><haxe_doc>An integer value is outside its allowed range</haxe_doc></Overflow>
		<OutsideBounds><haxe_doc>An operation on Bytes is outside of its valid range</haxe_doc></OutsideBounds>
		<Custom a="e">
			<d/>
			<haxe_doc>Other errors</haxe_doc>
		</Custom>
		<haxe_doc>The possible IO errors that can occur</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<class path="haxe.net.Socket2" params="" file="src/haxe/net/Socket2.hx">
		<create_ public="1" set="dynamic" line="38" static="1">
			<f a="host:port:?secure:?debug" v="::false:false">
				<c path="String"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="haxe.net.Socket2"/>
			</f>
			<meta><m n=":value"><e>{ debug : false, secure : false }</e></m></meta>
		</create_>
		<createFromExistingSocket public="1" set="method" line="49" static="1">
			<f a="socket:?debug" v=":false">
				<c path="sys.net.Socket"/>
				<x path="Bool"/>
				<c path="haxe.net.impl.SocketSys"/>
			</f>
			<meta><m n=":value"><e>{ debug : false }</e></m></meta>
		</createFromExistingSocket>
		<host><c path="String"/></host>
		<port><x path="Int"/></port>
		<debug><x path="Bool"/></debug>
		<close public="1" set="method" line="17"><f a=""><x path="Void"/></f></close>
		<process public="1" set="method" line="20"><f a=""><x path="Void"/></f></process>
		<onconnect public="1" set="dynamic" line="23"><f a=""><x path="Void"/></f></onconnect>
		<onclose public="1" set="dynamic" line="26"><f a=""><x path="Void"/></f></onclose>
		<onerror public="1" set="dynamic" line="29"><f a=""><x path="Void"/></f></onerror>
		<ondata public="1" set="dynamic" line="32"><f a="data">
	<c path="haxe.io.Bytes"/>
	<x path="Void"/>
</f></ondata>
		<send public="1" set="method" line="35"><f a="data">
	<c path="haxe.io.Bytes"/>
	<x path="Void"/>
</f></send>
		<new set="method" line="11">
			<f a="host:port:?debug" v="::false">
				<c path="String"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ debug : false }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="haxe.net.ReadyState" params="" file="src/haxe/net/WebSocket.hx" module="haxe.net.WebSocket">
		<Connecting/>
		<Open/>
		<Closing/>
		<Closed/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="haxe.net.WebSocket" params="" file="src/haxe/net/WebSocket.hx">
		<create public="1" set="dynamic" line="17" static="1">
			<f a="url:?protocols:?origin:?debug" v=":null:null:false">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
				<c path="String"/>
				<x path="Bool"/>
				<c path="haxe.net.WebSocket"/>
			</f>
			<meta><m n=":value"><e>{ debug : false, origin : null, protocols : null }</e></m></meta>
		</create>
		<createFromAcceptedSocket public="1" set="method" line="40" static="1">
			<f a="socket:?alreadyRecieved:?debug" v=":&quot;&quot;:false">
				<c path="haxe.net.Socket2"/>
				<c path="String"/>
				<x path="Bool"/>
				<c path="haxe.net.WebSocket"/>
			</f>
			<meta><m n=":value"><e>{ debug : false, alreadyRecieved : "" }</e></m></meta>
			<haxe_doc>* create server websocket from socket returned by accept()
	 * wait for onopen() to be called before using websocket
	 * @param	socket - accepted socket 
	 * @param	alredyRecieved - data already read from socket, it should be no more then full http header
	 * @param	debug - debug messages?</haxe_doc>
		</createFromAcceptedSocket>
		<defer public="1" set="dynamic" line="45" static="1"><f a="callback">
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></defer>
		<process public="1" set="method" line="53"><f a=""><x path="Void"/></f></process>
		<sendString public="1" set="method" line="56"><f a="message">
	<c path="String"/>
	<x path="Void"/>
</f></sendString>
		<sendBytes public="1" set="method" line="59"><f a="message">
	<c path="haxe.io.Bytes"/>
	<x path="Void"/>
</f></sendBytes>
		<close public="1" set="method" line="62"><f a=""><x path="Void"/></f></close>
		<readyState public="1" get="accessor" set="null"><e path="haxe.net.ReadyState"/></readyState>
		<get_readyState set="method" line="66"><f a=""><e path="haxe.net.ReadyState"/></f></get_readyState>
		<onopen public="1" set="dynamic" line="71"><f a=""><x path="Void"/></f></onopen>
		<onerror public="1" set="dynamic" line="74"><f a="message">
	<c path="String"/>
	<x path="Void"/>
</f></onerror>
		<onmessageString public="1" set="dynamic" line="77"><f a="message">
	<c path="String"/>
	<x path="Void"/>
</f></onmessageString>
		<onmessageBytes public="1" set="dynamic" line="80"><f a="message">
	<c path="haxe.io.Bytes"/>
	<x path="Void"/>
</f></onmessageBytes>
		<onclose public="1" set="dynamic" line="83"><f a=""><x path="Void"/></f></onclose>
		<new set="method" line="14"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="haxe.net.impl.BytesRW" params="" file="src/haxe/net/impl/BytesRW.hx">
		<available public="1" set="null" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</available>
		<currentOffset expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</currentOffset>
		<currentData expr="null">
			<c path="haxe.io.Bytes"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</currentData>
		<chunks expr="[]">
			<c path="Array"><c path="haxe.io.Bytes"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</chunks>
		<writeByte public="1" set="method" line="14"><f a="v">
	<x path="Int"/>
	<x path="Void"/>
</f></writeByte>
		<writeShort public="1" set="method" line="20"><f a="v">
	<x path="Int"/>
	<x path="Void"/>
</f></writeShort>
		<writeInt public="1" set="method" line="27"><f a="v">
	<x path="Int"/>
	<x path="Void"/>
</f></writeInt>
		<writeBytes public="1" set="method" line="36"><f a="data">
	<c path="haxe.io.Bytes"/>
	<x path="Void"/>
</f></writeBytes>
		<readAllAvailableBytes public="1" set="method" line="41"><f a=""><c path="haxe.io.Bytes"/></f></readAllAvailableBytes>
		<readBytes public="1" set="method" line="45"><f a="count">
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></readBytes>
		<readUnsignedShort public="1" set="method" line="52"><f a=""><x path="UInt"/></f></readUnsignedShort>
		<readUnsignedInt public="1" set="method" line="58"><f a=""><x path="UInt"/></f></readUnsignedInt>
		<readByte public="1" set="method" line="66"><f a=""><x path="Int"/></f></readByte>
		<new public="1" set="method" line="10"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="haxe.net.impl.SocketSys" params="" file="src/haxe/net/impl/SocketSys.hx">
		<extends path="haxe.net.Socket2"/>
		<create public="1" set="method" line="54" static="1">
			<f a="host:port:secure:?debug" v=":::false">
				<c path="String"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="haxe.net.impl.SocketSys"/>
			</f>
			<meta><m n=":value"><e>{ debug : false }</e></m></meta>
		</create>
		<createFromExistingSocket set="method" line="58" static="1">
			<f a="socket:?debug" v=":false">
				<c path="sys.net.Socket"/>
				<x path="Bool"/>
				<c path="haxe.net.impl.SocketSys"/>
			</f>
			<meta><m n=":value"><e>{ debug : false }</e></m></meta>
		</createFromExistingSocket>
		<impl><c path="sys.net.Socket"/></impl>
		<sendConnect expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</sendConnect>
		<sendError expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</sendError>
		<wasCloseSent expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</wasCloseSent>
		<secure><x path="Bool"/></secure>
		<isClosed expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</isClosed>
		<initialize set="method" line="18"><f a="secure">
	<x path="Bool"/>
	<c path="haxe.net.impl.SocketSys"/>
</f></initialize>
		<close public="1" set="method" line="72" override="1"><f a=""><x path="Void"/></f></close>
		<process public="1" set="method" line="82" override="1"><f a=""><x path="Void"/></f></process>
		<onconnect public="1" set="dynamic" line="129" override="1"><f a=""><x path="Void"/></f></onconnect>
		<onclose public="1" set="dynamic" line="132" override="1"><f a=""><x path="Void"/></f></onclose>
		<onerror public="1" set="dynamic" line="135" override="1"><f a=""><x path="Void"/></f></onerror>
		<ondata public="1" set="dynamic" line="138" override="1"><f a="data">
	<c path="haxe.io.Bytes"/>
	<x path="Void"/>
</f></ondata>
		<send public="1" set="method" line="141" override="1"><f a="data">
	<c path="haxe.io.Bytes"/>
	<x path="Void"/>
</f></send>
		<new set="method" line="16">
			<f a="host:port:?debug" v="::false">
				<c path="String"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ debug : false }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="haxe.net.impl.WebSocketGeneric" params="" file="src/haxe/net/impl/WebSocketGeneric.hx">
		<extends path="haxe.net.WebSocket"/>
		<create_ public="1" set="method" line="72" static="1">
			<f a="uri:?protocols:?origin:?key:debug" v=":null:null:&quot;wskey&quot;:">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
				<c path="haxe.net.impl.WebSocketGeneric"/>
			</f>
			<meta><m n=":value"><e>{ key : "wskey", origin : null, protocols : null }</e></m></meta>
		</create_>
		<createFromAcceptedSocket_ public="1" set="method" line="76" static="1">
			<f a="socket:?alreadyRecieved:debug" v=":&quot;&quot;:">
				<c path="haxe.net.Socket2"/>
				<c path="String"/>
				<x path="Bool"/>
				<c path="haxe.net.impl.WebSocketGeneric"/>
			</f>
			<meta><m n=":value"><e>{ alreadyRecieved : "" }</e></m></meta>
		</createFromAcceptedSocket_>
		<generateMask set="method" line="367" static="1"><f a=""><c path="haxe.io.Bytes"/></f></generateMask>
		<applyMask set="method" line="376" static="1"><f a="payload:mask">
	<c path="haxe.io.Bytes"/>
	<c path="haxe.io.Bytes"/>
	<c path="haxe.io.Bytes"/>
</f></applyMask>
		<socket><c path="haxe.net.Socket2"/></socket>
		<origin expr="&quot;http://127.0.0.1/&quot;">
			<c path="String"/>
			<meta><m n=":value"><e>"http://127.0.0.1/"</e></m></meta>
		</origin>
		<scheme expr="&quot;ws&quot;">
			<c path="String"/>
			<meta><m n=":value"><e>"ws"</e></m></meta>
		</scheme>
		<key expr="&quot;wskey&quot;">
			<c path="String"/>
			<meta><m n=":value"><e>"wskey"</e></m></meta>
		</key>
		<host expr="&quot;127.0.0.1&quot;">
			<c path="String"/>
			<meta><m n=":value"><e>"127.0.0.1"</e></m></meta>
		</host>
		<port expr="80">
			<x path="Int"/>
			<meta><m n=":value"><e>80</e></m></meta>
		</port>
		<path public="1" set="null" expr="&quot;/&quot;">
			<c path="String"/>
			<meta><m n=":value"><e>"/"</e></m></meta>
		</path>
		<secure expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</secure>
		<protocols expr="[]">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</protocols>
		<state expr="State.Handshake">
			<e path="haxe.net.impl.State"/>
			<meta><m n=":value"><e>State.Handshake</e></m></meta>
		</state>
		<debug public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</debug>
		<needHandleData expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</needHandleData>
		<initialize set="method" line="22">
			<f a="uri:?protocols:?origin:?key:?debug" v=":null:null:&quot;wskey&quot;:false">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
				<c path="haxe.net.impl.WebSocketGeneric"/>
			</f>
			<meta><m n=":value"><e>{ debug : false, key : "wskey", origin : null, protocols : null }</e></m></meta>
		</initialize>
		<commonInitialize set="method" line="56"><f a=""><x path="Void"/></f></commonInitialize>
		<process public="1" set="method" line="87" override="1"><f a=""><x path="Void"/></f></process>
		<_debug set="method" line="94"><f a="msg:?p">
	<c path="String"/>
	<t path="haxe.PosInfos"/>
	<x path="Void"/>
</f></_debug>
		<writeBytes set="method" line="99"><f a="data">
	<c path="haxe.io.Bytes"/>
	<x path="Void"/>
</f></writeBytes>
		<socketData><c path="haxe.net.impl.BytesRW"/></socketData>
		<isFinal><x path="Bool"/></isFinal>
		<isMasked><x path="Bool"/></isMasked>
		<opcode><x path="haxe.net.impl.Opcode"/></opcode>
		<frameIsBinary><x path="Bool"/></frameIsBinary>
		<partialLength><x path="Int"/></partialLength>
		<length><x path="Int"/></length>
		<mask><c path="haxe.io.Bytes"/></mask>
		<httpHeader expr="&quot;&quot;">
			<c path="String"/>
			<meta><m n=":value"><e>""</e></m></meta>
		</httpHeader>
		<lastPong expr="null">
			<c path="Date"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</lastPong>
		<payload expr="null">
			<c path="haxe.net.impl.BytesRW"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</payload>
		<handleData set="method" line="121"><f a=""><x path="Void"/></f></handleData>
		<setClosed set="method" line="226"><f a=""><x path="Void"/></f></setClosed>
		<ping set="method" line="233"><f a=""><x path="Void"/></f></ping>
		<isHttpHeaderRead set="method" line="237"><f a=""><x path="Bool"/></f></isHttpHeaderRead>
		<readHttpHeader set="method" line="239"><f a=""><x path="Bool"/></f></readHttpHeader>
		<prepareServerHandshake set="method" line="246"><f a=""><c path="String"/></f></prepareServerHandshake>
		<prepareHttp400 set="method" line="305"><f a="message">
	<c path="String"/>
	<c path="String"/>
</f></prepareHttp400>
		<prepareClientHandshake set="method" line="314"><f a="url:host:port:key:origin">
	<c path="String"/>
	<c path="String"/>
	<x path="Int"/>
	<c path="String"/>
	<c path="String"/>
	<c path="haxe.io.Bytes"/>
</f></prepareClientHandshake>
		<close public="1" set="method" line="333" override="1"><f a=""><x path="Void"/></f></close>
		<sendFrame set="method" line="341"><f a="data:type">
	<c path="haxe.io.Bytes"/>
	<x path="haxe.net.impl.Opcode"/>
	<x path="Void"/>
</f></sendFrame>
		<get_readyState set="method" line="345" override="1"><f a=""><e path="haxe.net.ReadyState"/></f></get_readyState>
		<sendString public="1" set="method" line="357" override="1"><f a="message">
	<c path="String"/>
	<x path="Void"/>
</f></sendString>
		<sendBytes public="1" set="method" line="362" override="1"><f a="message">
	<c path="haxe.io.Bytes"/>
	<x path="Void"/>
</f></sendBytes>
		<prepareFrame set="method" line="382"><f a="data:type:isFinal">
	<c path="haxe.io.Bytes"/>
	<x path="haxe.net.impl.Opcode"/>
	<x path="Bool"/>
	<c path="haxe.io.Bytes"/>
</f></prepareFrame>
		<new set="method" line="8"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="haxe.net.impl.State" params="" file="src/haxe/net/impl/WebSocketGeneric.hx" module="haxe.net.impl.WebSocketGeneric">
		<Handshake/>
		<ServerHandshake/>
		<Head/>
		<HeadExtraLength/>
		<HeadExtraMask/>
		<Body/>
		<Closed/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<abstract path="haxe.net.impl.WebSocketCloseCode" params="" file="src/haxe/net/impl/WebSocketGeneric.hx" module="haxe.net.impl.WebSocketGeneric">
		<this><x path="Int"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="haxe.net.impl._WebSocketGeneric.WebSocketCloseCode_Impl_" params="" file="src/haxe/net/impl/WebSocketGeneric.hx" private="1" module="haxe.net.impl.WebSocketGeneric" extern="1">
	<Normal public="1" get="inline" set="null" expr="cast 1000" line="419" static="1">
		<x path="haxe.net.impl.WebSocketCloseCode"/>
		<meta>
			<m n=":value"><e>cast 1000</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Normal>
	<Shutdown public="1" get="inline" set="null" expr="cast 1001" line="420" static="1">
		<x path="haxe.net.impl.WebSocketCloseCode"/>
		<meta>
			<m n=":value"><e>cast 1001</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Shutdown>
	<ProtocolError public="1" get="inline" set="null" expr="cast 1002" line="421" static="1">
		<x path="haxe.net.impl.WebSocketCloseCode"/>
		<meta>
			<m n=":value"><e>cast 1002</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ProtocolError>
	<DataError public="1" get="inline" set="null" expr="cast 1003" line="422" static="1">
		<x path="haxe.net.impl.WebSocketCloseCode"/>
		<meta>
			<m n=":value"><e>cast 1003</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DataError>
	<Reserved1 public="1" get="inline" set="null" expr="cast 1004" line="423" static="1">
		<x path="haxe.net.impl.WebSocketCloseCode"/>
		<meta>
			<m n=":value"><e>cast 1004</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Reserved1>
	<NoStatus public="1" get="inline" set="null" expr="cast 1005" line="424" static="1">
		<x path="haxe.net.impl.WebSocketCloseCode"/>
		<meta>
			<m n=":value"><e>cast 1005</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NoStatus>
	<CloseError public="1" get="inline" set="null" expr="cast 1006" line="425" static="1">
		<x path="haxe.net.impl.WebSocketCloseCode"/>
		<meta>
			<m n=":value"><e>cast 1006</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</CloseError>
	<UTF8Error public="1" get="inline" set="null" expr="cast 1007" line="426" static="1">
		<x path="haxe.net.impl.WebSocketCloseCode"/>
		<meta>
			<m n=":value"><e>cast 1007</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</UTF8Error>
	<PolicyError public="1" get="inline" set="null" expr="cast 1008" line="427" static="1">
		<x path="haxe.net.impl.WebSocketCloseCode"/>
		<meta>
			<m n=":value"><e>cast 1008</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</PolicyError>
	<TooLargeMessage public="1" get="inline" set="null" expr="cast 1009" line="428" static="1">
		<x path="haxe.net.impl.WebSocketCloseCode"/>
		<meta>
			<m n=":value"><e>cast 1009</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</TooLargeMessage>
	<ClientExtensionError public="1" get="inline" set="null" expr="cast 1010" line="429" static="1">
		<x path="haxe.net.impl.WebSocketCloseCode"/>
		<meta>
			<m n=":value"><e>cast 1010</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ClientExtensionError>
	<ServerRequestError public="1" get="inline" set="null" expr="cast 1011" line="430" static="1">
		<x path="haxe.net.impl.WebSocketCloseCode"/>
		<meta>
			<m n=":value"><e>cast 1011</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ServerRequestError>
	<TLSError public="1" get="inline" set="null" expr="cast 1015" line="431" static="1">
		<x path="haxe.net.impl.WebSocketCloseCode"/>
		<meta>
			<m n=":value"><e>cast 1015</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</TLSError>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="haxe.net.impl._WebSocketGeneric.WebSocketCloseCode_Impl_" params="" file="src/haxe/net/impl/WebSocketGeneric.hx" private="1" module="haxe.net.impl.WebSocketGeneric" extern="1">
		<Normal public="1" get="inline" set="null" expr="cast 1000" line="419" static="1">
			<x path="haxe.net.impl.WebSocketCloseCode"/>
			<meta>
				<m n=":value"><e>cast 1000</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Normal>
		<Shutdown public="1" get="inline" set="null" expr="cast 1001" line="420" static="1">
			<x path="haxe.net.impl.WebSocketCloseCode"/>
			<meta>
				<m n=":value"><e>cast 1001</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Shutdown>
		<ProtocolError public="1" get="inline" set="null" expr="cast 1002" line="421" static="1">
			<x path="haxe.net.impl.WebSocketCloseCode"/>
			<meta>
				<m n=":value"><e>cast 1002</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ProtocolError>
		<DataError public="1" get="inline" set="null" expr="cast 1003" line="422" static="1">
			<x path="haxe.net.impl.WebSocketCloseCode"/>
			<meta>
				<m n=":value"><e>cast 1003</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DataError>
		<Reserved1 public="1" get="inline" set="null" expr="cast 1004" line="423" static="1">
			<x path="haxe.net.impl.WebSocketCloseCode"/>
			<meta>
				<m n=":value"><e>cast 1004</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Reserved1>
		<NoStatus public="1" get="inline" set="null" expr="cast 1005" line="424" static="1">
			<x path="haxe.net.impl.WebSocketCloseCode"/>
			<meta>
				<m n=":value"><e>cast 1005</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NoStatus>
		<CloseError public="1" get="inline" set="null" expr="cast 1006" line="425" static="1">
			<x path="haxe.net.impl.WebSocketCloseCode"/>
			<meta>
				<m n=":value"><e>cast 1006</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</CloseError>
		<UTF8Error public="1" get="inline" set="null" expr="cast 1007" line="426" static="1">
			<x path="haxe.net.impl.WebSocketCloseCode"/>
			<meta>
				<m n=":value"><e>cast 1007</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</UTF8Error>
		<PolicyError public="1" get="inline" set="null" expr="cast 1008" line="427" static="1">
			<x path="haxe.net.impl.WebSocketCloseCode"/>
			<meta>
				<m n=":value"><e>cast 1008</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</PolicyError>
		<TooLargeMessage public="1" get="inline" set="null" expr="cast 1009" line="428" static="1">
			<x path="haxe.net.impl.WebSocketCloseCode"/>
			<meta>
				<m n=":value"><e>cast 1009</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</TooLargeMessage>
		<ClientExtensionError public="1" get="inline" set="null" expr="cast 1010" line="429" static="1">
			<x path="haxe.net.impl.WebSocketCloseCode"/>
			<meta>
				<m n=":value"><e>cast 1010</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ClientExtensionError>
		<ServerRequestError public="1" get="inline" set="null" expr="cast 1011" line="430" static="1">
			<x path="haxe.net.impl.WebSocketCloseCode"/>
			<meta>
				<m n=":value"><e>cast 1011</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ServerRequestError>
		<TLSError public="1" get="inline" set="null" expr="cast 1015" line="431" static="1">
			<x path="haxe.net.impl.WebSocketCloseCode"/>
			<meta>
				<m n=":value"><e>cast 1015</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</TLSError>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<abstract path="haxe.net.impl.Opcode" params="" file="src/haxe/net/impl/WebSocketGeneric.hx" module="haxe.net.impl.WebSocketGeneric">
		<this><x path="Int"/></this>
		<to><icast field="toInt"><x path="Int"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="haxe.net.impl._WebSocketGeneric.Opcode_Impl_" params="" file="src/haxe/net/impl/WebSocketGeneric.hx" private="1" module="haxe.net.impl.WebSocketGeneric">
	<Continuation public="1" get="inline" set="null" expr="cast 0x00" line="435" static="1">
		<x path="haxe.net.impl.Opcode"/>
		<meta>
			<m n=":value"><e>cast 0x00</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Continuation>
	<Text public="1" get="inline" set="null" expr="cast 0x01" line="436" static="1">
		<x path="haxe.net.impl.Opcode"/>
		<meta>
			<m n=":value"><e>cast 0x01</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Text>
	<Binary public="1" get="inline" set="null" expr="cast 0x02" line="437" static="1">
		<x path="haxe.net.impl.Opcode"/>
		<meta>
			<m n=":value"><e>cast 0x02</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Binary>
	<Close public="1" get="inline" set="null" expr="cast 0x08" line="438" static="1">
		<x path="haxe.net.impl.Opcode"/>
		<meta>
			<m n=":value"><e>cast 0x08</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Close>
	<Ping public="1" get="inline" set="null" expr="cast 0x09" line="439" static="1">
		<x path="haxe.net.impl.Opcode"/>
		<meta>
			<m n=":value"><e>cast 0x09</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Ping>
	<Pong public="1" get="inline" set="null" expr="cast 0x0A" line="440" static="1">
		<x path="haxe.net.impl.Opcode"/>
		<meta>
			<m n=":value"><e>cast 0x0A</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Pong>
	<toInt public="1" set="method" line="442" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</toInt>
	<meta>
		<m n=":directlyUsed"/>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="haxe.net.impl._WebSocketGeneric.Opcode_Impl_" params="" file="src/haxe/net/impl/WebSocketGeneric.hx" private="1" module="haxe.net.impl.WebSocketGeneric">
		<Continuation public="1" get="inline" set="null" expr="cast 0x00" line="435" static="1">
			<x path="haxe.net.impl.Opcode"/>
			<meta>
				<m n=":value"><e>cast 0x00</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Continuation>
		<Text public="1" get="inline" set="null" expr="cast 0x01" line="436" static="1">
			<x path="haxe.net.impl.Opcode"/>
			<meta>
				<m n=":value"><e>cast 0x01</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Text>
		<Binary public="1" get="inline" set="null" expr="cast 0x02" line="437" static="1">
			<x path="haxe.net.impl.Opcode"/>
			<meta>
				<m n=":value"><e>cast 0x02</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Binary>
		<Close public="1" get="inline" set="null" expr="cast 0x08" line="438" static="1">
			<x path="haxe.net.impl.Opcode"/>
			<meta>
				<m n=":value"><e>cast 0x08</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Close>
		<Ping public="1" get="inline" set="null" expr="cast 0x09" line="439" static="1">
			<x path="haxe.net.impl.Opcode"/>
			<meta>
				<m n=":value"><e>cast 0x09</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Ping>
		<Pong public="1" get="inline" set="null" expr="cast 0x0A" line="440" static="1">
			<x path="haxe.net.impl.Opcode"/>
			<meta>
				<m n=":value"><e>cast 0x0A</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Pong>
		<toInt public="1" set="method" line="442" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</toInt>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="haxe.net.impl.Utf8Encoder" params="" file="src/haxe/net/impl/WebSocketGeneric.hx" module="haxe.net.impl.WebSocketGeneric">
		<encode public="1" set="method" line="448" static="1"><f a="str">
	<c path="String"/>
	<c path="haxe.io.Bytes"/>
</f></encode>
		<decode public="1" set="method" line="453" static="1"><f a="data">
	<c path="haxe.io.Bytes"/>
	<c path="String"/>
</f></decode>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="sys.net.Host" params="" file="/usr/lib/haxe/std/sys/net/Host.hx" extern="1">
		<localhost public="1" set="method" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the local computer host name</haxe_doc>
		</localhost>
		<host public="1" set="null">
			<c path="String"/>
			<haxe_doc>The provided host string.</haxe_doc>
		</host>
		<ip public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The actual IP corresponding to the host.</haxe_doc>
		</ip>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the IP representation of the host</haxe_doc>
		</toString>
		<reverse public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Perform a reverse-DNS query to resolve a host name from an IP.</haxe_doc>
		</reverse>
		<new public="1" set="method">
			<f a="name">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new Host : the name can be an IP in the form "127.0.0.1" or an host name such as "google.com", in which case
		the corresponding IP address is resolved using DNS. An exception occur if the host name could not be found.</haxe_doc>
		</new>
		<haxe_doc>A given IP host name.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="sys.net.Socket" params="" file="/usr/lib/haxe/std/sys/net/Socket.hx" extern="1">
		<select public="1" set="method" static="1">
			<f a="read:write:others:?timeout">
				<c path="Array"><c path="sys.net.Socket"/></c>
				<c path="Array"><c path="sys.net.Socket"/></c>
				<c path="Array"><c path="sys.net.Socket"/></c>
				<x path="Float"/>
				<a>
					<write><c path="Array"><c path="sys.net.Socket"/></c></write>
					<read><c path="Array"><c path="sys.net.Socket"/></c></read>
					<others><c path="Array"><c path="sys.net.Socket"/></c></others>
				</a>
			</f>
			<haxe_doc>Wait until one of the sockets groups is ready for the given operation :
		 - `read`contains sockets on which we want to wait for available data to be read,
		 - `write` contains sockets on which we want to wait until we are allowed to write some data to their output buffers,
		 - `others` contains sockets on which we want to wait for exceptional conditions.
		 - `select` will block until one of the condition is met, in which case it will return the sockets for which the condition was true.
		In case a `timeout` (in seconds) is specified, select might wait at worse until the timeout expires.</haxe_doc>
		</select>
		<input public="1" set="null">
			<c path="haxe.io.Input"/>
			<haxe_doc>The stream on which you can read available data. By default the stream is blocking until the requested data is available,
		use `setBlocking(false)` or `setTimeout` to prevent infinite waiting.</haxe_doc>
		</input>
		<output public="1" set="null">
			<c path="haxe.io.Output"/>
			<haxe_doc>The stream on which you can send data. Please note that in case the output buffer you will block while writing the data, use `setBlocking(false)` or `setTimeout` to prevent that.</haxe_doc>
		</output>
		<custom public="1">
			<d/>
			<haxe_doc>A custom value that can be associated with the socket. Can be used to retrieve your custom infos after a `select`.
	*</haxe_doc>
		</custom>
		<close public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Closes the socket : make sure to properly close all your sockets or you will crash when you run out of file descriptors.</haxe_doc>
		</close>
		<read public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Read the whole data available on the socket.</haxe_doc>
		</read>
		<write public="1" set="method">
			<f a="content">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Write the whole data to the socket output.</haxe_doc>
		</write>
		<connect public="1" set="method">
			<f a="host:port">
				<c path="sys.net.Host"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Connect to the given server host/port. Throw an exception in case we couldn't successfully connect.</haxe_doc>
		</connect>
		<listen public="1" set="method">
			<f a="connections">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Allow the socket to listen for incoming questions. The parameter tells how many pending connections we can have until they get refused. Use `accept()` to accept incoming connections.</haxe_doc>
		</listen>
		<shutdown public="1" set="method">
			<f a="read:write">
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Shutdown the socket, either for reading or writing.</haxe_doc>
		</shutdown>
		<bind public="1" set="method">
			<f a="host:port">
				<c path="sys.net.Host"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Bind the socket to the given host/port so it can afterwards listen for connections there.</haxe_doc>
		</bind>
		<accept public="1" set="method">
			<f a=""><c path="sys.net.Socket"/></f>
			<haxe_doc>Accept a new connected client. This will return a connected socket on which you can read/write some data.</haxe_doc>
		</accept>
		<peer public="1" set="method">
			<f a=""><a>
	<port><x path="Int"/></port>
	<host><c path="sys.net.Host"/></host>
</a></f>
			<haxe_doc>Return the information about the other side of a connected socket.</haxe_doc>
		</peer>
		<host public="1" set="method">
			<f a=""><a>
	<port><x path="Int"/></port>
	<host><c path="sys.net.Host"/></host>
</a></f>
			<haxe_doc>Return the information about our side of a connected socket.</haxe_doc>
		</host>
		<setTimeout public="1" set="method">
			<f a="timeout">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Gives a timeout after which blocking socket operations (such as reading and writing) will abort and throw an exception.</haxe_doc>
		</setTimeout>
		<waitForRead public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Block until some data is available for read on the socket.</haxe_doc>
		</waitForRead>
		<setBlocking public="1" set="method">
			<f a="b">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Change the blocking mode of the socket. A blocking socket is the default behavior. A non-blocking socket will abort blocking operations immediately by throwing a haxe.io.Error.Blocking value.</haxe_doc>
		</setBlocking>
		<setFastSend public="1" set="method">
			<f a="b">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Allows the socket to immediately send the data when written to its output : this will cause less ping but might increase the number of packets / data size, especially when doing a lot of small writes.</haxe_doc>
		</setFastSend>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new unconnected socket.</haxe_doc>
		</new>
		<haxe_doc>A TCP socket class : allow you to both connect to a given server and exchange messages or start your own server and wait for connections.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="sys.ssl.Certificate" params="" file="/usr/lib/haxe/std/sys/ssl/Certificate.hx" extern="1">
		<loadFile public="1" set="method" static="1"><f a="file">
	<c path="String"/>
	<c path="sys.ssl.Certificate"/>
</f></loadFile>
		<loadPath public="1" set="method" static="1"><f a="path">
	<c path="String"/>
	<c path="sys.ssl.Certificate"/>
</f></loadPath>
		<fromString public="1" set="method" static="1"><f a="str">
	<c path="String"/>
	<c path="sys.ssl.Certificate"/>
</f></fromString>
		<loadDefaults public="1" set="method" static="1"><f a=""><c path="sys.ssl.Certificate"/></f></loadDefaults>
		<commonName public="1" get="accessor" set="null"><t path="Null"><c path="String"/></t></commonName>
		<altNames public="1" get="accessor" set="null"><c path="Array"><c path="String"/></c></altNames>
		<notBefore public="1" get="accessor" set="null"><c path="Date"/></notBefore>
		<notAfter public="1" get="accessor" set="null"><c path="Date"/></notAfter>
		<subject public="1" set="method"><f a="field">
	<c path="String"/>
	<t path="Null"><c path="String"/></t>
</f></subject>
		<issuer public="1" set="method"><f a="field">
	<c path="String"/>
	<t path="Null"><c path="String"/></t>
</f></issuer>
		<next public="1" set="method"><f a=""><t path="Null"><c path="sys.ssl.Certificate"/></t></f></next>
		<add public="1" set="method"><f a="pem">
	<c path="String"/>
	<x path="Void"/>
</f></add>
		<addDER public="1" set="method"><f a="der">
	<c path="haxe.io.Bytes"/>
	<x path="Void"/>
</f></addDER>
		<get_commonName set="method"><f a=""><t path="Null"><c path="String"/></t></f></get_commonName>
		<get_altNames set="method"><f a=""><c path="Array"><c path="String"/></c></f></get_altNames>
		<get_notBefore set="method"><f a=""><c path="Date"/></f></get_notBefore>
		<get_notAfter set="method"><f a=""><c path="Date"/></f></get_notAfter>
	</class>
	<class path="sys.ssl.Key" params="" file="/usr/lib/haxe/std/sys/ssl/Key.hx" extern="1">
		<loadFile public="1" set="method" static="1"><f a="file:?isPublic:?pass">
	<c path="String"/>
	<x path="Bool"/>
	<c path="String"/>
	<c path="sys.ssl.Key"/>
</f></loadFile>
		<readPEM public="1" set="method" static="1"><f a="data:isPublic:?pass">
	<c path="String"/>
	<x path="Bool"/>
	<c path="String"/>
	<c path="sys.ssl.Key"/>
</f></readPEM>
		<readDER public="1" set="method" static="1"><f a="data:isPublic">
	<c path="haxe.io.Bytes"/>
	<x path="Bool"/>
	<c path="sys.ssl.Key"/>
</f></readDER>
	</class>
	<class path="sys.ssl.Socket" params="" file="/usr/lib/haxe/std/sys/ssl/Socket.hx" extern="1">
		<extends path="sys.net.Socket"/>
		<DEFAULT_VERIFY_CERT public="1" static="1"><t path="Null"><x path="Bool"/></t></DEFAULT_VERIFY_CERT>
		<DEFAULT_CA public="1" static="1"><t path="Null"><c path="sys.ssl.Certificate"/></t></DEFAULT_CA>
		<verifyCert public="1">
			<t path="Null"><x path="Bool"/></t>
			<haxe_doc>Define if peer certificate is verified during SSL handshake.</haxe_doc>
		</verifyCert>
		<handshake public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Perform the SSL handshake.</haxe_doc>
		</handshake>
		<setCA public="1" set="method">
			<f a="cert">
				<c path="sys.ssl.Certificate"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Configure the certificate chain for peer certificate verification.</haxe_doc>
		</setCA>
		<setHostname public="1" set="method">
			<f a="name">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Configure the hostname for Server Name Indication TLS extension.</haxe_doc>
		</setHostname>
		<setCertificate public="1" set="method">
			<f a="cert:key">
				<c path="sys.ssl.Certificate"/>
				<c path="sys.ssl.Key"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Configure own certificate and private key.</haxe_doc>
		</setCertificate>
		<addSNICertificate public="1" set="method">
			<f a="cbServernameMatch:cert:key">
				<f a="">
					<c path="String"/>
					<x path="Bool"/>
				</f>
				<c path="sys.ssl.Certificate"/>
				<c path="sys.ssl.Key"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Configure additionals certificates and private keys for Server Name Indication extension.
		The callback may be called during handshake to determine the certificate to use.</haxe_doc>
		</addSNICertificate>
		<peerCertificate public="1" set="method">
			<f a=""><c path="sys.ssl.Certificate"/></f>
			<haxe_doc>Return the certificate received from the other side of a connection.</haxe_doc>
		</peerCertificate>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<haxe_doc>A TLS socket class : allow you to both connect to a given server and exchange messages or start your own server and wait for connections.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
</haxe>